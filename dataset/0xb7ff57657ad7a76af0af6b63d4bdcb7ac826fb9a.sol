{{
  "language": "Solidity",
  "sources": {
    "contracts/Positions/PositionMastercopy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Internal references\nimport \"./Position.sol\";\n\ncontract PositionMastercopy is Position {\n    constructor() {\n        // Freeze mastercopy on deployment so it can never be initialized with real arguments\n        initialized = true;\n    }\n}\n"
    },
    "contracts/Positions/Position.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Inheritance\nimport \"@openzeppelin/contracts-4.4.1/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IPosition.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts-4.4.1/utils/math/SafeMath.sol\";\n\n// Internal references\nimport \"./PositionalMarket.sol\";\n\ncontract Position is IERC20, IPosition {\n    /* ========== LIBRARIES ========== */\n\n    using SafeMath for uint;\n\n    /* ========== STATE VARIABLES ========== */\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    PositionalMarket public market;\n\n    mapping(address => uint) public override balanceOf;\n    uint public override totalSupply;\n\n    // The argument order is allowance[owner][spender]\n    mapping(address => mapping(address => uint)) private allowances;\n\n    // Enforce a 1 cent minimum amount\n    uint internal constant _MINIMUM_AMOUNT = 1e16;\n\n    address public limitOrderProvider;\n    address public thalesAMM;\n    /* ========== CONSTRUCTOR ========== */\n\n    bool public initialized = false;\n\n    function initialize(\n        string calldata _name,\n        string calldata _symbol,\n        address _limitOrderProvider,\n        address _thalesAMM\n    ) external {\n        require(!initialized, \"Positional Market already initialized\");\n        initialized = true;\n        name = _name;\n        symbol = _symbol;\n        market = PositionalMarket(msg.sender);\n        // add through constructor\n        limitOrderProvider = _limitOrderProvider;\n        thalesAMM = _thalesAMM;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        if (spender == limitOrderProvider || spender == thalesAMM) {\n            return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        } else {\n            return allowances[owner][spender];\n        }\n    }\n\n    function _requireMinimumAmount(uint amount) internal pure returns (uint) {\n        require(amount >= _MINIMUM_AMOUNT || amount == 0, \"Balance < $0.01\");\n        return amount;\n    }\n\n    function mint(address minter, uint amount) external onlyMarket {\n        _requireMinimumAmount(amount);\n        totalSupply = totalSupply.add(amount);\n        balanceOf[minter] = balanceOf[minter].add(amount); // Increment rather than assigning since a transfer may have occurred.\n\n        emit Transfer(address(0), minter, amount);\n        emit Issued(minter, amount);\n    }\n\n    // This must only be invoked after maturity.\n    function exercise(address claimant) external onlyMarket {\n        uint balance = balanceOf[claimant];\n\n        if (balance == 0) {\n            return;\n        }\n\n        balanceOf[claimant] = 0;\n        totalSupply = totalSupply.sub(balance);\n\n        emit Transfer(claimant, address(0), balance);\n        emit Burned(claimant, balance);\n    }\n\n    // This must only be invoked after maturity.\n    function exerciseWithAmount(address claimant, uint amount) external onlyMarket {\n        require(amount > 0, \"Can not exercise zero amount!\");\n\n        require(balanceOf[claimant] >= amount, \"Balance must be greather or equal amount that is burned\");\n\n        balanceOf[claimant] = balanceOf[claimant] - amount;\n        totalSupply = totalSupply.sub(amount);\n\n        emit Transfer(claimant, address(0), amount);\n        emit Burned(claimant, amount);\n    }\n\n    // This must only be invoked after the exercise window is complete.\n    // Note that any options which have not been exercised will linger.\n    function expire(address payable beneficiary) external onlyMarket {\n        selfdestruct(beneficiary);\n    }\n\n    /* ---------- ERC20 Functions ---------- */\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint _value\n    ) internal returns (bool success) {\n        market.requireUnpaused();\n        require(_to != address(0) && _to != address(this), \"Invalid address\");\n\n        uint fromBalance = balanceOf[_from];\n        require(_value <= fromBalance, \"Insufficient balance\");\n\n        balanceOf[_from] = fromBalance.sub(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) external override returns (bool success) {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _value\n    ) external override returns (bool success) {\n        if (msg.sender != limitOrderProvider && msg.sender != thalesAMM) {\n            uint fromAllowance = allowances[_from][msg.sender];\n            require(_value <= fromAllowance, \"Insufficient allowance\");\n            allowances[_from][msg.sender] = fromAllowance.sub(_value);\n        }\n        return _transfer(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint _value) external override returns (bool success) {\n        require(_spender != address(0));\n        allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function getBalanceOf(address account) external view override returns (uint) {\n        return balanceOf[account];\n    } \n\n    function getTotalSupply() external view override returns (uint) {\n        return totalSupply;\n    }\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyMarket() {\n        require(msg.sender == address(market), \"Only market allowed\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event Issued(address indexed account, uint value);\n    event Burned(address indexed account, uint value);\n}\n"
    },
    "@openzeppelin/contracts-4.4.1/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\n\nimport \"./IPositionalMarket.sol\";\n\ninterface IPosition {\n    /* ========== VIEWS / VARIABLES ========== */\n\n    function getBalanceOf(address account) external view returns (uint);\n\n    function getTotalSupply() external view returns (uint);\n\n}\n"
    },
    "@openzeppelin/contracts-4.4.1/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/Positions/PositionalMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Inheritance\nimport \"../OwnedWithInit.sol\";\nimport \"../interfaces/IPositionalMarket.sol\";\nimport \"../interfaces/IOracleInstance.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts-4.4.1/utils/math/SafeMath.sol\";\n\n// Internal references\nimport \"./PositionalMarketManager.sol\";\nimport \"./Position.sol\";\nimport \"@openzeppelin/contracts-4.4.1/token/ERC20/IERC20.sol\";\n\ncontract PositionalMarket is OwnedWithInit, IPositionalMarket {\n    /* ========== LIBRARIES ========== */\n\n    using SafeMath for uint;\n\n    /* ========== TYPES ========== */\n\n    struct Options {\n        Position up;\n        Position down;\n    }\n\n    struct Times {\n        uint maturity;\n        uint expiry;\n    }\n\n    struct OracleDetails {\n        bytes32 key;\n        uint strikePrice;\n        uint finalPrice;\n        bool customMarket;\n        address iOracleInstanceAddress;\n    }\n\n    struct PositionalMarketParameters {\n        address owner;\n        IERC20 sUSD;\n        IPriceFeed priceFeed;\n        address creator;\n        bytes32 oracleKey;\n        uint strikePrice;\n        uint[2] times; // [maturity, expiry]\n        uint deposit; // sUSD deposit\n        bool customMarket;\n        address iOracleInstanceAddress;\n        address up;\n        address down;\n        address limitOrderProvider;\n        address thalesAMM;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    Options public options;\n    Times public override times;\n    OracleDetails public oracleDetails;\n    PositionalMarketManager.Fees public override fees;\n    IPriceFeed public priceFeed;\n    IERC20 public sUSD;\n\n    IOracleInstance public iOracleInstance;\n    bool public customMarket;\n\n    // `deposited` tracks the sum of all deposits.\n    // This must explicitly be kept, in case tokens are transferred to the contract directly.\n    uint public override deposited;\n    uint public initialMint;\n    address public override creator;\n    bool public override resolved;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    bool public initialized = false;\n\n    function initialize(PositionalMarketParameters calldata _parameters) external {\n        require(!initialized, \"Positional Market already initialized\");\n        initialized = true;\n        initOwner(_parameters.owner);\n        sUSD = _parameters.sUSD;\n        priceFeed = _parameters.priceFeed;\n        creator = _parameters.creator;\n\n        oracleDetails = OracleDetails(\n            _parameters.oracleKey,\n            _parameters.strikePrice,\n            0,\n            _parameters.customMarket,\n            _parameters.iOracleInstanceAddress\n        );\n        customMarket = _parameters.customMarket;\n        iOracleInstance = IOracleInstance(_parameters.iOracleInstanceAddress);\n\n        times = Times(_parameters.times[0], _parameters.times[1]);\n\n        deposited = _parameters.deposit;\n        initialMint = _parameters.deposit;\n\n        // Instantiate the options themselves\n        options.up = Position(_parameters.up);\n        options.down = Position(_parameters.down);\n        // abi.encodePacked(\"sUP: \", _oracleKey)\n        // consider naming the option: sUpBTC>50@2021.12.31\n        options.up.initialize(\"Position Up\", \"UP\", _parameters.limitOrderProvider, _parameters.thalesAMM);\n        options.down.initialize(\"Position Down\", \"DOWN\", _parameters.limitOrderProvider, _parameters.thalesAMM);\n        _mint(creator, initialMint);\n\n        // Note: the ERC20 base contract does not have a constructor, so we do not have to worry\n        // about initializing its state separately\n    }\n\n    /* ---------- External Contracts ---------- */\n\n    function _priceFeed() internal view returns (IPriceFeed) {\n        return priceFeed;\n    }\n\n    function _manager() internal view returns (PositionalMarketManager) {\n        return PositionalMarketManager(owner);\n    }\n\n    /* ---------- Phases ---------- */\n\n    function _matured() internal view returns (bool) {\n        return times.maturity < block.timestamp;\n    }\n\n    function _expired() internal view returns (bool) {\n        return resolved && (times.expiry < block.timestamp || deposited == 0);\n    }\n\n    function phase() external view override returns (Phase) {\n        if (!_matured()) {\n            return Phase.Trading;\n        }\n        if (!_expired()) {\n            return Phase.Maturity;\n        }\n        return Phase.Expiry;\n    }\n\n    /* ---------- Market Resolution ---------- */\n\n    function _oraclePrice() internal view returns (uint price) {\n        return _priceFeed().rateForCurrency(oracleDetails.key);\n    }\n\n    function _oraclePriceAndTimestamp() internal view returns (uint price, uint updatedAt) {\n        return _priceFeed().rateAndUpdatedTime(oracleDetails.key);\n    }\n\n    function oraclePriceAndTimestamp() external view override returns (uint price, uint updatedAt) {\n        return _oraclePriceAndTimestamp();\n    }\n\n    function oraclePrice() external view override returns (uint price) {\n        return _oraclePrice();\n    }\n\n    function canResolve() public view override returns (bool) {\n        if (customMarket) {\n            return !resolved && _matured() && iOracleInstance.resolvable();\n        } else {\n            return !resolved && _matured();\n        }\n    }\n\n    function _result() internal view returns (Side) {\n        if (customMarket) {\n            return iOracleInstance.getOutcome() ? Side.Up : Side.Down;\n        } else {\n            uint price;\n            if (resolved) {\n                price = oracleDetails.finalPrice;\n            } else {\n                price = _oraclePrice();\n            }\n\n            return oracleDetails.strikePrice <= price ? Side.Up : Side.Down;\n        }\n    }\n\n    function result() external view override returns (Side) {\n        return _result();\n    }\n\n    /* ---------- Option Balances and Mints ---------- */\n\n    function _balancesOf(address account) internal view returns (uint up, uint down) {\n        return (options.up.getBalanceOf(account), options.down.getBalanceOf(account));\n    }\n\n    function balancesOf(address account) external view override returns (uint up, uint down) {\n        return _balancesOf(account);\n    }\n\n    function totalSupplies() external view override returns (uint up, uint down) {\n        return (options.up.totalSupply(), options.down.totalSupply());\n    }\n\n    function getMaximumBurnable(address account) external view override returns (uint amount) {\n        return _getMaximumBurnable(account);\n    }\n\n    function getOptions() external view override returns (IPosition up, IPosition down) {\n        up = options.up;\n        down = options.down;\n    }\n\n    function getOracleDetails()\n        external\n        view\n        override\n        returns (\n            bytes32 key,\n            uint strikePrice,\n            uint finalPrice\n        )\n    {\n        key = oracleDetails.key;\n        strikePrice = oracleDetails.strikePrice;\n        finalPrice = oracleDetails.finalPrice;\n    }\n\n    function _getMaximumBurnable(address account) internal view returns (uint amount) {\n        (uint upBalance, uint downBalance) = _balancesOf(account);\n        return (upBalance > downBalance) ? downBalance : upBalance;\n    }\n\n    /* ---------- Utilities ---------- */\n\n    function _incrementDeposited(uint value) internal returns (uint _deposited) {\n        _deposited = deposited.add(value);\n        deposited = _deposited;\n        _manager().incrementTotalDeposited(value);\n    }\n\n    function _decrementDeposited(uint value) internal returns (uint _deposited) {\n        _deposited = deposited.sub(value);\n        deposited = _deposited;\n        _manager().decrementTotalDeposited(value);\n    }\n\n    function _requireManagerNotPaused() internal view {\n        require(!_manager().paused(), \"This action cannot be performed while the contract is paused\");\n    }\n\n    function requireUnpaused() external view {\n        _requireManagerNotPaused();\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /* ---------- Minting ---------- */\n\n    function mint(uint value) external override duringMinting {\n        if (value == 0) {\n            return;\n        }\n\n        _mint(msg.sender, value);\n\n        _incrementDeposited(value);\n        _manager().transferSusdTo(msg.sender, address(this), value);\n    }\n\n    function _mint(address minter, uint amount) internal {\n        options.up.mint(minter, amount);\n        options.down.mint(minter, amount);\n\n        emit Mint(Side.Up, minter, amount);\n        emit Mint(Side.Down, minter, amount);\n    }\n\n    function burnOptionsMaximum() external override {\n        _burnOptions(msg.sender, _getMaximumBurnable(msg.sender));\n    }\n\n    function burnOptions(uint amount) external override {\n        _burnOptions(msg.sender, amount);\n    }\n\n    function _burnOptions(address account, uint amount) internal {\n        require(amount > 0, \"Can not burn zero amount!\");\n        require(_getMaximumBurnable(account) >= amount, \"There is not enough options!\");\n\n        // decrease deposit\n        _decrementDeposited(amount);\n\n        // decrease up and down options\n        options.up.exerciseWithAmount(account, amount);\n        options.down.exerciseWithAmount(account, amount);\n\n        // transfer balance\n        sUSD.transfer(account, amount);\n\n        // emit events\n        emit OptionsBurned(account, amount);\n    }\n\n    /* ---------- Custom oracle configuration ---------- */\n    function setIOracleInstance(address _address) external onlyOwner {\n        iOracleInstance = IOracleInstance(_address);\n        emit SetIOracleInstance(_address);\n    }\n\n    function setPriceFeed(address _address) external onlyOwner {\n        priceFeed = IPriceFeed(_address);\n        emit SetPriceFeed(_address);\n    }\n\n    function setsUSD(address _address) external onlyOwner {\n        sUSD = IERC20(_address);\n        emit SetsUSD(_address);\n    }\n\n    /* ---------- Market Resolution ---------- */\n\n    function resolve() external onlyOwner afterMaturity managerNotPaused {\n        require(canResolve(), \"Can not resolve market\");\n        uint price;\n        uint updatedAt;\n        if (!customMarket) {\n            (price, updatedAt) = _oraclePriceAndTimestamp();\n            oracleDetails.finalPrice = price;\n        }\n        resolved = true;\n\n        emit MarketResolved(_result(), price, updatedAt, deposited, 0, 0);\n    }\n\n    /* ---------- Claiming and Exercising Options ---------- */\n\n    function exerciseOptions() external override afterMaturity returns (uint) {\n        // The market must be resolved if it has not been.\n        // the first one to exercise pays the gas fees. Might be worth splitting it up.\n        if (!resolved) {\n            _manager().resolveMarket(address(this));\n        }\n\n        // If the account holds no options, revert.\n        (uint upBalance, uint downBalance) = _balancesOf(msg.sender);\n        require(upBalance != 0 || downBalance != 0, \"Nothing to exercise\");\n\n        // Each option only needs to be exercised if the account holds any of it.\n        if (upBalance != 0) {\n            options.up.exercise(msg.sender);\n        }\n        if (downBalance != 0) {\n            options.down.exercise(msg.sender);\n        }\n\n        // Only pay out the side that won.\n        uint payout = (_result() == Side.Up) ? upBalance : downBalance;\n        emit OptionsExercised(msg.sender, payout);\n        if (payout != 0) {\n            _decrementDeposited(payout);\n            sUSD.transfer(msg.sender, payout);\n        }\n        return payout;\n    }\n\n    /* ---------- Market Expiry ---------- */\n\n    function _selfDestruct(address payable beneficiary) internal {\n        uint _deposited = deposited;\n        if (_deposited != 0) {\n            _decrementDeposited(_deposited);\n        }\n\n        // Transfer the balance rather than the deposit value in case there are any synths left over\n        // from direct transfers.\n        uint balance = sUSD.balanceOf(address(this));\n        if (balance != 0) {\n            sUSD.transfer(beneficiary, balance);\n        }\n\n        // Destroy the option tokens before destroying the market itself.\n        options.up.expire(beneficiary);\n        options.down.expire(beneficiary);\n        selfdestruct(beneficiary);\n    }\n\n    function expire(address payable beneficiary) external onlyOwner {\n        require(_expired(), \"Unexpired options remaining\");\n        emit Expired(beneficiary);\n        _selfDestruct(beneficiary);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier duringMinting() {\n        require(!_matured(), \"Minting inactive\");\n        _;\n    }\n\n    modifier afterMaturity() {\n        require(_matured(), \"Not yet mature\");\n        _;\n    }\n\n    modifier managerNotPaused() {\n        _requireManagerNotPaused();\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event Mint(Side side, address indexed account, uint value);\n    event MarketResolved(\n        Side result,\n        uint oraclePrice,\n        uint oracleTimestamp,\n        uint deposited,\n        uint poolFees,\n        uint creatorFees\n    );\n\n    event OptionsExercised(address indexed account, uint value);\n    event OptionsBurned(address indexed account, uint value);\n    event SetZeroExAddress(address _zeroExAddress);\n    event SetZeroExAddressAtInit(address _zeroExAddress);\n    event SetsUSD(address _address);\n    event SetPriceFeed(address _address);\n    event SetIOracleInstance(address _address);\n    event Expired(address beneficiary);\n}\n"
    },
    "contracts/interfaces/IPositionalMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\n\nimport \"../interfaces/IPositionalMarketManager.sol\";\nimport \"../interfaces/IPosition.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\n\ninterface IPositionalMarket {\n    /* ========== TYPES ========== */\n\n    enum Phase {Trading, Maturity, Expiry}\n    enum Side {Up, Down}\n\n    /* ========== VIEWS / VARIABLES ========== */\n\n    function getOptions() external view returns (IPosition up, IPosition down);\n\n    function times() external view returns (uint maturity, uint destructino);\n\n    function getOracleDetails()\n        external\n        view\n        returns (\n            bytes32 key,\n            uint strikePrice,\n            uint finalPrice\n        );\n\n    function fees() external view returns (uint poolFee, uint creatorFee);\n\n    function deposited() external view returns (uint);\n\n    function creator() external view returns (address);\n\n    function resolved() external view returns (bool);\n\n    function phase() external view returns (Phase);\n\n    function oraclePrice() external view returns (uint);\n\n    function oraclePriceAndTimestamp() external view returns (uint price, uint updatedAt);\n\n    function canResolve() external view returns (bool);\n\n    function result() external view returns (Side);\n\n    function balancesOf(address account) external view returns (uint up, uint down);\n\n    function totalSupplies() external view returns (uint up, uint down);\n\n    function getMaximumBurnable(address account) external view returns (uint amount);\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function mint(uint value) external;\n\n    function exerciseOptions() external returns (uint);\n\n    function burnOptions(uint amount) external;\n\n    function burnOptionsMaximum() external;\n}\n"
    },
    "contracts/interfaces/IPositionalMarketManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\n\nimport \"../interfaces/IPositionalMarket.sol\";\n\ninterface IPositionalMarketManager {\n    /* ========== VIEWS / VARIABLES ========== */\n\n    function durations() external view returns (uint expiryDuration, uint maxTimeToMaturity);\n\n    function capitalRequirement() external view returns (uint);\n\n    function marketCreationEnabled() external view returns (bool);\n\n    function totalDeposited() external view returns (uint);\n\n    function numActiveMarkets() external view returns (uint);\n\n    function activeMarkets(uint index, uint pageSize) external view returns (address[] memory);\n\n    function numMaturedMarkets() external view returns (uint);\n\n    function maturedMarkets(uint index, uint pageSize) external view returns (address[] memory);\n\n    function isActiveMarket(address candidate) external view returns (bool);\n\n    function isKnownMarket(address candidate) external view returns (bool);\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function createMarket(\n        bytes32 oracleKey,\n        uint strikePrice,\n        uint maturity,\n        uint initialMint, // initial sUSD to mint options for,\n        bool customMarket,\n        address customOracle\n    ) external returns (IPositionalMarket);\n\n    function resolveMarket(address market) external;\n\n    function expireMarkets(address[] calldata market) external;\n\n    function transferSusdTo(\n        address sender,\n        address receiver,\n        uint amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\n\ninterface IPriceFeed {\n     // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n    \n    // Mutative functions\n    function addAggregator(bytes32 currencyKey, address aggregatorAddress) external;\n\n    function removeAggregator(bytes32 currencyKey) external;\n\n    // Views\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function getRates() external view returns (uint[] memory);\n\n    function getCurrencies() external view returns (bytes32[] memory);\n}\n"
    },
    "contracts/OwnedWithInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract OwnedWithInit {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor() {}\n\n    function initOwner(address _owner) internal {\n        require(owner == address(0), \"Init can only be called when owner is 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n"
    },
    "contracts/interfaces/IOracleInstance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IPositionalMarket.sol\";\n\ninterface IOracleInstance {\n    /* ========== VIEWS / VARIABLES ========== */\n\n    function getOutcome() external view returns (bool);\n\n    function resolvable() external view returns (bool);\n\n    // function targetName() external view returns (string memory);\n\n    // function targetOutcome() external view returns (string memory);\n\n    // function eventName() external view returns (string memory);\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n}\n"
    },
    "contracts/Positions/PositionalMarketManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Inheritance\nimport \"../interfaces/IPositionalMarketManager.sol\";\nimport \"../utils/proxy/solidity-0.8.0/ProxyOwned.sol\";\nimport \"../utils/proxy/solidity-0.8.0/ProxyPausable.sol\";\n\n// Libraries\nimport \"../utils/libraries/AddressSetLib.sol\";\nimport \"@openzeppelin/contracts-4.4.1/utils/math/SafeMath.sol\";\n\n// Internal references\nimport \"./PositionalMarketFactory.sol\";\nimport \"./PositionalMarket.sol\";\nimport \"./Position.sol\";\nimport \"../interfaces/IPositionalMarket.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"@openzeppelin/contracts-4.4.1/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract PositionalMarketManager is Initializable, ProxyOwned, ProxyPausable, IPositionalMarketManager {\n    /* ========== LIBRARIES ========== */\n\n    using SafeMath for uint;\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    /* ========== TYPES ========== */\n\n    struct Fees {\n        uint poolFee;\n        uint creatorFee;\n    }\n\n    struct Durations {\n        uint expiryDuration;\n        uint maxTimeToMaturity;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    Durations public override durations;\n    uint public override capitalRequirement;\n\n    bool public override marketCreationEnabled;\n    bool public customMarketCreationEnabled;\n\n    bool public onlyWhitelistedAddressesCanCreateMarkets;\n    mapping(address => bool) public whitelistedAddresses;\n\n    uint public override totalDeposited;\n\n    AddressSetLib.AddressSet internal _activeMarkets;\n    AddressSetLib.AddressSet internal _maturedMarkets;\n\n    PositionalMarketManager internal _migratingManager;\n\n    IPriceFeed public priceFeed;\n    IERC20 public sUSD;\n\n    address public positionalMarketFactory;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    function initialize(\n        address _owner,\n        IERC20 _sUSD,\n        IPriceFeed _priceFeed,\n        uint _expiryDuration,\n        uint _maxTimeToMaturity,\n        uint _creatorCapitalRequirement\n    ) external initializer {\n        setOwner(_owner);\n        priceFeed = _priceFeed;\n        sUSD = _sUSD;\n\n        // Temporarily change the owner so that the setters don't revert.\n        owner = msg.sender;\n\n        marketCreationEnabled = true;\n        customMarketCreationEnabled = false;\n        onlyWhitelistedAddressesCanCreateMarkets = false;\n\n        setExpiryDuration(_expiryDuration);\n        setMaxTimeToMaturity(_maxTimeToMaturity);\n        setCreatorCapitalRequirement(_creatorCapitalRequirement);\n    }\n\n    /* ========== SETTERS ========== */\n    function setPositionalMarketFactory(address _positionalMarketFactory) external onlyOwner {\n        positionalMarketFactory = _positionalMarketFactory;\n        emit SetPositionalMarketFactory(_positionalMarketFactory);\n    }\n\n    function setWhitelistedAddresses(address[] calldata _whitelistedAddresses) external onlyOwner {\n        require(_whitelistedAddresses.length > 0, \"Whitelisted addresses cannot be empty\");\n        onlyWhitelistedAddressesCanCreateMarkets = true;\n        for (uint256 index = 0; index < _whitelistedAddresses.length; index++) {\n            whitelistedAddresses[_whitelistedAddresses[index]] = true;\n        }\n    }\n\n    function disableWhitelistedAddresses() external onlyOwner {\n        onlyWhitelistedAddressesCanCreateMarkets = false;\n    }\n\n    function enableWhitelistedAddresses() external onlyOwner {\n        onlyWhitelistedAddressesCanCreateMarkets = true;\n    }\n\n    function addWhitelistedAddress(address _address) external onlyOwner {\n        whitelistedAddresses[_address] = true;\n    }\n\n    function removeWhitelistedAddress(address _address) external onlyOwner {\n        delete whitelistedAddresses[_address];\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ---------- Market Information ---------- */\n\n    function isKnownMarket(address candidate) public view override returns (bool) {\n        return _activeMarkets.contains(candidate) || _maturedMarkets.contains(candidate);\n    }\n\n    function isActiveMarket(address candidate) public view override returns (bool) {\n        return _activeMarkets.contains(candidate);\n    }\n\n    function numActiveMarkets() external view override returns (uint) {\n        return _activeMarkets.elements.length;\n    }\n\n    function activeMarkets(uint index, uint pageSize) external view override returns (address[] memory) {\n        return _activeMarkets.getPage(index, pageSize);\n    }\n\n    function numMaturedMarkets() external view override returns (uint) {\n        return _maturedMarkets.elements.length;\n    }\n\n    function maturedMarkets(uint index, uint pageSize) external view override returns (address[] memory) {\n        return _maturedMarkets.getPage(index, pageSize);\n    }\n\n    function _isValidKey(bytes32 oracleKey) internal view returns (bool) {\n        // If it has a rate, then it's possibly a valid key\n        if (priceFeed.rateForCurrency(oracleKey) != 0) {\n            // But not sUSD\n            if (oracleKey == \"sUSD\") {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /* ---------- Setters ---------- */\n\n    function setExpiryDuration(uint _expiryDuration) public onlyOwner {\n        durations.expiryDuration = _expiryDuration;\n        emit ExpiryDurationUpdated(_expiryDuration);\n    }\n\n    function setMaxTimeToMaturity(uint _maxTimeToMaturity) public onlyOwner {\n        durations.maxTimeToMaturity = _maxTimeToMaturity;\n        emit MaxTimeToMaturityUpdated(_maxTimeToMaturity);\n    }\n\n    function setCreatorCapitalRequirement(uint _creatorCapitalRequirement) public onlyOwner {\n        capitalRequirement = _creatorCapitalRequirement;\n        emit CreatorCapitalRequirementUpdated(_creatorCapitalRequirement);\n    }\n\n    function setPriceFeed(address _address) external onlyOwner {\n        priceFeed = IPriceFeed(_address);\n        emit SetPriceFeed(_address);\n    }\n\n    function setsUSD(address _address) external onlyOwner {\n        sUSD = IERC20(_address);\n        emit SetsUSD(_address);\n    }\n\n    /* ---------- Deposit Management ---------- */\n\n    function incrementTotalDeposited(uint delta) external onlyActiveMarkets notPaused {\n        totalDeposited = totalDeposited.add(delta);\n    }\n\n    function decrementTotalDeposited(uint delta) external onlyKnownMarkets notPaused {\n        // NOTE: As individual market debt is not tracked here, the underlying markets\n        //       need to be careful never to subtract more debt than they added.\n        //       This can't be enforced without additional state/communication overhead.\n        totalDeposited = totalDeposited.sub(delta);\n    }\n\n    /* ---------- Market Lifecycle ---------- */\n\n    function createMarket(\n        bytes32 oracleKey,\n        uint strikePrice,\n        uint maturity,\n        uint initialMint, // initial sUSD to mint options for,\n        bool customMarket,\n        address customOracle\n    )\n        external\n        override\n        notPaused\n        returns (\n            IPositionalMarket // no support for returning PositionalMarket polymorphically given the interface\n        )\n    {\n        require(marketCreationEnabled, \"Market creation is disabled\");\n        if (!customMarket) {\n            require(_isValidKey(oracleKey), \"Invalid key\");\n        } else {\n            if (!customMarketCreationEnabled) {\n                require(owner == msg.sender, \"Only owner can create custom markets\");\n            }\n            require(address(0) != customOracle, \"Invalid custom oracle\");\n        }\n\n        if (onlyWhitelistedAddressesCanCreateMarkets) {\n            require(whitelistedAddresses[msg.sender], \"Only whitelisted addresses can create markets\");\n        }\n\n        require(maturity <= block.timestamp + durations.maxTimeToMaturity, \"Maturity too far in the future\");\n        uint expiry = maturity.add(durations.expiryDuration);\n\n        require(block.timestamp < maturity, \"Maturity has to be in the future\");\n        // We also require maturity < expiry. But there is no need to check this.\n        // The market itself validates the capital and skew requirements.\n\n        require(capitalRequirement <= initialMint, \"Insufficient capital\");\n\n        PositionalMarket market = PositionalMarketFactory(positionalMarketFactory).createMarket(\n            PositionalMarketFactory.PositionCreationMarketParameters(\n                msg.sender,\n                sUSD,\n                priceFeed,\n                oracleKey,\n                strikePrice,\n                [maturity, expiry],\n                initialMint,\n                customMarket,\n                customOracle\n            )\n        );\n\n        _activeMarkets.add(address(market));\n\n        // The debt can't be incremented in the new market's constructor because until construction is complete,\n        // the manager doesn't know its address in order to grant it permission.\n        totalDeposited = totalDeposited.add(initialMint);\n        sUSD.transferFrom(msg.sender, address(market), initialMint);\n\n        (IPosition up, IPosition down) = market.getOptions();\n\n        emit MarketCreated(\n            address(market),\n            msg.sender,\n            oracleKey,\n            strikePrice,\n            maturity,\n            expiry,\n            address(up),\n            address(down),\n            customMarket,\n            customOracle\n        );\n        return market;\n    }\n\n    function transferSusdTo(\n        address sender,\n        address receiver,\n        uint amount\n    ) external override {\n        //only to be called by markets themselves\n        require(isKnownMarket(address(msg.sender)), \"Market unknown.\");\n        bool success = sUSD.transferFrom(sender, receiver, amount);\n        if (!success) {\n            revert(\"TransferFrom function failed\");\n        }\n    }\n\n    function resolveMarket(address market) external override {\n        require(_activeMarkets.contains(market), \"Not an active market\");\n        PositionalMarket(market).resolve();\n        _activeMarkets.remove(market);\n        _maturedMarkets.add(market);\n    }\n\n    function expireMarkets(address[] calldata markets) external override notPaused onlyOwner {\n        for (uint i = 0; i < markets.length; i++) {\n            address market = markets[i];\n\n            require(isKnownMarket(address(market)), \"Market unknown.\");\n\n            // The market itself handles decrementing the total deposits.\n            PositionalMarket(market).expire(payable(msg.sender));\n\n            // Note that we required that the market is known, which guarantees\n            // its index is defined and that the list of markets is not empty.\n            _maturedMarkets.remove(market);\n\n            emit MarketExpired(market);\n        }\n    }\n\n    function setMarketCreationEnabled(bool enabled) external onlyOwner {\n        if (enabled != marketCreationEnabled) {\n            marketCreationEnabled = enabled;\n            emit MarketCreationEnabledUpdated(enabled);\n        }\n    }\n\n    function setCustomMarketCreationEnabled(bool enabled) external onlyOwner {\n        customMarketCreationEnabled = enabled;\n        emit SetCustomMarketCreationEnabled(enabled);\n    }\n\n    function setMigratingManager(PositionalMarketManager manager) external onlyOwner {\n        _migratingManager = manager;\n        emit SetMigratingManager(address(manager));\n    }\n\n    function migrateMarkets(\n        PositionalMarketManager receivingManager,\n        bool active,\n        PositionalMarket[] calldata marketsToMigrate\n    ) external onlyOwner {\n        require(address(receivingManager) != address(this), \"Can't migrate to self\");\n\n        uint _numMarkets = marketsToMigrate.length;\n        if (_numMarkets == 0) {\n            return;\n        }\n        AddressSetLib.AddressSet storage markets = active ? _activeMarkets : _maturedMarkets;\n\n        uint runningDepositTotal;\n        for (uint i; i < _numMarkets; i++) {\n            PositionalMarket market = marketsToMigrate[i];\n            require(isKnownMarket(address(market)), \"Market unknown.\");\n\n            // Remove it from our list and deposit total.\n            markets.remove(address(market));\n            runningDepositTotal = runningDepositTotal.add(market.deposited());\n\n            // Prepare to transfer ownership to the new manager.\n            market.nominateNewOwner(address(receivingManager));\n        }\n        // Deduct the total deposits of the migrated markets.\n        totalDeposited = totalDeposited.sub(runningDepositTotal);\n        emit MarketsMigrated(receivingManager, marketsToMigrate);\n\n        // Now actually transfer the markets over to the new manager.\n        receivingManager.receiveMarkets(active, marketsToMigrate);\n    }\n\n    function receiveMarkets(bool active, PositionalMarket[] calldata marketsToReceive) external {\n        require(msg.sender == address(_migratingManager), \"Only permitted for migrating manager.\");\n\n        uint _numMarkets = marketsToReceive.length;\n        if (_numMarkets == 0) {\n            return;\n        }\n        AddressSetLib.AddressSet storage markets = active ? _activeMarkets : _maturedMarkets;\n\n        uint runningDepositTotal;\n        for (uint i; i < _numMarkets; i++) {\n            PositionalMarket market = marketsToReceive[i];\n            require(!isKnownMarket(address(market)), \"Market already known.\");\n\n            market.acceptOwnership();\n            markets.add(address(market));\n            // Update the market with the new manager address,\n            runningDepositTotal = runningDepositTotal.add(market.deposited());\n        }\n        totalDeposited = totalDeposited.add(runningDepositTotal);\n        emit MarketsReceived(_migratingManager, marketsToReceive);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyActiveMarkets() {\n        require(_activeMarkets.contains(msg.sender), \"Permitted only for active markets.\");\n        _;\n    }\n\n    modifier onlyKnownMarkets() {\n        require(isKnownMarket(msg.sender), \"Permitted only for known markets.\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event MarketCreated(\n        address market,\n        address indexed creator,\n        bytes32 indexed oracleKey,\n        uint strikePrice,\n        uint maturityDate,\n        uint expiryDate,\n        address up,\n        address down,\n        bool customMarket,\n        address customOracle\n    );\n    event MarketExpired(address market);\n    event MarketsMigrated(PositionalMarketManager receivingManager, PositionalMarket[] markets);\n    event MarketsReceived(PositionalMarketManager migratingManager, PositionalMarket[] markets);\n    event MarketCreationEnabledUpdated(bool enabled);\n    event ExpiryDurationUpdated(uint duration);\n    event MaxTimeToMaturityUpdated(uint duration);\n    event CreatorCapitalRequirementUpdated(uint value);\n    event SetPositionalMarketFactory(address _positionalMarketFactory);\n    event SetZeroExAddress(address _zeroExAddress);\n    event SetPriceFeed(address _address);\n    event SetsUSD(address _address);\n    event SetCustomMarketCreationEnabled(bool enabled);\n    event SetMigratingManager(address manager);\n}\n"
    },
    "contracts/utils/proxy/solidity-0.8.0/ProxyOwned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Clone of syntetix contract without constructor\ncontract ProxyOwned {\n    address public owner;\n    address public nominatedOwner;\n    bool private _initialized;\n    bool private _transferredAtInit;\n\n    function setOwner(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        require(!_initialized, \"Already initialized, use nominateNewOwner\");\n        _initialized = true;\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    function transferOwnershipAtInit(address proxyAddress) external onlyOwner {\n        require(proxyAddress != address(0), \"Invalid address\");\n        require(!_transferredAtInit, \"Already transferred\");\n        owner = proxyAddress;\n        _transferredAtInit = true;\n        emit OwnerChanged(owner, proxyAddress);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n"
    },
    "contracts/utils/proxy/solidity-0.8.0/ProxyPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Inheritance\nimport \"./ProxyOwned.sol\";\n\n// Clone of syntetix contract without constructor\n\ncontract ProxyPausable is ProxyOwned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    \n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = block.timestamp;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n"
    },
    "contracts/utils/libraries/AddressSetLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary AddressSetLib {\n    struct AddressSet {\n        address[] elements;\n        mapping(address => uint) indices;\n    }\n\n    function contains(AddressSet storage set, address candidate) internal view returns (bool) {\n        if (set.elements.length == 0) {\n            return false;\n        }\n        uint index = set.indices[candidate];\n        return index != 0 || set.elements[0] == candidate;\n    }\n\n    function getPage(\n        AddressSet storage set,\n        uint index,\n        uint pageSize\n    ) internal view returns (address[] memory) {\n        // NOTE: This implementation should be converted to slice operators if the compiler is updated to v0.6.0+\n        uint endIndex = index + pageSize; // The check below that endIndex <= index handles overflow.\n\n        // If the page extends past the end of the list, truncate it.\n        if (endIndex > set.elements.length) {\n            endIndex = set.elements.length;\n        }\n        if (endIndex <= index) {\n            return new address[](0);\n        }\n\n        uint n = endIndex - index; // We already checked for negative overflow.\n        address[] memory page = new address[](n);\n        for (uint i; i < n; i++) {\n            page[i] = set.elements[i + index];\n        }\n        return page;\n    }\n\n    function add(AddressSet storage set, address element) internal {\n        // Adding to a set is an idempotent operation.\n        if (!contains(set, element)) {\n            set.indices[element] = set.elements.length;\n            set.elements.push(element);\n        }\n    }\n\n    function remove(AddressSet storage set, address element) internal {\n        require(contains(set, element), \"Element not in set.\");\n        // Replace the removed element with the last element of the list.\n        uint index = set.indices[element];\n        uint lastIndex = set.elements.length - 1; // We required that element is in the list, so it is not empty.\n        if (index != lastIndex) {\n            // No need to shift the last element if it is the one we want to delete.\n            address shiftedElement = set.elements[lastIndex];\n            set.elements[index] = shiftedElement;\n            set.indices[shiftedElement] = index;\n        }\n        set.elements.pop();\n        delete set.indices[element];\n    }\n}"
    },
    "contracts/Positions/PositionalMarketFactory.sol": {
      "content": "pragma solidity ^0.8.0;\n\n// Inheritance\nimport \"../utils/proxy/solidity-0.8.0/ProxyOwned.sol\";\n\n// Internal references\nimport \"./Position.sol\";\nimport \"./PositionalMarket.sol\";\nimport \"./PositionalMarketFactory.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/IPositionalMarket.sol\";\nimport \"@openzeppelin/contracts-4.4.1/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-4.4.1/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract PositionalMarketFactory is Initializable, ProxyOwned {\n    /* ========== STATE VARIABLES ========== */\n    address public positionalMarketManager;\n\n    address public positionalMarketMastercopy;\n    address public positionMastercopy;\n\n    address public limitOrderProvider;\n    address public thalesAMM;\n\n    struct PositionCreationMarketParameters {\n        address creator;\n        IERC20 _sUSD;\n        IPriceFeed _priceFeed;\n        bytes32 oracleKey;\n        uint strikePrice;\n        uint[2] times; // [maturity, expiry]\n        uint initialMint;\n        bool customMarket;\n        address customOracle;\n    }\n\n    /* ========== INITIALIZER ========== */\n\n    function initialize(address _owner) external initializer {\n        setOwner(_owner);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function createMarket(PositionCreationMarketParameters calldata _parameters) external returns (PositionalMarket) {\n        require(positionalMarketManager == msg.sender, \"Only permitted by the manager.\");\n\n        PositionalMarket pom =\n            PositionalMarket(\n                Clones.clone(positionalMarketMastercopy)\n            );\n        Position up = Position(Clones.clone(positionMastercopy));\n        Position down = Position(Clones.clone(positionMastercopy));\n        pom.initialize(\n            PositionalMarket.PositionalMarketParameters(\n                positionalMarketManager,\n                _parameters._sUSD,\n                _parameters._priceFeed,\n                _parameters.creator,\n                _parameters.oracleKey,\n                _parameters.strikePrice,\n                _parameters.times,\n                _parameters.initialMint,\n                _parameters.customMarket,\n                _parameters.customOracle,\n                address(up),\n                address(down),\n                limitOrderProvider,\n                thalesAMM\n            )\n        );\n        emit MarketCreated(\n            address(pom),\n            _parameters.oracleKey,\n            _parameters.strikePrice,\n            _parameters.times[0],\n            _parameters.times[1],\n            _parameters.initialMint,\n            _parameters.customMarket,\n            _parameters.customOracle\n        );\n        return pom;\n    }\n\n    /* ========== SETTERS ========== */\n    function setPositionalMarketManager(address _positionalMarketManager) external onlyOwner {\n        positionalMarketManager = _positionalMarketManager;\n        emit PositionalMarketManagerChanged(_positionalMarketManager);\n    }\n\n    function setPositionalMarketMastercopy(address _positionalMarketMastercopy) external onlyOwner {\n        positionalMarketMastercopy = _positionalMarketMastercopy;\n        emit PositionalMarketMastercopyChanged(_positionalMarketMastercopy);\n    }\n\n    function setPositionMastercopy(address _positionMastercopy) external onlyOwner {\n        positionMastercopy = _positionMastercopy;\n        emit PositionMastercopyChanged(_positionMastercopy);\n    }\n\n    function setLimitOrderProvider(address _limitOrderProvider) external onlyOwner {\n        limitOrderProvider = _limitOrderProvider;\n        emit SetLimitOrderProvider(_limitOrderProvider);\n    }\n\n    function setThalesAMM(address _thalesAMM) external onlyOwner {\n        thalesAMM = _thalesAMM;\n        emit SetThalesAMM(_thalesAMM);\n    }\n\n    event PositionalMarketManagerChanged(address _positionalMarketManager);\n    event PositionalMarketMastercopyChanged(address _positionalMarketMastercopy);\n    event PositionMastercopyChanged(address _positionMastercopy);\n    event SetThalesAMM(address _thalesAMM);\n    event SetLimitOrderProvider(address _limitOrderProvider);\n    event MarketCreated(\n        address market,\n        bytes32 indexed oracleKey,\n        uint strikePrice,\n        uint maturityDate,\n        uint expiryDate,\n        uint initialMint,\n        bool customMarket,\n        address customOracle\n    );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.4.1/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}