{{
  "language": "Solidity",
  "sources": {
    "src/QiDaoFolderVGHST.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"./QiDaoFolder.sol\";\n// import \"forge-std/console.sol\";\n\ncontract QiDaoFolderVGHST is QiDaoFolder {\n  address internal constant MAI_ADDRESS = 0xa3Fa99A148fA48D14Ed51d610c367C61876997F1;\n  address internal constant MAI_PAIR_ADDRESS = 0x160532D2536175d65C03B97b0630A9802c274daD; // quickswap mai / usdc\n  address internal constant VGHST_VAULT_ADDRESS = 0x1F0aa72b980d65518e88841bA1dA075BD43fa933;\n  address internal constant VGHST_ADDRESS = 0x51195e21BDaE8722B29919db56d95Ef51FaecA6C;\n  address internal constant GHST_ADDRESS = 0x385Eeac5cB85A38A9a07A70c73e0a3271CfB54A7;\n  address internal constant AM3CRV_ADDRESS = 0xE7a24EF0C5e95Ffb0f6684b813A78F2a3AD7D171;\n  address internal constant CURVE_AAVE_POOL_ADDRESS = 0x445FE580eF8d70FF569aB36e80c647af338db351;\n  address internal constant CURVE_MAI_3POOL_ADDRESS = 0x447646e84498552e62eCF097Cc305eaBFFF09308; // coins: 0=mai, 1=am3crv\n  address internal constant QI_ADDRESS = 0x580A84C73811E1839F75d86d75d88cCa0c241fF4;\n  address internal constant USDC_ADDRESS = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\n  address internal constant USDC_GHST_PAIR_ADDRESS = 0x096C5CCb33cFc5732Bcd1f3195C13dBeFC4c82f4;\n\n  constructor() QiDaoFolder(MAI_ADDRESS, MAI_PAIR_ADDRESS, VGHST_VAULT_ADDRESS, VGHST_ADDRESS, QI_ADDRESS) {\n  }\n\n  function additionalFeeBps() pure internal override returns (uint) {\n    return 50;\n  }\n\n  function _approveSwaps() internal override {\n    IERC20(MAI_ADDRESS).approve(CURVE_MAI_3POOL_ADDRESS, type(uint).max);\n    IERC20(AM3CRV_ADDRESS).approve(CURVE_MAI_3POOL_ADDRESS, type(uint).max);\n    IERC20(MAI_ADDRESS).approve(AM3CRV_ADDRESS, type(uint).max);\n    IERC20(AM3CRV_ADDRESS).approve(CURVE_AAVE_POOL_ADDRESS, type(uint).max);\n    IERC20(USDC_ADDRESS).approve(CURVE_AAVE_POOL_ADDRESS, type(uint).max);\n    IERC20(GHST_ADDRESS).approve(VGHST_ADDRESS, type(uint).max);\n  }\n\n  function _swapMaiForToken(uint _amountMai, uint _minAmountTokenReceived) internal override {\n    // MAI -> AM3CRV\n    uint gotAm3crv = IERC20(AM3CRV_ADDRESS).balanceOf(address(this));\n    IAPool(CURVE_MAI_3POOL_ADDRESS).exchange(0, 1, _amountMai, 0);\n    gotAm3crv = IERC20(AM3CRV_ADDRESS).balanceOf(address(this)) - gotAm3crv;\n\n    // AM3CRV -> USDC\n    uint gotUsdc = IERC20(USDC_ADDRESS).balanceOf(address(this));\n    IAPool(CURVE_AAVE_POOL_ADDRESS).remove_liquidity_one_coin(gotAm3crv, 1, 0, true);\n    gotUsdc = IERC20(USDC_ADDRESS).balanceOf(address(this)) - gotUsdc;\n\n    // USDC -> GHST\n    uint gotGhst = IERC20(GHST_ADDRESS).balanceOf(address(this));\n    routerlessSwapFromAmountIn(USDC_GHST_PAIR_ADDRESS, USDC_ADDRESS, GHST_ADDRESS, gotUsdc);\n    gotGhst = IERC20(GHST_ADDRESS).balanceOf(address(this)) - gotGhst;\n\n    // GHST -> VGHST\n    uint gotVghst = IERC20(VGHST_ADDRESS).balanceOf(address(this));\n    IVGHST(VGHST_ADDRESS).enter(gotGhst);\n    gotVghst = IERC20(VGHST_ADDRESS).balanceOf(address(this)) - gotVghst;\n\n    require(\n      gotVghst >= _minAmountTokenReceived,\n      \"too much slippage\"\n    );\n    emit SwappedMaiForToken(_amountMai, gotVghst);\n  }\n\n  function _swapTokenForMai(uint _amountToken, uint _minAmountMaiReceived) internal override {\n    // VGHST -> GHST\n    uint gotGhst = IERC20(GHST_ADDRESS).balanceOf(address(this));\n    IVGHST(VGHST_ADDRESS).leave(_amountToken);\n    gotGhst = IERC20(GHST_ADDRESS).balanceOf(address(this)) - gotGhst;\n\n    // GHST -> USDC\n    uint gotUsdc = IERC20(USDC_ADDRESS).balanceOf(address(this));\n    routerlessSwapFromAmountIn(USDC_GHST_PAIR_ADDRESS, GHST_ADDRESS, USDC_ADDRESS, gotGhst);\n    gotUsdc = IERC20(USDC_ADDRESS).balanceOf(address(this)) - gotUsdc;\n\n    // USDC -> AM3CRV\n    uint gotAm3crv = IERC20(AM3CRV_ADDRESS).balanceOf(address(this));\n    uint[3] memory amounts;\n    amounts[1] = gotUsdc;\n    IAPool(CURVE_AAVE_POOL_ADDRESS).add_liquidity(amounts, 0, true);\n    gotAm3crv = IERC20(AM3CRV_ADDRESS).balanceOf(address(this)) - gotAm3crv;\n\n    // AM3CRV -> MAI\n    uint gotMai = IERC20(MAI_ADDRESS).balanceOf(address(this));\n    IAPool(CURVE_MAI_3POOL_ADDRESS).exchange(1, 0, gotAm3crv, 0);\n    gotMai = IERC20(MAI_ADDRESS).balanceOf(address(this)) - gotMai;\n\n    require(\n      gotMai >= _minAmountMaiReceived,\n      \"too much slippage\"\n    );\n    emit SwappedTokenForMai(_amountToken, gotMai);\n  }\n\n  function routerlessSwapFromAmountIn(address _pairAddress, address _tokenFrom, address _tokenTo, uint _amountIn) internal {\n    uint reservesFrom = IERC20(_tokenFrom).balanceOf(_pairAddress);\n    uint reservesTo = IERC20(_tokenTo).balanceOf(_pairAddress);\n    uint amountInWithFee = _amountIn * 997;\n    uint numerator = amountInWithFee * reservesTo;\n    uint denominator = (reservesFrom * 1000) + amountInWithFee;\n    uint exactAmountOut = numerator / denominator;\n    bool tokenToIsToken0 = _tokenTo < _tokenFrom;\n\n    IERC20(_tokenFrom).transfer(_pairAddress, _amountIn);\n\n    IUniswapV2Pair(_pairAddress).swap(\n      tokenToIsToken0 ? exactAmountOut : 0,\n      !tokenToIsToken0 ? exactAmountOut : 0,\n      address(this),\n      bytes(\"\")\n    );\n  }\n}\n"
    },
    "src/QiDaoFolder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"./interfaces.sol\";\nimport \"openzeppelin-contracts/interfaces/IERC20.sol\";\nimport \"openzeppelin-contracts/proxy/utils/UUPSUpgradeable.sol\";\n// import \"forge-std/console.sol\";\n\n/// @title QiDao Debt Folding Contract\n/// @dev This is an abstract contract that must be implemented for each vault type.\nabstract contract QiDaoFolder is UUPSUpgradeable {\n\n  function _authorizeUpgrade(address) internal override onlyOwner {}\n\n  // erc20 event\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  // other events\n  event SwappedMaiForToken(uint amountMai, uint amountToken);\n  event SwappedTokenForMai(uint amountToken, uint amountMai);\n\n  // Constants\n  enum RebalanceType { NONE, FOLD, UNFOLD, EMERGENCY_UNFOLD }\n  uint constant PRICE_PRECISION = 1e8; // qidao oracles are USD with 1e8 decimals\n  uint constant CDR_PRECISION = 1e4; // 4 decimals of precision, e.g. 11500 = 115%\n  uint constant DEFAULT_FOLD_TRIGGER_DEVIATION = 100; // e.g. rebalance at 116%\n  uint constant DEFAULT_MIN_AMOUNT_TO_FOLD = 5 * 1e18; // don't even bother looping for less than 5 MAI\n  uint constant DEFAULT_MAX_FOLDS_PER_CALL = 10; // make sure to respect gas limits\n  address constant GELATO_OPS_ADDRESS = 0xB3f5503f93d5Ef84b06993a1975B9D21B962892F;\n\n  // Immutables (set by child contract)\n\n  address immutable owner; // Owner of this contract\n  address immutable maiAddress; // Address of the MAI token\n  address immutable maiPairAddress; // Address of a univ2 pair, used to flashloan MAI for \"emergency unfolding\"\n  address immutable tokenAddress; // Address of the underlying token in the vault\n  address immutable qiAddress; // Address of the QI token\n  address immutable vaultAddress; // QiDao vault address\n\n  // Storage variables: do not change order or remove, as this contract must be upgradeable\n\n  // erc20 stuff\n  string public name;\n  string public symbol;\n  uint public totalSupply;\n  mapping(address => uint) private balances;\n\n  // folder stuff\n  uint public vaultId; // QiDao vault ID (created upon initialization)\n  uint public targetCdr; // target CDR\n  uint public maxFoldsPerCall; // maximium folds/unfolds to perform per tx\n  uint public foldTriggerDeviation; // fold when CDR deviates by this amount\n  mapping(address => bool) public depositors; // allowlist of addresses allowed to deposit in this vault\n  uint public minAmountToFold; // don't even bother looping for less than this amount of MAI\n\n  // Modifiers\n\n  modifier onlyOwner() {\n    require(owner == msg.sender, \"not owner\");\n    _;\n  }\n\n  modifier onlyOwnerOrGelato() {\n    require(owner == msg.sender || GELATO_OPS_ADDRESS == msg.sender, \"not owner or gelato\");\n    _;\n  }\n\n  modifier onlyDepositors() {\n    require(depositors[msg.sender] || owner == msg.sender, \"not depositor\");\n    _;\n  }\n\n  modifier onlyInitialized() {\n    require(vaultId != 0, \"not initialized\");\n    _;\n  }\n\n  // Initialization\n\n  // sets immutable variables only, as this will be deployed behind a proxy\n  constructor(address _maiAddress, address _maiPairAddress, address _vaultAddress, address _tokenAddress, address _qiAddress) {\n    owner = msg.sender;\n    maiAddress = _maiAddress;\n    maiPairAddress = _maiPairAddress;\n    vaultAddress = _vaultAddress;\n    tokenAddress = _tokenAddress;\n    qiAddress = _qiAddress;\n  }\n\n  /// @notice create a vault and initialize storage variables\n  /// @param _targetCdr target collateral:debt ratio with 4 decimals of precision, e.g. \"11500\" for 115%\n  function initialize(string memory _name, string memory _symbol, uint _targetCdr) external onlyOwner {\n    require(vaultId == 0, \"already initialized\");\n    name = _name;\n    symbol = _symbol;\n    maxFoldsPerCall = DEFAULT_MAX_FOLDS_PER_CALL;\n    foldTriggerDeviation = DEFAULT_FOLD_TRIGGER_DEVIATION;\n    minAmountToFold = DEFAULT_MIN_AMOUNT_TO_FOLD;\n    _setTargetCdr(_targetCdr);\n    _approveSwaps();\n    IERC20(tokenAddress).approve(vaultAddress, type(uint).max);\n    IERC20(maiAddress).approve(vaultAddress, type(uint).max);\n    vaultId = QiDaoVault(vaultAddress).createVault();\n  }\n\n  // Tokenization\n\n  function decimals() public pure returns (uint8) {\n    return 18;\n  }\n\n  function balanceOf(address _account) public view returns (uint) {\n    return balances[_account];\n  }\n\n  /// @notice invests underlying tokens and issues an ERC20 representing the depositor's share in the vault\n  /// @param _amount amount of underlying tokens to invest in the folder\n  function enter(uint _amount) external onlyDepositors onlyInitialized {\n    require(_amount > 0, \"_amount must be gt 0\");\n\n    uint toMint = totalSupply == 0 ? _amount : _amount * approximateBalanceOfUnderlying() / totalSupply;\n\n    if (toMint != 0) {\n      IERC20(tokenAddress).transferFrom(msg.sender, address(this), _amount);\n      _mint(msg.sender, toMint);\n    }\n  }\n\n  /// @notice burns ERC20 tokens and withdraws the appropriate amount of underlying tokens to the caller\n  /// @param _amount amount of underlying tokens to invest in the folder\n  function exit(uint _amount) external onlyDepositors onlyInitialized {\n    require(totalSupply > 0, \"totalSupply is zero\");\n    require(_amount > 0, \"_amount must be gt 0\");\n\n    uint amountToWithdraw = _amount * approximateBalanceOfUnderlying() / totalSupply;\n    require(amountToWithdraw <= tokenBalance(), \"not enough tokens to withdraw, must unfold first\");\n\n    IERC20(tokenAddress).transfer(msg.sender, amountToWithdraw);\n    _burn(msg.sender, _amount);\n  }\n\n  // no transfers allowed\n  function transfer(address, uint) public pure returns (bool) { return false; }\n  function transferFrom(address, address, uint) public pure returns (bool) { return false; }\n  function approve(address, uint) public pure returns (bool) { return false; }\n  function allowance(address, address) public pure returns (uint) { return 0; }\n  function increaseAllowance(address, uint) public pure returns (uint) { return 0; }\n  function decreaseAllowance(address, uint) public pure returns (uint) { return 0; }\n\n  // External\n\n  /// @param _depositor address of the depositor to add\n  function addDepositor(address _depositor) external onlyOwner {\n    depositors[_depositor] = true;\n  }\n\n  /// @param _depositor address of the depositor to remove\n  function removeDepositor(address _depositor) external onlyOwner {\n    depositors[_depositor] = false;\n  }\n\n  /// @param _vaultId new vault ID (must be owned by this contract)\n  function setVaultId(uint _vaultId) external onlyOwner {\n    require(vaultId == 0, \"already initialized\");\n    vaultId = _vaultId;\n  }\n\n  /// @param _targetCdr target collateral:debt ratio with 4 decimals of precision, e.g. \"11500\" for 115%\n  function setTargetCdr(uint _targetCdr) external onlyOwner onlyInitialized {\n    _setTargetCdr(_targetCdr);\n  }\n\n  /// @param _maxFoldsPerCall maximium folds/unfolds to perform per tx\n  function setMaxFoldsPerCall(uint _maxFoldsPerCall) external onlyOwner onlyInitialized {\n    maxFoldsPerCall = _maxFoldsPerCall;\n  }\n\n  /// @param _foldTriggerDeviation rebalance when CDR deviates by this amount\n  function setFoldTriggerDeviation(uint _foldTriggerDeviation) external onlyOwner onlyInitialized {\n    foldTriggerDeviation = _foldTriggerDeviation;\n  }\n\n  /// @param _minAmountToFold don't bother folding for less than this amount of MAI\n  function setMinAmountToFold(uint _minAmountToFold) external onlyOwner onlyInitialized {\n    minAmountToFold = _minAmountToFold;\n  }\n\n  /// @notice Rebalances the vault based on the target CDR by either folding or unfolding if necessary.\n  /// @param _minTokenReceivedPerMai minimum number of tokens to receive per MAI,\n  /// expressed with PRICE_PRECISION decimals. if fewer tokens are receieved,\n  /// the call will revert.\n  /// @param _minMaiReceivedPerToken minimum number of MAI to receive per token,\n  /// expressed with PRICE_PRECISION decimals. if fewer tokens are receieved,\n  /// the call will revert.\n  function rebalance(uint _minTokenReceivedPerMai, uint _minMaiReceivedPerToken) external onlyOwnerOrGelato onlyInitialized {\n    RebalanceType rt = _getRebalanceType();\n    require(rt != RebalanceType.NONE, \"no rebalance needed\");\n\n    if (rt == RebalanceType.EMERGENCY_UNFOLD) {\n      _emergencyUnfold(0);\n    } else if (rt == RebalanceType.FOLD) {\n      _fold(type(uint).max, _minTokenReceivedPerMai);\n    } else if (rt == RebalanceType.UNFOLD) {\n      _unfold(type(uint).max, _minMaiReceivedPerToken);\n    }\n  }\n\n  function checkRebalanceGelato() external view returns (bool canExec, bytes memory execPayload) {\n    RebalanceType rt = _getRebalanceType();\n\n    if (rt != RebalanceType.NONE) {\n      canExec = true;\n      execPayload = abi.encodeWithSelector(QiDaoFolder.rebalance.selector, 0, 0); // TODO: set min amounts\n    }\n  }\n\n  /// @notice \"Folds\" the vault's collateral by borrowing MAI, swapping for more\n  /// collateral tokens, depositing those, borrowing MAI, and repeating this process.\n  /// @param _minTokenReceivedPerMai minimum number of tokens to receive per MAI,\n  /// expressed with PRICE_PRECISION decimals. if fewer tokens are receieved,\n  /// the call will revert.\n  function fold(uint _minTokenReceivedPerMai) external onlyOwner onlyInitialized {\n    _fold(type(uint).max, _minTokenReceivedPerMai);\n  }\n\n  /// @notice \"Folds\" the vault's collateral by borrowing MAI, swapping for more\n  /// collateral tokens, depositing those, borrowing MAI, and repeating this process.\n  /// @param _maxNewDebtAmount the maximum amount of new MAI debt to borrow.\n  /// By passing this parameter, we can specify a smaller \"fold\" in\n  /// order to profit when the price of MAI is > $1.\n  /// @param _minTokenReceivedPerMai minimum number of tokens to receive per MAI,\n  /// expressed with PRICE_PRECISION decimals. if fewer tokens are receieved,\n  /// the call will revert.\n  function foldWithMaxNewDebtAmount(uint _maxNewDebtAmount, uint _minTokenReceivedPerMai) external onlyOwner onlyInitialized {\n    _fold(_maxNewDebtAmount, _minTokenReceivedPerMai);\n  }\n\n  /// @notice \"Unfolds\" the vault's debt by withdrawing the maximium available amount\n  /// of collateral, swapping it for MAI, repaying the vault's debt, then withdrawing more\n  /// collateral, and repeating this process. This function will revert if the vault is already\n  /// below the minimum CDR, in which case you must call emergencyUnfold() instead.\n  /// @param _minMaiReceivedPerToken minimum number of MAI to receive per token,\n  /// expressed with PRICE_PRECISION decimals. if fewer tokens are receieved,\n  /// the call will revert.\n  function unfold(uint _minMaiReceivedPerToken) external onlyOwner onlyInitialized {\n    _unfold(type(uint).max, _minMaiReceivedPerToken);\n  }\n\n  /// @notice \"Unfolds\" the vault's debt to the target CDR by withdrawing the maximium available amount\n  /// of collateral, swapping it for MAI, repaying the vault's debt, then withdrawing more\n  /// collateral, and repeating this process. This function will revert if the vault is already\n  /// below the minimum CDR, in which case you must call emergencyUnfold() instead.\n  /// @param _maxAmountCollateralSold the maximum amount of collateral that we want to\n  /// sell for MAI to repay the debt. By passing this parameter, we can specify a\n  /// smaller \"unfold\" in order to profit when the price of MAI is < $1.\n  /// @param _minMaiReceivedPerToken minimum number of MAI to receive per token,\n  /// expressed with PRICE_PRECISION decimals. if fewer tokens are receieved,\n  /// the call will revert.\n  function unfoldWithMaxAmountCollateralSold(uint _maxAmountCollateralSold, uint _minMaiReceivedPerToken) external onlyOwner onlyInitialized {\n    _unfold(_maxAmountCollateralSold, _minMaiReceivedPerToken);\n  }\n\n  /// @notice \"Unfolds\" as much of the vault's debt as possible, when the CDR is already below the\n  /// minimum, and no collateral can be withdrawn. This is accomplished by first borrowing MAI\n  /// from a UniV2 pool to repay some of the vault's debt, then withdrawing collateral,\n  /// swapping it for MAI, repaying more debt, and repeating this process, all before\n  /// repaying the UniV2 flash loan. In the future we could consider only unfolding to the\n  /// target CDR instead, but since this is an \"emergency\" function, we can just unfold all the way\n  /// for now.\n  /// @param _minMaiReceivedPerToken minimum number of MAI to receive per token,\n  /// expressed with PRICE_PRECISION decimals. if fewer tokens are receieved,\n  /// the call will revert.\n  function emergencyUnfold(uint _minMaiReceivedPerToken) external onlyOwner onlyInitialized {\n    _emergencyUnfold(_minMaiReceivedPerToken);\n  }\n\n  // emergency unfold continuation:\n  function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _params) external {\n    require(msg.sender == address(maiPairAddress), \"authorization: not mai pair\");\n    require(_sender == address(this), \"authorization: not us\");\n\n    (bool _maiIsToken0, uint _minMaiReceivedPerToken) = abi.decode(_params, (bool, uint));\n    uint amtReceived = _maiIsToken0 ? _amount0 : _amount1;\n    uint amountToRepay = amtReceived + (amtReceived * 3 / 997) + 1;\n    QiDaoVault(vaultAddress).payBackToken(vaultId, amtReceived);\n    _unfold(type(uint).max, _minMaiReceivedPerToken);\n\n    require(vaultDebt() == 0, \"vault still has debt after emergency unfold\");\n    _withdrawCollateral(vaultCollateral());\n\n    // We should probably swap for the correct amount instead of going back and forth like this.\n    // But this is OK for now since this is the \"emergency\" function\n    _swapTokenForMai(IERC20(tokenAddress).balanceOf(address(this)), 0);\n    require(_maiBalance() > amountToRepay, \"not enough mai to repay flashswap\");\n    IERC20(maiAddress).transfer(maiPairAddress, amountToRepay);\n    _swapMaiForToken(IERC20(maiAddress).balanceOf(address(this)), 0);\n  }\n\n  /// @notice withdraws collateral tokens from the QiDao vault.\n  /// can only be called once the vault no longer has any debt. (e.g. after unfolding completely)\n  function withdrawFromVault() external onlyOwner onlyInitialized {\n    require(vaultDebt() == 0, \"vault still has debt\");\n    _withdrawCollateral(vaultCollateral());\n  }\n\n  /// @notice \"Unfolds\" the vault's debt by withdrawing collateral, swapping it for MAI, repaying the\n  /// vault's debt, and withdrawing more collateral. This function is likely to be used when someone\n  /// wants to exit the vault, and we need to free up a certain amount of capital for them to exit.\n  /// @param _amountCollateralToWithdraw the exact amount of collateral that we want to\n  /// sell for MAI to repay the debt.\n  /// @param _minMaiReceivedPerToken minimum number of MAI to receive per token,\n  /// expressed with PRICE_PRECISION decimals. if fewer tokens are receieved,\n  /// the call will revert.\n  function withdrawFromVaultWithUnfold(uint _amountCollateralToWithdraw, uint _minMaiReceivedPerToken) external onlyOwner onlyInitialized {\n    require(vaultDebt() > 0, \"vault has no debt, call withdrawFromVault instead\");\n    require(_amountCollateralToWithdraw <= vaultCollateral(), \"not enough collateral to withdraw\");\n\n    // Find a temporary CDR target that will allow us to withdraw the appropriate amount of collateral\n    uint percentCollateralToWithdraw = _amountCollateralToWithdraw * 1e18 / vaultCollateral();\n    uint startCdr = targetCdr;\n    targetCdr = targetCdr + (vaultCdr() * percentCollateralToWithdraw / 1e18) + 50; // add a small buffer\n    _unfold(type(uint).max, _minMaiReceivedPerToken);\n    targetCdr = startCdr;\n\n    _withdrawCollateral(_amountCollateralToWithdraw);\n  }\n\n  /// @notice withdraws full balance of collateral tokens from this contract.\n  function withdrawFunds() external onlyOwner onlyInitialized {\n    IERC20(tokenAddress).transfer(owner, tokenBalance());\n  }\n\n  /// @notice withdraws full balance of Qi tokens from this contract.\n  function withdrawQi() external onlyOwner onlyInitialized {\n    IERC20(qiAddress).transfer(owner, qiBalance());\n  }\n\n  /// @notice deposits collateral tokens from this contract to the QiDao vault.\n  /// @param _amount amount of tokens to deposit\n  function depositCollateral(uint _amount) external onlyOwner onlyInitialized {\n    _depositCollateral(_amount);\n  }\n\n  /// @notice withdraw the balance of a token from the contract\n  /// @param _token token address\n  /// @param _amount token amount\n  function rescueToken(address _token, uint _amount) external onlyOwner {\n    if (_token == address(0)) {\n      payable(owner).transfer(_amount);\n    } else {\n      IERC20(_token).transfer(owner, _amount);\n    }\n  }\n\n  /// @notice \"bails out\" by transferring the underlying vault NFT to the owner\n  /// after this function is called, the folder can be initialized again if needed\n  function bailout() external onlyOwner onlyInitialized {\n    QiDaoVault(vaultAddress).safeTransferFrom(address(this), owner, vaultId);\n    vaultId = 0; // clear vaultId\n  }\n\n  // Public\n\n  /// @return amount of MAI that can be borrowed based on the CDR that we are targeting.\n  /// The return value of this function will also be capped at the current debt ceiling of vault.\n  /// Expressed with 1e18 decimals of precision.\n  function availableBorrows() view public returns (uint) {\n    uint borrowsBasedOnCdr = _availableBorrowsByTargetCdr();\n    uint borrowsBasedOnMai = QiDaoVault(vaultAddress).getDebtCeiling();\n\n    // return the min\n    return borrowsBasedOnCdr < borrowsBasedOnMai ? borrowsBasedOnCdr : borrowsBasedOnMai;\n  }\n\n  /// @return approximate USD value of the vault collateral, subtracted by the value of the vault's\n  /// debt, subtracted by the repayment fees. (swap fees are not currently taken into account.)\n  function vaultValue() view public returns (uint) {\n    uint debt = vaultDebt();\n    uint repaymentFees = debt * QiDaoVault(vaultAddress).closingFee() / 10000;\n    uint additionalFees = debt * additionalFeeBps() / 10000;\n    return _vaultCollateralValue() - debt - repaymentFees + additionalFees;\n  }\n\n  /// @return approximate underlying collateral balance, calculating by taking the vault collateral balance\n  /// and subtracting the debt and repayment fees, all converted to be in collateral units.\n  /// Note that swap fees are not accounted for in this calculation\n  function approximateBalanceOfUnderlying() view public returns (uint) {\n    uint debt = vaultDebt();\n    uint repaymentFees = debt * QiDaoVault(vaultAddress).closingFee() / 10000;\n    uint debtAndFeesInCollateral = (debt + repaymentFees) * PRICE_PRECISION / _collateralPrice();\n    require(debtAndFeesInCollateral == 0 || debtAndFeesInCollateral < vaultCollateral(), \"how is there more debt than collateral?\");\n    return tokenBalance() + vaultCollateral() - debtAndFeesInCollateral;\n  }\n\n  /// @return number of underlying tokens in this contract\n  function tokenBalance() view public returns (uint) {\n    return IERC20(tokenAddress).balanceOf(address(this));\n  }\n\n  /// @return number of Qi tokens in this contract\n  function qiBalance() view public returns (uint) {\n    return IERC20(qiAddress).balanceOf(address(this));\n  }\n\n  /// @return amount of MAI debt in the QiDao vault\n  function vaultDebt() view public returns (uint) {\n    return QiDaoVault(vaultAddress).vaultDebt(vaultId);\n  }\n\n  /// @return amount of collateral locked in the QiDao vault\n  function vaultCollateral() view public returns (uint) {\n    return QiDaoVault(vaultAddress).vaultCollateral(vaultId);\n  }\n\n  /// @return current CDR for this vault, expressed with CDR_PRECISION decimals of precision\n  function vaultCdr() view public returns (uint) {\n    uint debt = vaultDebt();\n    return debt == 0 ? type(uint).max : _vaultCollateralValue() * CDR_PRECISION / debt;\n  }\n\n  // Internal\n\n  function _fold(uint _maxNewDebtAmount, uint _minTokenReceivedPerMai) internal {\n    uint newDebtAmount;\n\n    for (uint i = 0; i < maxFoldsPerCall; i++) {\n      uint borrowAmount = availableBorrows();\n\n      if (newDebtAmount + borrowAmount > _maxNewDebtAmount) {\n        borrowAmount = _maxNewDebtAmount - newDebtAmount;\n      }\n\n      require(i > 0 || borrowAmount > 0, \"no borrows available\"); // only require borrowAmount > 0 on the first loop\n      if (vaultCdr() <= targetCdr) { break; }\n      if (borrowAmount <= minAmountToFold) { break; }\n\n      // borrow MAI\n      QiDaoVault(vaultAddress).borrowToken(vaultId, borrowAmount);\n      uint collateralBalanceBefore = tokenBalance();\n      _swapMaiForToken(borrowAmount, borrowAmount * _minTokenReceivedPerMai / PRICE_PRECISION);\n      _depositCollateral(tokenBalance() - collateralBalanceBefore);\n      newDebtAmount = newDebtAmount + borrowAmount;\n    }\n  }\n\n  function _unfold(uint _maxAmountCollateralSold, uint _minMaiReceivedPerToken) internal {\n    uint cdrBefore = vaultCdr();\n    require(cdrBefore > _vaultMinimumCdr(), \"below minimum cdr, must unfold with flashloan instead\");\n    require(vaultCdr() < targetCdr, \"no need to unfold\");\n\n    uint amountCollateralSold;\n\n    for (uint i = 0; i < maxFoldsPerCall; i++) {\n      if (vaultDebt() == 0) { break; }\n      if (vaultCdr() > targetCdr) { break; }\n\n      // withdraw collateral to unfold with\n      // TODO: withdraw less if necessary\n      uint withdrawAmt = _maxWithdrawableCollateral();\n\n      // check for _maxAmountCollateralSold\n      if (amountCollateralSold + withdrawAmt > _maxAmountCollateralSold) {\n        withdrawAmt = _maxAmountCollateralSold - amountCollateralSold;\n      }\n\n      uint approxMaiReceivedPerWithdraw = withdrawAmt * _collateralPrice() / PRICE_PRECISION;\n      uint hypotheticalNewCdr = vaultDebt() <= approxMaiReceivedPerWithdraw ? type(uint).max : ((vaultCollateral() - withdrawAmt) * _collateralPrice() / PRICE_PRECISION) * CDR_PRECISION / (vaultDebt() - approxMaiReceivedPerWithdraw);\n\n      // will the new CDR be too high? if so, adjust the amount we are withdrawing\n      if (hypotheticalNewCdr > targetCdr) {\n        uint currentCdr = vaultCdr();\n        withdrawAmt = withdrawAmt * (targetCdr - currentCdr) / (hypotheticalNewCdr - currentCdr);\n      }\n\n      if (withdrawAmt == 0) { break; }\n\n      _withdrawCollateral(withdrawAmt);\n      amountCollateralSold = amountCollateralSold + withdrawAmt;\n\n      // This is kinda hacky - ideally we can calculate the input amount needed\n      // for the exactAmountOut that we want. For now, we just use the slippage params,\n      // and swap any leftover MAI back to the token\n      uint minAmountMaiOut = withdrawAmt * _minMaiReceivedPerToken / PRICE_PRECISION;\n\n      if (minAmountMaiOut > vaultDebt()) {\n        withdrawAmt = vaultDebt() * _minMaiReceivedPerToken / PRICE_PRECISION;\n        minAmountMaiOut = withdrawAmt * _minMaiReceivedPerToken / PRICE_PRECISION;\n      }\n\n      _swapTokenForMai(withdrawAmt, minAmountMaiOut);\n      _repayAvailableMaiDebt();\n\n      // Swap leftover MAI back to the token...\n      if (vaultDebt() == 0 && _maiBalance() > 0) {\n        _swapMaiForToken(_maiBalance(), 0);\n      }\n    }\n\n    require(vaultCdr() > cdrBefore, \"cdr is not higher after unfold, what went wrong?\");\n  }\n\n  function _emergencyUnfold(uint _minMaiReceivedPerToken) internal {\n    targetCdr = type(uint).max;\n    uint debt = vaultDebt();\n    require(debt > 0, \"vault has no debt\");\n\n    // borrow 20% of total debt for emergency unfold\n    // TODO: this will fail if we are WAY below the minimum CDR, but I'm not sure when that\n    // would ever happen...\n    uint amountMaiToBorrow = debt / 5;\n\n    bool maiIsToken0 = IUniswapV2Pair(maiPairAddress).token0() == maiAddress;\n\n    bytes memory data = abi.encode(\n      maiIsToken0,\n      _minMaiReceivedPerToken\n    );\n\n    IUniswapV2Pair(maiPairAddress).swap(\n      maiIsToken0 ? amountMaiToBorrow : 0,\n      maiIsToken0 ? 0 : amountMaiToBorrow,\n      address(this),\n      data\n    );\n  }\n\n  function _setTargetCdr(uint _targetCdr) internal {\n    require(_targetCdr > _vaultMinimumCdr(), \"targetCdr too low\");\n    targetCdr = _targetCdr;\n  }\n\n  function _depositCollateral(uint _amount) internal {\n    require(_amount > 0, \"must deposit more than 0 tokens\");\n    require(_amount <= tokenBalance(), \"not enough collateral to deposit\");\n    QiDaoVault(vaultAddress).depositCollateral(vaultId, _amount);\n  }\n\n  function _withdrawCollateral(uint _amount) internal {\n    QiDaoVault(vaultAddress).withdrawCollateral(vaultId, _amount);\n  }\n\n  function _repayAvailableMaiDebt() internal {\n    uint amt = _maiBalance();\n    uint debt = vaultDebt();\n\n    if (amt > debt) {\n      amt = debt;\n    }\n\n    if (amt > 0) {\n      QiDaoVault(vaultAddress).payBackToken(vaultId, amt);\n    }\n  }\n\n  function _getRebalanceType() view internal returns (RebalanceType rt) {\n    require(vaultCollateral() > 0, \"vault has no collateral\");\n    uint cdr = vaultCdr();\n\n    if (cdr < _vaultMinimumCdr()) {\n      rt = RebalanceType.EMERGENCY_UNFOLD;\n    } else if (cdr > targetCdr + foldTriggerDeviation) {\n      rt = RebalanceType.FOLD;\n    } else if (cdr < targetCdr) {\n      rt = RebalanceType.UNFOLD;\n    }\n  }\n\n  function _collateralPrice() view internal returns (uint) {\n    return QiDaoVault(vaultAddress).getEthPriceSource();\n  }\n\n  /// @return approximate USD value of the vault collateral, expressed with 1e18 decimals of precision\n  function _vaultCollateralValue() view internal returns (uint) {\n    return vaultCollateral() * _collateralPrice() / PRICE_PRECISION;\n  }\n\n  /// @return Minimum CDR for this vault, expressed with CDR_PRECISION decimals of precision\n  function _vaultMinimumCdr() view internal returns (uint) {\n    return QiDaoVault(vaultAddress)._minimumCollateralPercentage() * CDR_PRECISION / 1e2;\n  }\n\n  function _maiBalance() view internal returns (uint) {\n    return IERC20(maiAddress).balanceOf(address(this));\n  }\n\n  /// @return Maximium amount of collateral that can be withdrawn from the vault without\n  /// going below the vault's minimum CDR. (Used for unfolding.)\n  function _maxWithdrawableCollateral() view internal returns (uint) {\n    uint minCollateralBalance = _vaultMinimumCdr() * vaultDebt() * CDR_PRECISION / _collateralPrice();\n    uint actualCollateralBalance = vaultCollateral();\n    return actualCollateralBalance - minCollateralBalance - 1;\n  }\n\n  function _availableBorrowsByTargetCdr() view internal returns (uint) {\n    uint maxTotalBorrowsInCollateral = _vaultCollateralValue() * CDR_PRECISION / targetCdr;\n    return maxTotalBorrowsInCollateral - vaultDebt();\n  }\n\n  // ERC20 stuff\n\n  function _mint(address _account, uint _amount) internal virtual {\n    require(_account != address(0), \"ERC20: mint to the zero address\");\n    totalSupply += _amount;\n    balances[_account] += _amount;\n    emit Transfer(address(0), _account, _amount);\n  }\n\n  function _burn(address _account, uint _amount) internal virtual {\n    require(_account != address(0), \"ERC20: burn from the zero address\");\n\n    uint256 accountBalance = balances[_account];\n    require(accountBalance >= _amount, \"ERC20: burn _amount exceeds balance\");\n    unchecked {\n      balances[_account] = accountBalance - _amount;\n    }\n    totalSupply -= _amount;\n\n    emit Transfer(_account, address(0), _amount);\n  }\n\n  // allow receiving NFT xfer\n  function onERC721Received(address, address, uint256, bytes calldata) pure external returns (bytes4) {\n    return QiDaoFolder.onERC721Received.selector;\n  }\n\n  // Overrides\n  function _approveSwaps() internal virtual;\n  function _swapMaiForToken(uint _amountMai, uint _minAmountTokenReceived) internal virtual;\n  function _swapTokenForMai(uint _amountToken, uint _minAmountMaiReceived) internal virtual;\n\n  function additionalFeeBps() pure internal virtual returns (uint) {\n    return 0;\n  }\n}\n"
    },
    "src/interfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IYVault {\n  function withdraw(uint shares) external;\n  function deposit(uint amount) external;\n}\n\ninterface IAPool {\n  function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\n  function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 _min_amount, bool _use_underlying) external;\n  function add_liquidity(uint256[3] memory _amounts, uint256 _min_mint_amount, bool _use_underlying) external;\n}\n\ninterface IVGHST {\n  function enter(uint256 _amount) external;\n  function leave(uint256 _share) external;\n}\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n  function name() external pure returns (string memory);\n  function symbol() external pure returns (string memory);\n  function decimals() external pure returns (uint8);\n  function totalSupply() external view returns (uint);\n  function balanceOf(address owner) external view returns (uint);\n  function allowance(address owner, address spender) external view returns (uint);\n  function approve(address spender, uint value) external returns (bool);\n  function transfer(address to, uint value) external returns (bool);\n  function transferFrom(address from, address to, uint value) external returns (bool);\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n  function nonces(address owner) external view returns (uint);\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n  event Mint(address indexed sender, uint amount0, uint amount1);\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n  event Swap(\n      address indexed sender,\n      uint amount0In,\n      uint amount1In,\n      uint amount0Out,\n      uint amount1Out,\n      address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\n  function factory() external view returns (address);\n  function token0() external view returns (address);\n  function token1() external view returns (address);\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n  function price0CumulativeLast() external view returns (uint);\n  function price1CumulativeLast() external view returns (uint);\n  function kLast() external view returns (uint);\n  function mint(address to) external returns (uint liquidity);\n  function burn(address to) external returns (uint amount0, uint amount1);\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n  function skim(address to) external;\n  function sync() external;\n}\n\ninterface QiDaoVault {\n  function _minimumCollateralPercentage() external view returns (uint256);\n\n  function approve(address to, uint256 tokenId) external;\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function baseURI() external view returns (string memory);\n\n  function borrowToken(uint256 vaultID, uint256 amount) external;\n\n  function burn(uint256 amountToken) external;\n\n  function changeEthPriceSource(address ethPriceSourceAddress) external;\n\n  function checkCollateralPercentage(uint256 vaultID)\n      external\n      view\n      returns (uint256);\n\n  function checkCost(uint256 vaultID) external view returns (uint256);\n\n  function checkExtract(uint256 vaultID) external view returns (uint256);\n\n  function checkLiquidation(uint256 vaultID) external view returns (bool);\n\n  function closingFee() external view returns (uint256);\n\n  function collateral() external view returns (address);\n\n  function createVault() external returns (uint256);\n\n  function debtRatio() external view returns (uint256);\n\n  function depositCollateral(uint256 vaultID, uint256 amount) external;\n\n  function destroyVault(uint256 vaultID) external;\n\n  function ethPriceSource() external view returns (address);\n\n  function exists(uint256 vaultID) external view returns (bool);\n\n  function gainRatio() external view returns (uint256);\n\n  function getApproved(uint256 tokenId) external view returns (address);\n\n  function getClosingFee() external view returns (uint256);\n\n  function getDebtCeiling() external view returns (uint256);\n\n  function getEthPriceSource() external view returns (uint256);\n\n  function getPaid() external;\n\n  function getTokenPriceSource() external view returns (uint256);\n\n  function isApprovedForAll(address owner, address operator)\n      external\n      view\n      returns (bool);\n\n  function isOwner() external view returns (bool);\n\n  function liquidateVault(uint256 vaultID) external;\n\n  function mai() external view returns (address);\n\n  function maticDebt(address) external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function owner() external view returns (address);\n\n  function ownerOf(uint256 tokenId) external view returns (address);\n\n  function payBackToken(uint256 vaultID, uint256 amount) external;\n\n  function priceSourceDecimals() external view returns (uint256);\n\n  function renounceOwnership() external;\n\n  function safeTransferFrom(\n      address from,\n      address to,\n      uint256 tokenId\n  ) external;\n\n  function safeTransferFrom(\n      address from,\n      address to,\n      uint256 tokenId,\n      bytes memory _data\n  ) external;\n\n  function setApprovalForAll(address to, bool approved) external;\n\n  function setDebtRatio(uint256 _debtRatio) external;\n\n  function setGainRatio(uint256 _gainRatio) external;\n\n  function setMinCollateralRatio(uint256 minimumCollateralPercentage)\n      external;\n\n  function setStabilityPool(address _pool) external;\n\n  function setTokenURI(string memory _uri) external;\n\n  function setTreasury(uint256 _treasury) external;\n\n  function stabilityPool() external view returns (address);\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  function tokenByIndex(uint256 index) external view returns (uint256);\n\n  function tokenOfOwnerByIndex(address owner, uint256 index)\n      external\n      view\n      returns (uint256);\n\n  function tokenPeg() external view returns (uint256);\n\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n\n  function totalBorrowed() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function transferFrom(\n      address from,\n      address to,\n      uint256 tokenId\n  ) external;\n\n  function transferOwnership(address newOwner) external;\n\n  function treasury() external view returns (uint256);\n\n  function uri() external view returns (string memory);\n\n  function vaultCollateral(uint256) external view returns (uint256);\n\n  function vaultCount() external view returns (uint256);\n\n  function vaultDebt(uint256) external view returns (uint256);\n\n  function withdrawCollateral(uint256 vaultID, uint256 amount) external;\n}\n"
    },
    "lib/openzeppelin-contracts.git/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "lib/openzeppelin-contracts.git/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n"
    },
    "lib/openzeppelin-contracts.git/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts.git/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts.git/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts.git/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "lib/openzeppelin-contracts.git/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts.git/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts.git/=lib/openzeppelin-contracts.git/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts.git/contracts/",
      "src/=src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london"
  }
}}