{{
  "language": "Solidity",
  "sources": {
    "contracts/Positions/PositionMastercopy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// Internal references\nimport \"./Position.sol\";\n\ncontract PositionMastercopy is Position {\n    constructor() {\n        // Freeze mastercopy on deployment so it can never be initialized with real arguments\n        initialized = true;\n    }\n}\n"
    },
    "contracts/Positions/Position.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// Inheritance\nimport \"@openzeppelin/contracts-4.4.1/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IPosition.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts-4.4.1/utils/math/SafeMath.sol\";\n\n// Internal references\nimport \"./PositionalMarket.sol\";\n\ncontract Position is IERC20, IPosition {\n    using SafeMath for uint;\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    PositionalMarket public market;\n\n    mapping(address => uint) public override balanceOf;\n    uint public override totalSupply;\n\n    // The argument order is allowance[owner][spender]\n    mapping(address => mapping(address => uint)) private allowances;\n\n    // Enforce a 1 cent minimum amount\n    uint internal constant _MINIMUM_AMOUNT = 1e16;\n\n    address public thalesAMM;\n\n    bool public initialized = false;\n\n    function initialize(\n        string calldata _name,\n        string calldata _symbol,\n        address _thalesAMM\n    ) external {\n        require(!initialized, \"Positional Market already initialized\");\n        initialized = true;\n        name = _name;\n        symbol = _symbol;\n        market = PositionalMarket(msg.sender);\n        thalesAMM = _thalesAMM;\n    }\n\n    /// @notice allowance inherited IERC20 function\n    /// @param owner address of the owner\n    /// @param spender address of the spender\n    /// @return uint256 number of tokens\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        if (spender == thalesAMM) {\n            return type(uint256).max;\n        } else {\n            return allowances[owner][spender];\n        }\n    }\n\n    /// @notice mint function mints Position token\n    /// @param minter address of the minter\n    /// @param amount value to mint token for\n    function mint(address minter, uint amount) external onlyMarket {\n        _requireMinimumAmount(amount);\n        totalSupply = totalSupply.add(amount);\n        balanceOf[minter] = balanceOf[minter].add(amount); // Increment rather than assigning since a transfer may have occurred.\n\n        emit Transfer(address(0), minter, amount);\n        emit Issued(minter, amount);\n    }\n\n    /// @notice exercise function exercises Position token\n    /// @dev This must only be invoked after maturity.\n    /// @param claimant address of the claiming address\n    function exercise(address claimant) external onlyMarket {\n        uint balance = balanceOf[claimant];\n\n        if (balance == 0) {\n            return;\n        }\n\n        balanceOf[claimant] = 0;\n        totalSupply = totalSupply.sub(balance);\n\n        emit Transfer(claimant, address(0), balance);\n        emit Burned(claimant, balance);\n    }\n\n    /// @notice exerciseWithAmount function exercises Position token\n    /// @dev This must only be invoked after maturity.\n    /// @param claimant address of the claiming address\n    /// @param amount amount of tokens for exercising\n    function exerciseWithAmount(address claimant, uint amount) external onlyMarket {\n        require(amount > 0, \"Can not exercise zero amount!\");\n\n        require(balanceOf[claimant] >= amount, \"Balance must be greather or equal amount that is burned\");\n\n        balanceOf[claimant] = balanceOf[claimant] - amount;\n        totalSupply = totalSupply.sub(amount);\n\n        emit Transfer(claimant, address(0), amount);\n        emit Burned(claimant, amount);\n    }\n\n    /// @notice expire function is used for Position selfdestruct\n    /// @dev This must only be invoked after the exercise window is complete.\n    /// Any options which have not been exercised will linger.\n    /// @param beneficiary address of the Position token\n    function expire(address payable beneficiary) external onlyMarket {\n        selfdestruct(beneficiary);\n    }\n\n    /// @notice transfer is ERC20 function for transfer tokens\n    /// @param _to address of the receiver\n    /// @param _value value to be transferred\n    /// @return success\n    function transfer(address _to, uint _value) external override returns (bool success) {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    /// @notice transferFrom is ERC20 function for transfer tokens\n    /// @param _from address of the sender\n    /// @param _to address of the receiver\n    /// @param _value value to be transferred\n    /// @return success\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _value\n    ) external override returns (bool success) {\n        if (msg.sender != thalesAMM) {\n            uint fromAllowance = allowances[_from][msg.sender];\n            require(_value <= fromAllowance, \"Insufficient allowance\");\n            allowances[_from][msg.sender] = fromAllowance.sub(_value);\n        }\n        return _transfer(_from, _to, _value);\n    }\n\n    /// @notice approve is ERC20 function for token approval\n    /// @param _spender address of the spender\n    /// @param _value value to be approved\n    /// @return success\n    function approve(address _spender, uint _value) external override returns (bool success) {\n        require(_spender != address(0));\n        allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /// @notice getBalanceOf ERC20 function gets token balance of an account\n    /// @param account address of the account\n    /// @return uint\n    function getBalanceOf(address account) external view override returns (uint) {\n        return balanceOf[account];\n    }\n\n    /// @notice getTotalSupply ERC20 function gets token total supply\n    /// @return uint\n    function getTotalSupply() external view override returns (uint) {\n        return totalSupply;\n    }\n\n    /// @notice transfer is internal function for transfer tokens\n    /// @param _from address of the sender\n    /// @param _to address of the receiver\n    /// @param _value value to be transferred\n    /// @return success\n    function _transfer(\n        address _from,\n        address _to,\n        uint _value\n    ) internal returns (bool success) {\n        market.requireUnpaused();\n        require(_to != address(0) && _to != address(this), \"Invalid address\");\n\n        uint fromBalance = balanceOf[_from];\n        require(_value <= fromBalance, \"Insufficient balance\");\n\n        balanceOf[_from] = fromBalance.sub(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /// @notice _requireMinimumAmount checks that amount is greater than minimum amount\n    /// @param amount value to be checked\n    /// @return uint amount\n    function _requireMinimumAmount(uint amount) internal pure returns (uint) {\n        require(amount >= _MINIMUM_AMOUNT || amount == 0, \"Balance < $0.01\");\n        return amount;\n    }\n\n    modifier onlyMarket() {\n        require(msg.sender == address(market), \"Only market allowed\");\n        _;\n    }\n\n    event Issued(address indexed account, uint value);\n    event Burned(address indexed account, uint value);\n}\n"
    },
    "@openzeppelin/contracts-4.4.1/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\nimport \"./IPositionalMarket.sol\";\n\ninterface IPosition {\n    /* ========== VIEWS / VARIABLES ========== */\n\n    function getBalanceOf(address account) external view returns (uint);\n\n    function getTotalSupply() external view returns (uint);\n}\n"
    },
    "@openzeppelin/contracts-4.4.1/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/Positions/PositionalMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// Inheritance\nimport \"../OwnedWithInit.sol\";\nimport \"../interfaces/IPositionalMarket.sol\";\nimport \"../interfaces/IOracleInstance.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts-4.4.1/utils/math/SafeMath.sol\";\n\n// Internal references\nimport \"./PositionalMarketManager.sol\";\nimport \"./Position.sol\";\nimport \"@openzeppelin/contracts-4.4.1/token/ERC20/IERC20.sol\";\n\ncontract PositionalMarket is OwnedWithInit, IPositionalMarket {\n    /* ========== LIBRARIES ========== */\n\n    using SafeMath for uint;\n\n    /* ========== TYPES ========== */\n\n    struct Options {\n        Position up;\n        Position down;\n    }\n\n    struct Times {\n        uint maturity;\n        uint expiry;\n    }\n\n    struct OracleDetails {\n        bytes32 key;\n        uint strikePrice;\n        uint finalPrice;\n        bool customMarket;\n        address iOracleInstanceAddress;\n    }\n\n    struct PositionalMarketParameters {\n        address owner;\n        IERC20 sUSD;\n        IPriceFeed priceFeed;\n        address creator;\n        bytes32 oracleKey;\n        uint strikePrice;\n        uint[2] times; // [maturity, expiry]\n        uint deposit; // sUSD deposit\n        address up;\n        address down;\n        address thalesAMM;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    Options public options;\n    Times public override times;\n    OracleDetails public oracleDetails;\n    PositionalMarketManager.Fees public override fees;\n    IPriceFeed public priceFeed;\n    IERC20 public sUSD;\n\n    // `deposited` tracks the sum of all deposits.\n    // This must explicitly be kept, in case tokens are transferred to the contract directly.\n    uint public override deposited;\n    uint public initialMint;\n    address public override creator;\n    bool public override resolved;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    bool public initialized = false;\n\n    function initialize(PositionalMarketParameters calldata _parameters) external {\n        require(!initialized, \"Positional Market already initialized\");\n        initialized = true;\n        initOwner(_parameters.owner);\n        sUSD = _parameters.sUSD;\n        priceFeed = _parameters.priceFeed;\n        creator = _parameters.creator;\n\n        oracleDetails = OracleDetails(_parameters.oracleKey, _parameters.strikePrice, 0, false, address(0));\n\n        times = Times(_parameters.times[0], _parameters.times[1]);\n\n        deposited = _parameters.deposit;\n        initialMint = _parameters.deposit;\n\n        // Instantiate the options themselves\n        options.up = Position(_parameters.up);\n        options.down = Position(_parameters.down);\n        // abi.encodePacked(\"sUP: \", _oracleKey)\n        // consider naming the option: sUpBTC>50@2021.12.31\n        options.up.initialize(\"Position Up\", \"UP\", _parameters.thalesAMM);\n        options.down.initialize(\"Position Down\", \"DOWN\", _parameters.thalesAMM);\n        _mint(creator, initialMint);\n\n        // Note: the ERC20 base contract does not have a constructor, so we do not have to worry\n        // about initializing its state separately\n    }\n\n    /// @notice phase returns market phase\n    /// @return Phase\n    function phase() external view override returns (Phase) {\n        if (!_matured()) {\n            return Phase.Trading;\n        }\n        if (!_expired()) {\n            return Phase.Maturity;\n        }\n        return Phase.Expiry;\n    }\n\n    /// @notice oraclePriceAndTimestamp returns oracle key price and last updated timestamp\n    /// @return price updatedAt\n    function oraclePriceAndTimestamp() external view override returns (uint price, uint updatedAt) {\n        return _oraclePriceAndTimestamp();\n    }\n\n    /// @notice oraclePrice returns oracle key price\n    /// @return price\n    function oraclePrice() external view override returns (uint price) {\n        return _oraclePrice();\n    }\n\n    /// @notice canResolve checks if market can be resolved\n    /// @return bool\n    function canResolve() public view override returns (bool) {\n        return !resolved && _matured();\n    }\n\n    /// @notice result calculates market result based on market strike price\n    /// @return Side\n    function result() external view override returns (Side) {\n        return _result();\n    }\n\n    /// @notice balancesOf returns balances of an account\n    /// @return up down\n    function balancesOf(address account) external view override returns (uint up, uint down) {\n        return _balancesOf(account);\n    }\n\n    /// @notice totalSupplies returns total supplies of op and down options\n    /// @return up down\n    function totalSupplies() external view override returns (uint up, uint down) {\n        return (options.up.totalSupply(), options.down.totalSupply());\n    }\n\n    /// @notice getMaximumBurnable returns maximum burnable amount of an account\n    /// @param account address of the account\n    /// @return amount\n    function getMaximumBurnable(address account) external view override returns (uint amount) {\n        return _getMaximumBurnable(account);\n    }\n\n    /// @notice getOptions returns up and down positions\n    /// @return up down\n    function getOptions() external view override returns (IPosition up, IPosition down) {\n        up = options.up;\n        down = options.down;\n    }\n\n    /// @notice getOracleDetails returns data from oracle source\n    /// @return key strikePrice finalPrice\n    function getOracleDetails()\n        external\n        view\n        override\n        returns (\n            bytes32 key,\n            uint strikePrice,\n            uint finalPrice\n        )\n    {\n        key = oracleDetails.key;\n        strikePrice = oracleDetails.strikePrice;\n        finalPrice = oracleDetails.finalPrice;\n    }\n\n    /// @notice requireUnpaused ensures that manager is not paused\n    function requireUnpaused() external view {\n        _requireManagerNotPaused();\n    }\n\n    /// @notice mint mints up and down tokens\n    /// @param value to mint options for\n    function mint(uint value) external override duringMinting {\n        if (value == 0) {\n            return;\n        }\n\n        _mint(msg.sender, value);\n\n        _incrementDeposited(value);\n        _manager().transferSusdTo(msg.sender, address(this), _manager().transformCollateral(value));\n    }\n\n    /// @notice burnOptionsMaximum burns option tokens based on maximum burnable account amount\n    function burnOptionsMaximum() external override {\n        _burnOptions(msg.sender, _getMaximumBurnable(msg.sender));\n    }\n\n    /// @notice burnOptions burns option tokens based on amount\n    function burnOptions(uint amount) external override {\n        _burnOptions(msg.sender, amount);\n    }\n\n    /// @notice resolve function for resolving market if possible\n    function resolve() external onlyOwner afterMaturity managerNotPaused {\n        require(canResolve(), \"Can not resolve market\");\n        uint price;\n        uint updatedAt;\n\n        (price, updatedAt) = _oraclePriceAndTimestamp();\n        oracleDetails.finalPrice = price;\n\n        resolved = true;\n\n        emit MarketResolved(_result(), price, updatedAt, deposited, 0, 0);\n    }\n\n    /// @notice exerciseOptions is used for exercising options from resolved market\n    function exerciseOptions() external override afterMaturity returns (uint) {\n        // The market must be resolved if it has not been.\n        if (!resolved) {\n            _manager().resolveMarket(address(this));\n        }\n\n        // If the account holds no options, revert.\n        (uint upBalance, uint downBalance) = _balancesOf(msg.sender);\n        require(upBalance != 0 || downBalance != 0, \"Nothing to exercise\");\n\n        // Each option only needs to be exercised if the account holds any of it.\n        if (upBalance != 0) {\n            options.up.exercise(msg.sender);\n        }\n        if (downBalance != 0) {\n            options.down.exercise(msg.sender);\n        }\n\n        // Only pay out the side that won.\n        uint payout = (_result() == Side.Up) ? upBalance : downBalance;\n        emit OptionsExercised(msg.sender, payout);\n        if (payout != 0) {\n            _decrementDeposited(payout);\n            sUSD.transfer(msg.sender, _manager().transformCollateral(payout));\n        }\n        return payout;\n    }\n\n    /// @notice expire is used for exercising options from resolved market\n    function expire(address payable beneficiary) external onlyOwner {\n        require(_expired(), \"Unexpired options remaining\");\n        emit Expired(beneficiary);\n        _selfDestruct(beneficiary);\n    }\n\n    /// @notice _priceFeed internal function returns PriceFeed contract address\n    /// @return IPriceFeed\n    function _priceFeed() internal view returns (IPriceFeed) {\n        return priceFeed;\n    }\n\n    /// @notice _manager internal function returns PositionalMarketManager contract address\n    /// @return PositionalMarketManager\n    function _manager() internal view returns (PositionalMarketManager) {\n        return PositionalMarketManager(owner);\n    }\n\n    /// @notice _matured internal function checks if market is matured\n    /// @return bool\n    function _matured() internal view returns (bool) {\n        return times.maturity < block.timestamp;\n    }\n\n    /// @notice _expired internal function checks if market is expired\n    /// @return bool\n    function _expired() internal view returns (bool) {\n        return resolved && (times.expiry < block.timestamp || deposited == 0);\n    }\n\n    /// @notice _oraclePrice internal function returns oracle key price from source\n    /// @return price\n    function _oraclePrice() internal view returns (uint price) {\n        return _priceFeed().rateForCurrency(oracleDetails.key);\n    }\n\n    /// @notice _oraclePriceAndTimestamp internal function returns oracle key price and last updated timestamp from source\n    /// @return price updatedAt\n    function _oraclePriceAndTimestamp() internal view returns (uint price, uint updatedAt) {\n        return _priceFeed().rateAndUpdatedTime(oracleDetails.key);\n    }\n\n    /// @notice _result internal function calculates market result based on market strike price\n    /// @return Side\n    function _result() internal view returns (Side) {\n        uint price;\n        if (resolved) {\n            price = oracleDetails.finalPrice;\n        } else {\n            price = _oraclePrice();\n        }\n\n        return oracleDetails.strikePrice <= price ? Side.Up : Side.Down;\n    }\n\n    /// @notice _balancesOf internal function gets account balances of up and down tokens\n    /// @param account address of an account\n    /// @return up down\n    function _balancesOf(address account) internal view returns (uint up, uint down) {\n        return (options.up.getBalanceOf(account), options.down.getBalanceOf(account));\n    }\n\n    /// @notice _getMaximumBurnable internal function gets account maximum burnable amount\n    /// @param account address of an account\n    /// @return amount\n    function _getMaximumBurnable(address account) internal view returns (uint amount) {\n        (uint upBalance, uint downBalance) = _balancesOf(account);\n        return (upBalance > downBalance) ? downBalance : upBalance;\n    }\n\n    /// @notice _incrementDeposited internal function increments deposited value\n    /// @param value increment value\n    /// @return _deposited\n    function _incrementDeposited(uint value) internal returns (uint _deposited) {\n        _deposited = deposited.add(value);\n        deposited = _deposited;\n        _manager().incrementTotalDeposited(value);\n    }\n\n    /// @notice _decrementDeposited internal function decrements deposited value\n    /// @param value decrement value\n    /// @return _deposited\n    function _decrementDeposited(uint value) internal returns (uint _deposited) {\n        _deposited = deposited.sub(value);\n        deposited = _deposited;\n        _manager().decrementTotalDeposited(value);\n    }\n\n    /// @notice _requireManagerNotPaused internal function ensures that manager is not paused\n    function _requireManagerNotPaused() internal view {\n        require(!_manager().paused(), \"This action cannot be performed while the contract is paused\");\n    }\n\n    /// @notice _mint internal function mints up and down tokens\n    /// @param amount value to mint options for\n    function _mint(address minter, uint amount) internal {\n        options.up.mint(minter, amount);\n        options.down.mint(minter, amount);\n\n        emit Mint(Side.Up, minter, amount);\n        emit Mint(Side.Down, minter, amount);\n    }\n\n    /// @notice _burnOptions internal function for burning up and down tokens\n    /// @param account address of an account\n    /// @param amount burning amount\n    function _burnOptions(address account, uint amount) internal {\n        require(amount > 0, \"Can not burn zero amount!\");\n        require(_getMaximumBurnable(account) >= amount, \"There is not enough options!\");\n\n        // decrease deposit\n        _decrementDeposited(amount);\n\n        // decrease up and down options\n        options.up.exerciseWithAmount(account, amount);\n        options.down.exerciseWithAmount(account, amount);\n\n        // transfer balance\n        sUSD.transfer(account, _manager().transformCollateral(amount));\n\n        // emit events\n        emit OptionsBurned(account, amount);\n    }\n\n    /// @notice _selfDestruct internal function for market self desctruct\n    /// @param beneficiary address of a market\n    function _selfDestruct(address payable beneficiary) internal {\n        uint _deposited = deposited;\n        if (_deposited != 0) {\n            _decrementDeposited(_deposited);\n        }\n\n        // Transfer the balance rather than the deposit value in case there are any synths left over\n        // from direct transfers.\n        uint balance = sUSD.balanceOf(address(this));\n        if (balance != 0) {\n            sUSD.transfer(beneficiary, balance);\n        }\n\n        // Destroy the option tokens before destroying the market itself.\n        options.up.expire(beneficiary);\n        options.down.expire(beneficiary);\n        selfdestruct(beneficiary);\n    }\n\n    modifier duringMinting() {\n        require(!_matured(), \"Minting inactive\");\n        _;\n    }\n\n    modifier afterMaturity() {\n        require(_matured(), \"Not yet mature\");\n        _;\n    }\n\n    modifier managerNotPaused() {\n        _requireManagerNotPaused();\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event Mint(Side side, address indexed account, uint value);\n    event MarketResolved(\n        Side result,\n        uint oraclePrice,\n        uint oracleTimestamp,\n        uint deposited,\n        uint poolFees,\n        uint creatorFees\n    );\n\n    event OptionsExercised(address indexed account, uint value);\n    event OptionsBurned(address indexed account, uint value);\n    event Expired(address beneficiary);\n}\n"
    },
    "contracts/interfaces/IPositionalMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\nimport \"../interfaces/IPositionalMarketManager.sol\";\nimport \"../interfaces/IPosition.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\n\ninterface IPositionalMarket {\n    /* ========== TYPES ========== */\n\n    enum Phase {Trading, Maturity, Expiry}\n    enum Side {Up, Down}\n\n    /* ========== VIEWS / VARIABLES ========== */\n\n    function getOptions() external view returns (IPosition up, IPosition down);\n\n    function times() external view returns (uint maturity, uint destructino);\n\n    function getOracleDetails()\n        external\n        view\n        returns (\n            bytes32 key,\n            uint strikePrice,\n            uint finalPrice\n        );\n\n    function fees() external view returns (uint poolFee, uint creatorFee);\n\n    function deposited() external view returns (uint);\n\n    function creator() external view returns (address);\n\n    function resolved() external view returns (bool);\n\n    function phase() external view returns (Phase);\n\n    function oraclePrice() external view returns (uint);\n\n    function oraclePriceAndTimestamp() external view returns (uint price, uint updatedAt);\n\n    function canResolve() external view returns (bool);\n\n    function result() external view returns (Side);\n\n    function balancesOf(address account) external view returns (uint up, uint down);\n\n    function totalSupplies() external view returns (uint up, uint down);\n\n    function getMaximumBurnable(address account) external view returns (uint amount);\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function mint(uint value) external;\n\n    function exerciseOptions() external returns (uint);\n\n    function burnOptions(uint amount) external;\n\n    function burnOptionsMaximum() external;\n}\n"
    },
    "contracts/interfaces/IPositionalMarketManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\nimport \"../interfaces/IPositionalMarket.sol\";\n\ninterface IPositionalMarketManager {\n    /* ========== VIEWS / VARIABLES ========== */\n\n    function durations() external view returns (uint expiryDuration, uint maxTimeToMaturity);\n\n    function capitalRequirement() external view returns (uint);\n\n    function marketCreationEnabled() external view returns (bool);\n\n    function transformCollateral(uint value) external view returns (uint);\n\n    function reverseTransformCollateral(uint value) external view returns (uint);\n\n    function totalDeposited() external view returns (uint);\n\n    function numActiveMarkets() external view returns (uint);\n\n    function activeMarkets(uint index, uint pageSize) external view returns (address[] memory);\n\n    function numMaturedMarkets() external view returns (uint);\n\n    function maturedMarkets(uint index, uint pageSize) external view returns (address[] memory);\n\n    function isActiveMarket(address candidate) external view returns (bool);\n\n    function isKnownMarket(address candidate) external view returns (bool);\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function createMarket(\n        bytes32 oracleKey,\n        uint strikePrice,\n        uint maturity,\n        uint initialMint // initial sUSD to mint options for,\n    ) external returns (IPositionalMarket);\n\n    function resolveMarket(address market) external;\n\n    function expireMarkets(address[] calldata market) external;\n\n    function transferSusdTo(\n        address sender,\n        address receiver,\n        uint amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.16;\n\ninterface IPriceFeed {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    // Mutative functions\n    function addAggregator(bytes32 currencyKey, address aggregatorAddress) external;\n\n    function removeAggregator(bytes32 currencyKey) external;\n\n    // Views\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function getRates() external view returns (uint[] memory);\n\n    function getCurrencies() external view returns (bytes32[] memory);\n}\n"
    },
    "contracts/OwnedWithInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract OwnedWithInit {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor() {}\n\n    function initOwner(address _owner) internal {\n        require(owner == address(0), \"Init can only be called when owner is 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n"
    },
    "contracts/interfaces/IOracleInstance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IPositionalMarket.sol\";\n\ninterface IOracleInstance {\n    /* ========== VIEWS / VARIABLES ========== */\n\n    function getOutcome() external view returns (bool);\n\n    function resolvable() external view returns (bool);\n}\n"
    },
    "contracts/Positions/PositionalMarketManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// Inheritance\nimport \"../interfaces/IPositionalMarketManager.sol\";\nimport \"../utils/proxy/solidity-0.8.0/ProxyOwned.sol\";\nimport \"../utils/proxy/solidity-0.8.0/ProxyPausable.sol\";\n\n// Libraries\nimport \"../utils/libraries/AddressSetLib.sol\";\nimport \"../utils/libraries/DateTime.sol\";\nimport \"@openzeppelin/contracts-4.4.1/utils/math/SafeMath.sol\";\n\n// Internal references\nimport \"./PositionalMarketFactory.sol\";\nimport \"./PositionalMarket.sol\";\nimport \"./Position.sol\";\nimport \"../interfaces/IPositionalMarket.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/IThalesAMM.sol\";\nimport \"@openzeppelin/contracts-4.4.1/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract PositionalMarketManager is Initializable, ProxyOwned, ProxyPausable, IPositionalMarketManager {\n    /* ========== LIBRARIES ========== */\n\n    using SafeMath for uint;\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    /* ========== TYPES ========== */\n\n    struct Fees {\n        uint poolFee;\n        uint creatorFee;\n    }\n\n    struct Durations {\n        uint expiryDuration;\n        uint maxTimeToMaturity;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    Durations public override durations;\n    uint public override capitalRequirement;\n\n    bool public override marketCreationEnabled;\n    bool public customMarketCreationEnabled;\n\n    bool public onlyWhitelistedAddressesCanCreateMarkets;\n    mapping(address => bool) public whitelistedAddresses;\n\n    uint public override totalDeposited;\n\n    AddressSetLib.AddressSet internal _activeMarkets;\n    AddressSetLib.AddressSet internal _maturedMarkets;\n\n    PositionalMarketManager internal _migratingManager;\n\n    IPriceFeed public priceFeed;\n    IERC20 public sUSD;\n\n    address public positionalMarketFactory;\n\n    bool public needsTransformingCollateral;\n\n    uint public timeframeBuffer;\n    uint256 public priceBuffer;\n\n    mapping(bytes32 => mapping(uint => address[])) public marketsPerOracleKey;\n    mapping(address => uint) public marketsStrikePrice;\n\n    function initialize(\n        address _owner,\n        IERC20 _sUSD,\n        IPriceFeed _priceFeed,\n        uint _expiryDuration,\n        uint _maxTimeToMaturity\n    ) external initializer {\n        setOwner(_owner);\n        priceFeed = _priceFeed;\n        sUSD = _sUSD;\n\n        // Temporarily change the owner so that the setters don't revert.\n        owner = msg.sender;\n\n        marketCreationEnabled = true;\n        customMarketCreationEnabled = false;\n        onlyWhitelistedAddressesCanCreateMarkets = false;\n\n        setExpiryDuration(_expiryDuration);\n        setMaxTimeToMaturity(_maxTimeToMaturity);\n    }\n\n    /// @notice isKnownMarket checks if market is among matured or active markets\n    /// @param candidate Address of the market.\n    /// @return bool\n    function isKnownMarket(address candidate) public view override returns (bool) {\n        return _activeMarkets.contains(candidate) || _maturedMarkets.contains(candidate);\n    }\n\n    /// @notice isActiveMarket checks if market is active market\n    /// @param candidate Address of the market.\n    /// @return bool\n    function isActiveMarket(address candidate) public view override returns (bool) {\n        return _activeMarkets.contains(candidate);\n    }\n\n    /// @notice numActiveMarkets returns number of active markets\n    /// @return uint\n    function numActiveMarkets() external view override returns (uint) {\n        return _activeMarkets.elements.length;\n    }\n\n    /// @notice activeMarkets returns list of active markets\n    /// @param index index of the page\n    /// @param pageSize number of addresses per page\n    /// @return address[] active market list\n    function activeMarkets(uint index, uint pageSize) external view override returns (address[] memory) {\n        return _activeMarkets.getPage(index, pageSize);\n    }\n\n    /// @notice numMaturedMarkets returns number of mature markets\n    /// @return uint\n    function numMaturedMarkets() external view override returns (uint) {\n        return _maturedMarkets.elements.length;\n    }\n\n    /// @notice maturedMarkets returns list of matured markets\n    /// @param index index of the page\n    /// @param pageSize number of addresses per page\n    /// @return address[] matured market list\n    function maturedMarkets(uint index, uint pageSize) external view override returns (address[] memory) {\n        return _maturedMarkets.getPage(index, pageSize);\n    }\n\n    /// @notice incrementTotalDeposited increments totalDeposited value\n    /// @param delta increment amount\n    function incrementTotalDeposited(uint delta) external onlyActiveMarkets notPaused {\n        totalDeposited = totalDeposited.add(delta);\n    }\n\n    /// @notice decrementTotalDeposited decrements totalDeposited value\n    /// @dev As individual market debt is not tracked here, the underlying markets\n    /// need to be careful never to subtract more debt than they added.\n    /// This can't be enforced without additional state/communication overhead.\n    /// @param delta decrement amount\n    function decrementTotalDeposited(uint delta) external onlyKnownMarkets notPaused {\n        totalDeposited = totalDeposited.sub(delta);\n    }\n\n    /// @notice createMarket create market function\n    /// @param oracleKey market oracle key\n    /// @param strikePrice market strike price\n    /// @param maturity  market maturity date\n    /// @param initialMint initial sUSD to mint options for\n    /// @return IPositionalMarket created market\n    function createMarket(\n        bytes32 oracleKey,\n        uint strikePrice,\n        uint maturity,\n        uint initialMint\n    )\n        external\n        override\n        notPaused\n        returns (\n            IPositionalMarket // no support for returning PositionalMarket polymorphically given the interface\n        )\n    {\n\n        if (onlyWhitelistedAddressesCanCreateMarkets) {\n            require(whitelistedAddresses[msg.sender], \"Only whitelisted addresses can create markets\");\n        }\n\n        (bool canCreate, string memory message) = canCreateMarket(oracleKey, maturity, strikePrice);\n        require(canCreate, message);\n\n        uint expiry = maturity.add(durations.expiryDuration);\n\n        PositionalMarket market = PositionalMarketFactory(positionalMarketFactory).createMarket(\n            PositionalMarketFactory.PositionCreationMarketParameters(\n                msg.sender,\n                sUSD,\n                priceFeed,\n                oracleKey,\n                strikePrice,\n                [maturity, expiry],\n                initialMint\n            )\n        );\n\n        _activeMarkets.add(address(market));\n\n        // The debt can't be incremented in the new market's constructor because until construction is complete,\n        // the manager doesn't know its address in order to grant it permission.\n        totalDeposited = totalDeposited.add(initialMint);\n        sUSD.transferFrom(msg.sender, address(market), _transformCollateral(initialMint));\n\n        (IPosition up, IPosition down) = market.getOptions();\n\n        marketsStrikePrice[address(market)] = strikePrice;\n        marketsPerOracleKey[oracleKey][_getDateFromTimestamp(maturity)].push(address(market));\n\n        emit MarketCreated(\n            address(market),\n            msg.sender,\n            oracleKey,\n            strikePrice,\n            maturity,\n            expiry,\n            address(up),\n            address(down),\n            false,\n            address(0)\n        );\n        return market;\n    }\n\n    /// @notice transferSusdTo transfers sUSD from market to receiver\n    /// @dev Only to be called by markets themselves\n    /// @param sender address of sender\n    /// @param receiver address of receiver\n    /// @param amount amount to be transferred\n    function transferSusdTo(\n        address sender,\n        address receiver,\n        uint amount\n    ) external override {\n        //only to be called by markets themselves\n        require(isKnownMarket(address(msg.sender)), \"Market unknown.\");\n        bool success = sUSD.transferFrom(sender, receiver, amount);\n        if (!success) {\n            revert(\"TransferFrom function failed\");\n        }\n    }\n\n    /// @notice resolveMarket resolves an active market\n    /// @param market address of the market\n    function resolveMarket(address market) external override {\n        require(_activeMarkets.contains(market), \"Not an active market\");\n        PositionalMarket(market).resolve();\n        _activeMarkets.remove(market);\n        _maturedMarkets.add(market);\n    }\n\n    /// @notice expireMarkets removes expired markets from matured markets\n    /// @param markets array of market addresses\n    function expireMarkets(address[] calldata markets) external override notPaused onlyOwner {\n        for (uint i = 0; i < markets.length; i++) {\n            address market = markets[i];\n\n            require(isKnownMarket(address(market)), \"Market unknown.\");\n\n            // The market itself handles decrementing the total deposits.\n            PositionalMarket(market).expire(payable(msg.sender));\n\n            // Note that we required that the market is known, which guarantees\n            // its index is defined and that the list of markets is not empty.\n            _maturedMarkets.remove(market);\n\n            emit MarketExpired(market);\n        }\n    }\n\n    /// @notice transformCollateral transforms collateral\n    /// @param value value to be transformed\n    /// @return uint\n    function transformCollateral(uint value) external view override returns (uint) {\n        return _transformCollateral(value);\n    }\n\n    /// @notice reverseTransformCollateral reverse collateral if needed\n    /// @param value value to be reversed\n    /// @return uint\n    function reverseTransformCollateral(uint value) external view override returns (uint) {\n        if (needsTransformingCollateral) {\n            return value * 1e12;\n        } else {\n            return value;\n        }\n    }\n\n    /// @notice canCreateMarket checks if market can be created\n    /// @param oracleKey market oracle key\n    /// @param maturity market maturity timestamp\n    /// @param strikePrice market strike price\n    /// @return bool\n    function canCreateMarket(\n        bytes32 oracleKey,\n        uint maturity,\n        uint strikePrice\n    ) public view returns (bool, string memory) {\n        if (!marketCreationEnabled) {\n            return (false, \"Market creation is disabled\");\n        }\n\n        if (!_isValidKey(oracleKey)) {\n            return (false, \"Invalid key\");\n        }\n\n        if (maturity > block.timestamp + durations.maxTimeToMaturity) {\n            return (false, \"Maturity too far in the future\");\n        }\n\n        if (block.timestamp >= maturity) {\n            return (false, \"Maturity too far in the future\");\n        }\n\n        if (!_checkMarkets(oracleKey, strikePrice, maturity)) {\n            return (false, \"A market already exists within that timeframe and price buffer\");\n        }\n\n        return (true, \"\");\n    }\n\n    /// @notice enableWhitelistedAddresses enables option that only whitelisted addresses\n    /// can create markets\n    function enableWhitelistedAddresses() external onlyOwner {\n        onlyWhitelistedAddressesCanCreateMarkets = true;\n    }\n\n    /// @notice disableWhitelistedAddresses disables option that only whitelisted addresses\n    /// can create markets\n    function disableWhitelistedAddresses() external onlyOwner {\n        onlyWhitelistedAddressesCanCreateMarkets = false;\n    }\n\n    /// @notice addWhitelistedAddress adds given address to whitelisted addresses list\n    /// @param _address address to be added to the list\n    function addWhitelistedAddress(address _address) external onlyOwner {\n        whitelistedAddresses[_address] = true;\n    }\n\n    /// @notice removeWhitelistedAddress removes given address from whitelisted addresses list\n    /// @param _address address to be removed from the list\n    function removeWhitelistedAddress(address _address) external onlyOwner {\n        delete whitelistedAddresses[_address];\n    }\n\n    /// @notice setWhitelistedAddresses enables whitelist addresses option and creates list\n    /// @param _whitelistedAddresses array of whitelisted addresses\n    function setWhitelistedAddresses(address[] calldata _whitelistedAddresses) external onlyOwner {\n        require(_whitelistedAddresses.length > 0, \"Whitelisted addresses cannot be empty\");\n        onlyWhitelistedAddressesCanCreateMarkets = true;\n        for (uint256 index = 0; index < _whitelistedAddresses.length; index++) {\n            whitelistedAddresses[_whitelistedAddresses[index]] = true;\n        }\n    }\n\n    /// @notice setPositionalMarketFactory sets PositionalMarketFactory address\n    /// @param _positionalMarketFactory address of PositionalMarketFactory\n    function setPositionalMarketFactory(address _positionalMarketFactory) external onlyOwner {\n        positionalMarketFactory = _positionalMarketFactory;\n        emit SetPositionalMarketFactory(_positionalMarketFactory);\n    }\n\n    /// @notice setNeedsTransformingCollateral sets needsTransformingCollateral value\n    /// @param _needsTransformingCollateral boolen value to be set\n    function setNeedsTransformingCollateral(bool _needsTransformingCollateral) external onlyOwner {\n        needsTransformingCollateral = _needsTransformingCollateral;\n    }\n\n    /// @notice setExpiryDuration sets expiryDuration value\n    /// @param _expiryDuration value in seconds needed for market expiry check\n    function setExpiryDuration(uint _expiryDuration) public onlyOwner {\n        durations.expiryDuration = _expiryDuration;\n        emit ExpiryDurationUpdated(_expiryDuration);\n    }\n\n    /// @notice setMaxTimeToMaturity sets maxTimeToMaturity value\n    /// @param _maxTimeToMaturity value in seconds for market max time to maturity check\n    function setMaxTimeToMaturity(uint _maxTimeToMaturity) public onlyOwner {\n        durations.maxTimeToMaturity = _maxTimeToMaturity;\n        emit MaxTimeToMaturityUpdated(_maxTimeToMaturity);\n    }\n\n    /// @notice setPriceFeed sets address of PriceFeed contract\n    /// @param _address PriceFeed address\n    function setPriceFeed(address _address) external onlyOwner {\n        priceFeed = IPriceFeed(_address);\n        emit SetPriceFeed(_address);\n    }\n\n    /// @notice setsUSD sets address of sUSD contract\n    /// @param _address sUSD address\n    function setsUSD(address _address) external onlyOwner {\n        sUSD = IERC20(_address);\n        emit SetsUSD(_address);\n    }\n\n    /// @notice setPriceBuffer sets priceBuffer value\n    /// @param _priceBuffer value in percents needed for market creaton check\n    function setPriceBuffer(uint _priceBuffer) external onlyOwner {\n        priceBuffer = _priceBuffer;\n        emit PriceBufferChanged(_priceBuffer);\n    }\n\n    /// @notice setTimeframeBuffer sets timeframeBuffer value\n    /// @param _timeframeBuffer value in days needed for market creaton check\n    function setTimeframeBuffer(uint _timeframeBuffer) external onlyOwner {\n        timeframeBuffer = _timeframeBuffer;\n        emit TimeframeBufferChanged(_timeframeBuffer);\n    }\n\n    /// @notice setMarketCreationEnabled sets marketCreationEnabled value\n    /// @param enabled boolean value to enable/disable market creation\n    function setMarketCreationEnabled(bool enabled) external onlyOwner {\n        if (enabled != marketCreationEnabled) {\n            marketCreationEnabled = enabled;\n            emit MarketCreationEnabledUpdated(enabled);\n        }\n    }\n\n    /// @notice _isValidKey checks if oracle key is supported by PriceFeed contract\n    /// @param oracleKey oracle key\n    /// @return bool\n    function _isValidKey(bytes32 oracleKey) internal view returns (bool) {\n        // If it has a rate, then it's possibly a valid key\n        if (priceFeed.rateForCurrency(oracleKey) != 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// @notice _checkStrikePrice checks if markets strike prices are between given price values\n    /// @param markets list of markets to be checked\n    /// @param strikePrice market strike price\n    /// @param oracleKey market oracle key\n    /// @return bool - true if there are no markets between given price values, otherwise false\n    function _checkStrikePrice(\n        address[] memory markets,\n        uint strikePrice,\n        bytes32 oracleKey\n    ) internal view returns (bool) {\n         uint buffer = (priceBuffer * _getImpliedVolatility(oracleKey)) / 1e18;\n        for (uint i = 0; i < markets.length; i++) {\n            uint upperPriceLimit = marketsStrikePrice[markets[i]] + (marketsStrikePrice[markets[i]] * buffer) / 1e20;\n            uint lowerPriceLimit = marketsStrikePrice[markets[i]] - (marketsStrikePrice[markets[i]] * buffer) / 1e20;\n            if (strikePrice <= upperPriceLimit && strikePrice >= lowerPriceLimit) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice _checkMarkets checks if there exists similar market with same oracleKey\n    /// @dev price limits are calculated from given strike price using priceBuffer percentage and\n    /// we're checking lists of markets using timeframeBuffer\n    /// @param oracleKey oracle key of the market to be created\n    /// @param strikePrice strike price\n    /// @param maturity market date maturity\n    /// @return bool\n    function _checkMarkets(\n        bytes32 oracleKey,\n        uint strikePrice,\n        uint maturity\n    ) internal view returns (bool) {\n        uint date = _getDateFromTimestamp(maturity);\n\n        for (uint day = 1; day <= timeframeBuffer; day++) {\n            uint upperDateLimit = DateTime.addDays(date, day);\n            uint lowerDateLimit = DateTime.subDays(date, day);\n\n            address[] memory marketsDateAfter = _getMarketsPerOracleKey(oracleKey, upperDateLimit);\n            address[] memory marketsDateBefore = _getMarketsPerOracleKey(oracleKey, lowerDateLimit);\n\n            if (\n                !(_checkStrikePrice(marketsDateAfter, strikePrice, oracleKey) &&\n                    _checkStrikePrice(marketsDateBefore, strikePrice, oracleKey))\n            ) {\n                return false;\n            }\n        }\n\n        address[] memory marketsOnDate = _getMarketsPerOracleKey(oracleKey, date);\n\n        return _checkStrikePrice(marketsOnDate, strikePrice, oracleKey);\n    }\n\n    /// @notice _getMarketsPerOracleKey returns list of markets with same oracle key and maturity date\n    /// @param oracleKey oracle key\n    /// @param date maturity date\n    /// @return address[] list of markets\n    function _getMarketsPerOracleKey(bytes32 oracleKey, uint date) internal view returns (address[] memory) {\n        return marketsPerOracleKey[oracleKey][date];\n    }\n\n    /// @notice _getDateFromTimestamp calculates midnight timestamp\n    /// @param timestamp timestamp to strip seconds, minutes and hours\n    /// @return date midnigth timestamp\n    function _getDateFromTimestamp(uint timestamp) internal pure returns (uint date) {\n        uint second = DateTime.getSecond(timestamp);\n        uint minute = DateTime.getMinute(timestamp);\n        uint hour = DateTime.getHour(timestamp);\n\n        date = DateTime.subHours(timestamp, hour);\n        date = DateTime.subMinutes(date, minute);\n        date = DateTime.subSeconds(date, second);\n    }\n\n    /// @notice _getImpliedVolatility gets implied volatility per asset from ThalesAMM contract\n    /// @param oracleKey asset to fetch value for\n    /// @return impliedVolatility\n    function _getImpliedVolatility(bytes32 oracleKey) internal view returns (uint impliedVolatility) {\n        address thalesAMM = PositionalMarketFactory(positionalMarketFactory).thalesAMM();\n        impliedVolatility = IThalesAMM(thalesAMM).impliedVolatilityPerAsset(oracleKey);\n    }\n\n    /// @notice _transformCollateral transforms collateral if needed\n    /// @param value value to be transformed\n    /// @return uint\n    function _transformCollateral(uint value) internal view returns (uint) {\n        if (needsTransformingCollateral) {\n            return value / 1e12;\n        } else {\n            return value;\n        }\n    }\n\n    modifier onlyActiveMarkets() {\n        require(_activeMarkets.contains(msg.sender), \"Permitted only for active markets.\");\n        _;\n    }\n\n    modifier onlyKnownMarkets() {\n        require(isKnownMarket(msg.sender), \"Permitted only for known markets.\");\n        _;\n    }\n\n    event MarketCreated(\n        address market,\n        address indexed creator,\n        bytes32 indexed oracleKey,\n        uint strikePrice,\n        uint maturityDate,\n        uint expiryDate,\n        address up,\n        address down,\n        bool customMarket,\n        address customOracle\n    );\n    event MarketExpired(address market);\n    event MarketsMigrated(PositionalMarketManager receivingManager, PositionalMarket[] markets);\n    event MarketsReceived(PositionalMarketManager migratingManager, PositionalMarket[] markets);\n    event MarketCreationEnabledUpdated(bool enabled);\n    event ExpiryDurationUpdated(uint duration);\n    event MaxTimeToMaturityUpdated(uint duration);\n    event SetPositionalMarketFactory(address _positionalMarketFactory);\n    event SetZeroExAddress(address _zeroExAddress);\n    event SetPriceFeed(address _address);\n    event SetsUSD(address _address);\n    event SetMigratingManager(address manager);\n    event PriceBufferChanged(uint priceBuffer);\n    event TimeframeBufferChanged(uint timeframeBuffer);\n}\n"
    },
    "contracts/utils/proxy/solidity-0.8.0/ProxyOwned.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// Clone of syntetix contract without constructor\ncontract ProxyOwned {\n    address public owner;\n    address public nominatedOwner;\n    bool private _initialized;\n    bool private _transferredAtInit;\n\n    function setOwner(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        require(!_initialized, \"Already initialized, use nominateNewOwner\");\n        _initialized = true;\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    function transferOwnershipAtInit(address proxyAddress) external onlyOwner {\n        require(proxyAddress != address(0), \"Invalid address\");\n        require(!_transferredAtInit, \"Already transferred\");\n        owner = proxyAddress;\n        _transferredAtInit = true;\n        emit OwnerChanged(owner, proxyAddress);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n"
    },
    "contracts/utils/proxy/solidity-0.8.0/ProxyPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// Inheritance\nimport \"./ProxyOwned.sol\";\n\n// Clone of syntetix contract without constructor\n\ncontract ProxyPausable is ProxyOwned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    \n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = block.timestamp;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n"
    },
    "contracts/utils/libraries/AddressSetLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary AddressSetLib {\n    struct AddressSet {\n        address[] elements;\n        mapping(address => uint) indices;\n    }\n\n    function contains(AddressSet storage set, address candidate) internal view returns (bool) {\n        if (set.elements.length == 0) {\n            return false;\n        }\n        uint index = set.indices[candidate];\n        return index != 0 || set.elements[0] == candidate;\n    }\n\n    function getPage(\n        AddressSet storage set,\n        uint index,\n        uint pageSize\n    ) internal view returns (address[] memory) {\n        // NOTE: This implementation should be converted to slice operators if the compiler is updated to v0.6.0+\n        uint endIndex = index + pageSize; // The check below that endIndex <= index handles overflow.\n\n        // If the page extends past the end of the list, truncate it.\n        if (endIndex > set.elements.length) {\n            endIndex = set.elements.length;\n        }\n        if (endIndex <= index) {\n            return new address[](0);\n        }\n\n        uint n = endIndex - index; // We already checked for negative overflow.\n        address[] memory page = new address[](n);\n        for (uint i; i < n; i++) {\n            page[i] = set.elements[i + index];\n        }\n        return page;\n    }\n\n    function add(AddressSet storage set, address element) internal {\n        // Adding to a set is an idempotent operation.\n        if (!contains(set, element)) {\n            set.indices[element] = set.elements.length;\n            set.elements.push(element);\n        }\n    }\n\n    function remove(AddressSet storage set, address element) internal {\n        require(contains(set, element), \"Element not in set.\");\n        // Replace the removed element with the last element of the list.\n        uint index = set.indices[element];\n        uint lastIndex = set.elements.length - 1; // We required that element is in the list, so it is not empty.\n        if (index != lastIndex) {\n            // No need to shift the last element if it is the one we want to delete.\n            address shiftedElement = set.elements[lastIndex];\n            set.elements[index] = shiftedElement;\n            set.indices[shiftedElement] = index;\n        }\n        set.elements.pop();\n        delete set.indices[element];\n    }\n}"
    },
    "contracts/utils/libraries/DateTime.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// ----------------------------------------------------------------------------\n// DateTime Library v2.0\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary DateTime {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    uint256 constant DOW_MON = 1;\n    uint256 constant DOW_TUE = 2;\n    uint256 constant DOW_WED = 3;\n    uint256 constant DOW_THU = 4;\n    uint256 constant DOW_FRI = 5;\n    uint256 constant DOW_SAT = 6;\n    uint256 constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days =\n            _day -\n                32075 +\n                (1461 * (_year + 4800 + (_month - 14) / 12)) /\n                4 +\n                (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n                12 -\n                (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n                4 -\n                OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function timestampFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n\n    function timestampFromDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 timestamp) {\n        timestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            hour *\n            SECONDS_PER_HOUR +\n            minute *\n            SECONDS_PER_MINUTE +\n            second;\n    }\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint256 daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n\n    function isValidDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n\n    function isLeapYear(uint256 timestamp)\n        internal\n        pure\n        returns (bool leapYear)\n    {\n        (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n\n    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n\n    function getDaysInMonth(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 daysInMonth)\n    {\n        (uint256 year, uint256 month, ) =\n            _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n\n    function _getDaysInMonth(uint256 year, uint256 month)\n        internal\n        pure\n        returns (uint256 daysInMonth)\n    {\n        if (\n            month == 1 ||\n            month == 3 ||\n            month == 5 ||\n            month == 7 ||\n            month == 8 ||\n            month == 10 ||\n            month == 12\n        ) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 dayOfWeek)\n    {\n        uint256 _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = ((_days + 3) % 7) + 1;\n    }\n\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n\n    function getMinute(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 minute)\n    {\n        uint256 secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n\n    function getSecond(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 second)\n    {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint256 timestamp, uint256 _years)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) =\n            _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMonths(uint256 timestamp, uint256 _months)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) =\n            _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = ((month - 1) % 12) + 1;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addDays(uint256 timestamp, uint256 _days)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addHours(uint256 timestamp, uint256 _hours)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMinutes(uint256 timestamp, uint256 _minutes)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addSeconds(uint256 timestamp, uint256 _seconds)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint256 timestamp, uint256 _years)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) =\n            _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp <= timestamp);\n    }\n\n    function subMonths(uint256 timestamp, uint256 _months)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) =\n            _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = (yearMonth % 12) + 1;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp <= timestamp);\n    }\n\n    function subDays(uint256 timestamp, uint256 _days)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subHours(uint256 timestamp, uint256 _hours)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subMinutes(uint256 timestamp, uint256 _minutes)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subSeconds(uint256 timestamp, uint256 _seconds)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _years)\n    {\n        require(fromTimestamp <= toTimestamp);\n        (uint256 fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint256 toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _months)\n    {\n        require(fromTimestamp <= toTimestamp);\n        (uint256 fromYear, uint256 fromMonth, ) =\n            _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint256 toYear, uint256 toMonth, ) =\n            _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _days)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _hours)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _minutes)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _seconds)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}"
    },
    "contracts/Positions/PositionalMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// Inheritance\nimport \"../utils/proxy/solidity-0.8.0/ProxyOwned.sol\";\n\n// Internal references\nimport \"./Position.sol\";\nimport \"./PositionalMarket.sol\";\nimport \"./PositionalMarketFactory.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/IPositionalMarket.sol\";\nimport \"@openzeppelin/contracts-4.4.1/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-4.4.1/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract PositionalMarketFactory is Initializable, ProxyOwned {\n    /* ========== STATE VARIABLES ========== */\n    address public positionalMarketManager;\n\n    address public positionalMarketMastercopy;\n    address public positionMastercopy;\n\n    address public limitOrderProvider;\n    address public thalesAMM;\n\n    struct PositionCreationMarketParameters {\n        address creator;\n        IERC20 _sUSD;\n        IPriceFeed _priceFeed;\n        bytes32 oracleKey;\n        uint strikePrice;\n        uint[2] times; // [maturity, expiry]\n        uint initialMint;\n    }\n\n    function initialize(address _owner) external initializer {\n        setOwner(_owner);\n    }\n\n    /// @notice createMarket create market function\n    /// @param _parameters PositionCreationMarketParameters needed for market creation\n    /// @return PositionalMarket created market\n    function createMarket(PositionCreationMarketParameters calldata _parameters) external returns (PositionalMarket) {\n        require(positionalMarketManager == msg.sender, \"Only permitted by the manager.\");\n\n        PositionalMarket pom = PositionalMarket(Clones.clone(positionalMarketMastercopy));\n        Position up = Position(Clones.clone(positionMastercopy));\n        Position down = Position(Clones.clone(positionMastercopy));\n        pom.initialize(\n            PositionalMarket.PositionalMarketParameters(\n                positionalMarketManager,\n                _parameters._sUSD,\n                _parameters._priceFeed,\n                _parameters.creator,\n                _parameters.oracleKey,\n                _parameters.strikePrice,\n                _parameters.times,\n                _parameters.initialMint,\n                address(up),\n                address(down),\n                thalesAMM\n            )\n        );\n        emit MarketCreated(\n            address(pom),\n            _parameters.oracleKey,\n            _parameters.strikePrice,\n            _parameters.times[0],\n            _parameters.times[1],\n            _parameters.initialMint\n        );\n        return pom;\n    }\n\n    /// @notice setPositionalMarketManager sets positionalMarketManager value\n    /// @param _positionalMarketManager address of the PositionalMarketManager contract\n    function setPositionalMarketManager(address _positionalMarketManager) external onlyOwner {\n        positionalMarketManager = _positionalMarketManager;\n        emit PositionalMarketManagerChanged(_positionalMarketManager);\n    }\n\n    /// @notice setPositionalMarketMastercopy sets positionalMarketMastercopy value\n    /// @param _positionalMarketMastercopy address of the PositionalMarketMastercopy contract\n    function setPositionalMarketMastercopy(address _positionalMarketMastercopy) external onlyOwner {\n        positionalMarketMastercopy = _positionalMarketMastercopy;\n        emit PositionalMarketMastercopyChanged(_positionalMarketMastercopy);\n    }\n\n    /// @notice setPositionMastercopy sets positionMastercopy value\n    /// @param _positionMastercopy address of the PositionMastercopy contract\n    function setPositionMastercopy(address _positionMastercopy) external onlyOwner {\n        positionMastercopy = _positionMastercopy;\n        emit PositionMastercopyChanged(_positionMastercopy);\n    }\n\n    /// @notice setThalesAMM sets thalesAMM value\n    /// @param _thalesAMM address of ThalesAMM contract\n    function setThalesAMM(address _thalesAMM) external onlyOwner {\n        thalesAMM = _thalesAMM;\n        emit SetThalesAMM(_thalesAMM);\n    }\n\n    event PositionalMarketManagerChanged(address _positionalMarketManager);\n    event PositionalMarketMastercopyChanged(address _positionalMarketMastercopy);\n    event PositionMastercopyChanged(address _positionMastercopy);\n    event SetThalesAMM(address _thalesAMM);\n    event MarketCreated(\n        address market,\n        bytes32 indexed oracleKey,\n        uint strikePrice,\n        uint maturityDate,\n        uint expiryDate,\n        uint initialMint\n    );\n}\n"
    },
    "contracts/interfaces/IThalesAMM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\n\ninterface IThalesAMM {\n    enum Position {Up, Down}\n\n    function manager() external view returns (address);\n\n    function availableToBuyFromAMM(address market, Position position) external view returns (uint);\n\n    function impliedVolatilityPerAsset(bytes32 oracleKey) external view returns(uint);\n\n    function buyFromAmmQuote(\n        address market,\n        Position position,\n        uint amount\n    ) external view returns (uint);\n\n    function buyFromAMM(\n        address market,\n        Position position,\n        uint amount,\n        uint expectedPayout,\n        uint additionalSlippage\n    ) external;\n\n    function availableToSellToAMM(address market, Position position) external view returns (uint);\n\n    function sellToAmmQuote(\n        address market,\n        Position position,\n        uint amount\n    ) external view returns (uint);\n\n    function sellToAMM(\n        address market,\n        Position position,\n        uint amount,\n        uint expectedPayout,\n        uint additionalSlippage\n    ) external;\n\n    function isMarketInAMMTrading(address market) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.4.1/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}