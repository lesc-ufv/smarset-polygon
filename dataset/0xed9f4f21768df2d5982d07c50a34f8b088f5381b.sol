{{
  "language": "Solidity",
  "sources": {
    "contracts/bridges/Kyber/KyberSwapBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.6;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IERC20.sol\";\nimport \"../interfaces/IUniswapV2Swap.sol\";\nimport \"./interfaces/IKyberDMM.sol\";\nimport \"../interfaces/IKyberSwap.sol\";\n\n/**\n * @title KyberSwapBridge\n * @author DeFi Basket\n *\n * @notice Swaps using the KyberSwap contract in Polygon.\n *\n * @dev This contract swaps ERC20 tokens to ERC20 tokens. Please notice that there are no payable functions.\n *\n */\n\ncontract KyberSwapBridge is IKyberSwap {\n    IKyberDMM constant router = IKyberDMM(0x546C79662E028B661dFB4767664d0273184E4dD1);\n\n    /**\n      * @notice Swaps from ERC20 token to ERC20 token.\n      *\n      * @dev Wraps the swap and generate the necessary events to communicate with DeFi Basket's UI and back-end.\n      *\n      * @param amountInPercentage Percentage of the balance of the input ERC20 token that will be swapped\n      * @param amountOutMin Minimum amount of the output token required to execute swap\n      * @param poolsPath the Kyber pools to be used\n      * @param path The swap route determined by the path. The first element of path is the input token, the last is\n      * the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example,\n      * a direct pair does not exist)\n      */\n    function swapTokenToToken(\n        uint256 amountInPercentage,\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        address[] calldata path\n    ) external override {\n        uint256 amountIn = IERC20(path[0]).balanceOf(address(this)) * amountInPercentage / 100000;\n\n        // Approve 0 first as a few ERC20 tokens are requiring this pattern.\n        IERC20(path[0]).approve(address(router), 0);\n        IERC20(path[0]).approve(address(router), amountIn);\n\n        uint[] memory amounts = router.swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            poolsPath,\n            path,\n            address(this),\n            block.timestamp + 100000\n        );\n\n        emit DEFIBASKET_KYBER_SWAP(amounts);\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/bridges/interfaces/IUniswapV2Swap.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.6;\n\ninterface IUniswapV2Swap {\n    event DEFIBASKET_UNISWAPV2_SWAP(\n        uint256[] amounts\n    );\n\n    function swapTokenToToken(\n        uint256 amountInPercentage,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) external;\n}\n"
    },
    "contracts/bridges/Kyber/interfaces/IKyberDMM.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.6;\n\ninterface IKyberDMM {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        address pool,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256[2] calldata vReserveRatioBounds,\n        address to,\n        uint256 deadline\n    ) external\n    returns (\n        uint256 amountA,\n        uint256 amountB,\n        uint256 liquidity\n    );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        address pool,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external\n    returns (\n        uint256 amountA,\n        uint256 amountB\n    );\n}\n"
    },
    "contracts/bridges/interfaces/IKyberSwap.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.6;\n\ninterface IKyberSwap {\n    event DEFIBASKET_KYBER_SWAP(\n        uint256[] amounts\n    );\n\n    function swapTokenToToken(\n        uint256 amountInPercentage,\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        address[] calldata path\n    ) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}