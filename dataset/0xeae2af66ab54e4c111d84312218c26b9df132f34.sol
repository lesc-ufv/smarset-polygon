{"ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ncontract ERC20 {\n  uint public totalSupply;\n  mapping(address =\u003e uint) public balanceOf;\n  mapping(address =\u003e mapping(address =\u003e uint)) public allowance;\n\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n\n  function transfer(address recipient, uint amount) external returns (bool) {\n    balanceOf[msg.sender] -= amount;\n    balanceOf[recipient] += amount;\n    emit Transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function approve(address spender, uint amount) external returns (bool) {\n    allowance[msg.sender][spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(address sender, address recipient, uint amount) external returns (bool) {\n    allowance[sender][msg.sender] -= amount;\n    balanceOf[sender] -= amount;\n    balanceOf[recipient] += amount;\n    emit Transfer(sender, recipient, amount);\n    return true;\n  }\n\n  function _mint(address account, uint amount) internal {\n    balanceOf[account] += amount;\n    totalSupply += amount;\n    emit Transfer(address(0), account, amount);\n  }\n\n  function _burn(address account, uint amount) internal {\n    balanceOf[account] -= amount;\n    totalSupply -= amount;\n    emit Transfer(account, address(0), amount);\n  }\n}\n\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IERC20 {\n  function name() external view returns (string memory);\n  function symbol() external view returns (string memory);\n  function decimals() external view returns (uint8);\n  function totalSupply() external view returns (uint);\n  function balanceOf(address account) external view returns (uint);\n  function allowance(address owner, address spender) external view returns (uint);\n  function transfer(address recipient, uint amount) external returns (bool);\n  function approve(address spender, uint amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n}\n"},"IPool.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IPool {\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  modifier onlyOwner() {\n    require(owner == msg.sender, \"Caller is not owner\");\n    _;\n  }\n\n  function _transferOwnership(address newOwner) internal {\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n}\n"},"safeTransfer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nlibrary safeTransfer {\n  bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\u0027transferFrom(address,address,uint256)\u0027)));\n  bytes4 private constant SELECTOR_TRANSFER = bytes4(keccak256(bytes(\u0027transfer(address,uint256)\u0027)));\n\n  function invoke(address token, address to, uint value) internal {\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR_TRANSFER, to, value));\n    require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TRANSFER_FAILED\u0027);\n  }\n  function invokeFrom(address token, address from, address to, uint value) internal {\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, from, to, value));\n    require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TRANSFER_FROM_FAILED\u0027);\n  }\n}\n"},"StickyAavePool.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./ERC20.sol\";\nimport \"./IERC20.sol\";\nimport \"./IPool.sol\";\nimport \"./safeTransfer.sol\";\nimport \"./Ownable.sol\";\n\ncontract StickyAavePool is ERC20, Ownable {\n  IPool public aavePool;\n  address public aToken;\n  address public baseToken;\n  address public factory;\n\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n\n  event FactoryChanged(address indexed oldFactory, address indexed newFactory);\n\n  constructor(\n    IPool _aavePool,\n    address _aToken,\n    address _baseToken,\n    address _factory,\n    string memory _name,\n    string memory _symbol\n  ) {\n    aavePool = _aavePool;\n    aToken = _aToken;\n    baseToken = _baseToken;\n    factory = _factory;\n    name = _name;\n    symbol = _symbol;\n    decimals = IERC20(baseToken).decimals();\n    _transferOwnership(msg.sender);\n  }\n\n  function mint(uint amountIn) external {\n    _mint(msg.sender, amountIn);\n    safeTransfer.invokeFrom(baseToken, msg.sender, address(this), amountIn);\n    ERC20(baseToken).approve(address(aavePool), amountIn);\n    aavePool.supply(baseToken, amountIn, address(this), 0);\n  }\n\n  function burn(uint amountOut) external {\n    _burn(msg.sender, amountOut);\n    aavePool.withdraw(baseToken, amountOut, msg.sender);\n  }\n\n  function interestToken() public view returns(address) {\n    return baseToken;\n  }\n\n  function interestAvailable() public view returns(uint) {\n    return ERC20(aToken).balanceOf(address(this)) - totalSupply;\n  }\n\n  function setFactory(address newFactory) external onlyOwner {\n    emit FactoryChanged(factory, newFactory);\n    factory = newFactory;\n  }\n\n  function transferOwnership(address newOwner) external onlyOwner {\n    _transferOwnership(newOwner);\n  }\n\n  function collectInterest() external {\n    require(msg.sender == factory);\n    aavePool.withdraw(baseToken, interestAvailable(), factory);\n  }\n}\n"}}