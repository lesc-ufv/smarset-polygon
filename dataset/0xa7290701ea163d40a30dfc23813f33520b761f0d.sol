{{
  "language": "Solidity",
  "sources": {
    "contracts/QiPowah.sol": {
      "content": "pragma solidity 0.5.16;\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ninterface IStakingRewards {\n    function balanceOf(address account) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n\ninterface IPair {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112,\n            uint112,\n            uint32\n        );\n}\n\ninterface IVault {\n    function balance() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n\ninterface IJar {\n    function balanceOf(address _user) external view returns (uint256);\n\n    function getRatio() external view returns (uint256);\n}\n\ninterface IPickleFarm {\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n    }\n\n    function userInfo(uint256 index, address user)\n        external\n        view\n        returns (UserInfo memory);\n}\n\ninterface IMasterChef {\n    function userInfo(uint256 nr, address who)\n        external\n        view\n        returns (uint256, uint256);\n\n    function pending(uint256 nr, address who) external view returns (uint256);\n}\n\ninterface BalancerVault {\n    function getPoolTokenInfo(bytes32, address)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address\n        );\n\n    function getPool(bytes32) external view returns (address, uint8);\n}\n\ncontract QIPOWAH {\n    using SafeMath for uint256;\n\n    IERC20 qi = IERC20(0x580A84C73811E1839F75d86d75d88cCa0c241fF4);\n\n    function name() public pure returns (string memory) {\n        return \"QIPOWAH\";\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \"QIPOWAH\";\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        //    IPair pair = IPair(0x7AfcF11F3e2f01e71B7Cc6b8B5e707E42e6Ea397);\n        // no xQi yet IBar bar = IBar(0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272);\n        //    (uint256 lp_totalQi, , ) = pair.getReserves();\n        uint256 qi_totalQi = qi.totalSupply().mul(4); /// x 4 because boost in eQi\n\n        return qi_totalQi; //lp_totalQi.add(qi_totalQi);\n    }\n    \n\n    function calculateBalanceInPair(\n        address pair_addr,\n        IERC20 token,\n        address user\n    ) public view returns (uint256) {\n        IPair pair = IPair(pair_addr);\n\n        uint256 lp_totalQi = token.balanceOf(address(pair));\n        uint256 lp_balance = pair.balanceOf(user);\n\n        if (lp_balance > 0) {\n            return lp_totalQi.mul(lp_balance).div(pair.totalSupply());\n        } else {\n            return 0;\n        }\n    }\n\n    function calculateBalanceInQuickSwapStakingPool(\n      address pool_addr,\n      address pair_addr,\n      IERC20 token,\n      address user\n    ) public view returns (uint256) {\n      IPair pair = IPair(pair_addr);\n      IStakingRewards stakingRewards = IStakingRewards(pool_addr);\n\n      return stakingRewards\n        .balanceOf(user) \n        .mul(token.balanceOf(pair_addr)) \n        .mul(pair.balanceOf(pool_addr)) \n        .div(stakingRewards.totalSupply()) \n        .div(pair.totalSupply()); \n    }\n\n    function lpToQi(address pair_addr, uint256 lpTokens)\n        public\n        view\n        returns (uint256)\n    {\n        IPair pool = IPair(pair_addr);\n\n        uint256 lp_totalQi = qi.balanceOf(address(pool));\n        return lp_totalQi.mul(lpTokens).div(pool.totalSupply());\n    }\n\n    function calculateAddyPower(\n        address jar_addr,\n        address pair_addr,\n        address user\n    ) public view returns (uint256) {\n        IJar addyJar = IJar(jar_addr);\n        uint256 LPTokens = addyJar.balanceOf(user).mul(addyJar.getRatio()).div(\n            1e18\n        );\n        return lpToQi(pair_addr, LPTokens);\n    }\n\n    function calculateBeefyPower(\n        address vault_addr,\n        address pair_addr,\n        address user\n    ) public view returns (uint256) {\n        IVault beefyVault = IVault(vault_addr);\n        uint256 userBalance = beefyVault.balanceOf(user);\n        uint256 userLpTokens = (\n            userBalance.mul(beefyVault.balance()).div(beefyVault.totalSupply())\n        );\n        return lpToQi(pair_addr, userLpTokens);\n    }\n\n    function calculatePickleJarPower(\n        address jar_addr,\n        address pair_addr,\n        address user\n    ) public view returns (uint256) {\n        IJar pickleJar = IJar(jar_addr);\n        uint256 LPTokens = pickleJar\n            .balanceOf(user)\n            .mul(pickleJar.getRatio())\n            .div(1e18);\n        return lpToQi(pair_addr, LPTokens);\n    }\n\n    function calculatePickleFarmPower(\n        address farm_addr,\n        address jar_addr,\n        address pair_addr,\n        address user\n    ) public view returns (uint256) {\n        IJar pickleJar = IJar(jar_addr);\n        IPickleFarm pickleFarm = IPickleFarm(farm_addr);\n        IPickleFarm.UserInfo memory userInfo = pickleFarm.userInfo(10, user);\n        uint256 LPTokens = userInfo.amount.mul(pickleJar.getRatio()).div(1e18);\n        return lpToQi(pair_addr, LPTokens);\n    }\n\n    function calculateBalancerPoolBalance(\n        bytes32 poolId,\n        IERC20 token,\n        address user\n    ) public view returns (uint256) {\n        BalancerVault vault = BalancerVault(\n            0xBA12222222228d8Ba445958a75a0704d566BF2C8\n        );\n        (address pool_address, ) = vault.getPool(poolId);\n        (uint256 poolQiBalance, , , ) = vault.getPoolTokenInfo(\n            poolId,\n            address(token)\n        );\n        return\n            IERC20(pool_address).balanceOf(user).mul(poolQiBalance).div(\n                IERC20(pool_address).totalSupply()\n            );\n        /*     userShare = pool.balanceOf(userAddress) / pool.totalSupply()\n\nuserQiBalance = userShare * poolQiBalance */\n    }\n\n    function getAllFarms(uint256 qi_powah, address owner) public view returns (uint256) {\n\n        // qi-mimatic QS pair\n        qi_powah = qi_powah.add(\n            calculateBalanceInPair(\n                0x7AfcF11F3e2f01e71B7Cc6b8B5e707E42e6Ea397,\n                qi,\n                owner\n            )\n        );\n        // USDC-Qi pair\n        qi_powah = qi_powah.add(\n            calculateBalanceInPair(\n                0x1dBba57B3d9719c007900D21e8541e90bC6933EC,\n                qi,\n                owner\n            )\n        );\n        // QI - QUICK pair\n        qi_powah = qi_powah.add(\n            calculateBalanceInPair(\n                0x25d56E2416f20De1Efb1F18fd06dD12eFeC3D3D0,\n                qi,\n                owner\n            )\n        );\n\n        // QI - WETH\n        qi_powah = qi_powah.add(\n            calculateBalanceInPair(\n                0x8C1b40Ea78081B70F661C3286c74E71b4602C9C0,\n                qi,\n                owner\n            )\n        );\n\n        // QI - WMATIC\n        qi_powah = qi_powah.add(\n            calculateBalanceInPair(\n                0x9A8b2601760814019B7E6eE0052E25f1C623D1E6,\n                qi,\n                owner\n            )\n        );\n\n        // sushi pairs\n        // wmatic-qi\n        qi_powah = qi_powah.add(\n            calculateBalanceInPair(\n                0xCe00673a5a3023EBE47E3D46e4D59292e921dc7c,\n                qi,\n                owner\n            )\n        );\n        // mimatic-qi\n        qi_powah = qi_powah.add(\n            calculateBalanceInPair(\n                0x96f72333A043a623D6869954B6A50AB7Be883EbC,\n                qi,\n                owner\n            )\n        );\n\n        // Balancer LP\n        // WMATIC-USDC-QI-BAL-MIMATIC\n        qi_powah = qi_powah.add(\n            calculateBalancerPoolBalance(\n                0xf461f2240b66d55dcf9059e26c022160c06863bf000100000000000000000006,\n                qi,\n                owner\n            )\n        );\n\n        // SUSHI-WMATIC-USDC-QI-WETH-QUICK-BAL-ADDY\n        qi_powah = qi_powah.add(\n            calculateBalancerPoolBalance(\n                0x32fc95287b14eaef3afa92cccc48c285ee3a280a000100000000000000000005,\n                qi,\n                owner\n            )\n        );\n        // QI-MIMATIC\n        qi_powah = qi_powah.add(\n            calculateBalancerPoolBalance(\n                0x09804caea2400035b18e2173fdd10ec8b670ca0900020000000000000000000f,\n                qi,\n                owner\n            )\n        );\n\n        return qi_powah;\n    }\n\n    function getAllCompounders(uint256 qi_powah, address owner) public view returns(uint256){\n\n        // Adamant vaults\n        qi_powah = qi_powah.add(\n            calculateAddyPower(\n                0x80506dBe1FE9DAbbD3F4D92Fc1CBA4866131bF82,\n                0x7AfcF11F3e2f01e71B7Cc6b8B5e707E42e6Ea397,\n                owner\n            )\n        );\n\n        // Beefy\n        // QI-MAI\n        qi_powah = qi_powah.add(\n            calculateBeefyPower(\n                0xa2Dd60Fb8Bbf21e60E58AF97Cfc9dB9A34397848,\n                0x7AfcF11F3e2f01e71B7Cc6b8B5e707E42e6Ea397,\n                owner\n            )\n        );\n        // QI-QUICK\n        qi_powah = qi_powah.add(\n            calculateBeefyPower(\n                0x1d7A7182043F521ab57Fe07a8420Fee9843E365e,\n                0x25d56E2416f20De1Efb1F18fd06dD12eFeC3D3D0,\n                owner\n            )\n        );\n\n        // Pickle jars\n        // QI-MAI\n        qi_powah = qi_powah.add(\n            calculatePickleJarPower(\n                0xd06a56c864C80e4cC76A2eF778183104BF0c848d,\n                0x7AfcF11F3e2f01e71B7Cc6b8B5e707E42e6Ea397,\n                owner\n            )\n        );\n\n        // Pickle farms\n        // p QI-MAI\n        qi_powah = qi_powah.add(\n            calculatePickleFarmPower(\n                0x20B2a3fc7B13cA0cCf7AF81A68a14CB3116E8749,\n                0xd06a56c864C80e4cC76A2eF778183104BF0c848d,\n                0x7AfcF11F3e2f01e71B7Cc6b8B5e707E42e6Ea397,\n                owner\n            )\n        );\n\n        // QuickSwap staking pools\n        // QI-QUICK\n        qi_powah = qi_powah.add(\n          calculateBalanceInQuickSwapStakingPool(\n            0xad9E0d2FC293fD9a0f6c3C16c16A69d36B6D3b06,\n            0x25d56E2416f20De1Efb1F18fd06dD12eFeC3D3D0,\n            qi,\n            owner\n          )\n        );\n\n        // QI - WETH\n        qi_powah = qi_powah.add(\n            calculateBalanceInQuickSwapStakingPool(\n                0xb47f7120a57381c217e4d6F3a79F066bfAAe6C93,\n                0x8C1b40Ea78081B70F661C3286c74E71b4602C9C0,\n                qi,\n                owner\n            )\n        );\n        return qi_powah;\n    }\n\n    IERC20 qix = IERC20(0xe1cA10e6a10c0F72B74dF6b7339912BaBfB1f8B5); // qix erc20\n    IERC20 eqi = IERC20(0x880DeCADe22aD9c58A8A4202EF143c4F305100B3); // eqi erc20\n    IPair QSpair = IPair(0x7AfcF11F3e2f01e71B7Cc6b8B5e707E42e6Ea397); // Qi-miMatic QS pair\n    \n    function balanceOf(address owner) public view returns (uint256) {\n        IMasterChef chef = IMasterChef(\n            0x574Fe4E8120C4Da1741b5Fd45584de7A5b521F0F\n        ); // rewards contract\n\n        // no xQi yet  IBar bar = IBar(0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272);\n\n\n\n        uint256 qi_powah = qi.balanceOf(owner).add(qix.balanceOf(owner));\n\n        uint256 lp_totalQi = qi.balanceOf(address(QSpair));\n        uint256 lp_balance = QSpair.balanceOf(owner);\n\n        // Add staked balance\n        (uint256 lp_stakedBalance, ) = chef.userInfo(2, owner);\n        lp_balance = lp_balance.add(lp_stakedBalance);\n\n        uint256 lp_powah = 0;\n\n        if (lp_balance > 0) {\n            lp_powah = lp_totalQi.mul(lp_balance).div(QSpair.totalSupply());\n            // all Qi in lp * user_lp_balance / total_lp_balance\n        }\n\n        (uint256 lp_stakedBalance4, ) = chef.userInfo(4, owner);\n        \n        IPair QSpair4 = IPair(0x9A8b2601760814019B7E6eE0052E25f1C623D1E6); // Qi-WMATIC QS pair\n        uint256 lp_totalQi4 = qi.balanceOf(address(QSpair4));\n\n        if(lp_stakedBalance4 > 0) {\n            lp_powah = lp_powah.add(lp_totalQi4.mul(lp_stakedBalance4).div(QSpair4.totalSupply()));\n        }\n\n        // add any unharvested Qi from the qi-mimatic staked pool\n        qi_powah = qi_powah.add(chef.pending(0, owner));\n        qi_powah = qi_powah.add(chef.pending(1, owner));\n        qi_powah = qi_powah.add(chef.pending(2, owner));\n        qi_powah = qi_powah.add(chef.pending(4, owner));\n\n        // need to add nonincentivized farms as well\n\n        qi_powah = getAllFarms(qi_powah, owner);\n\n        // add eQi\n        qi_powah = qi_powah.add(eqi.balanceOf(owner));\n\n\n        qi_powah = getAllCompounders(qi_powah, owner);\n\n        return lp_powah.add(qi_powah);\n    }\n\n    function allowance(address, address) public pure returns (uint256) {\n        return 0;\n    }\n\n    function transfer(address, uint256) public pure returns (bool) {\n        return false;\n    }\n\n    function approve(address, uint256) public pure returns (bool) {\n        return false;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public pure returns (bool) {\n        return false;\n    }\n}"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}