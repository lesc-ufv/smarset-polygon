{{
  "language": "Solidity",
  "sources": {
    "contracts/delta/WunderPoolDelta.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./WunderVaultDelta.sol\";\n\ninterface IPoolLauncher {\n    function addPoolToMembersPools(address _pool, address _member) external;\n\n    function removePoolFromMembersPools(address _pool, address _member)\n        external;\n\n    function wunderProposal() external view returns (address);\n}\n\ninterface WunderProposal {\n    function createProposal(\n        address creator,\n        uint256 proposalId,\n        string memory title,\n        string memory description,\n        address[] memory contractAddresses,\n        string[] memory actions,\n        bytes[] memory params,\n        uint256[] memory transactionValues,\n        uint256 deadline\n    ) external;\n\n    function vote(\n        uint256 _proposalId,\n        uint256 _mode,\n        address _voter\n    ) external;\n\n    function proposalExecutable(address _pool, uint256 _proposalId)\n        external\n        view\n        returns (bool executable, string memory errorMessage);\n\n    function setProposalExecuted(uint256 _proposalId) external;\n\n    function getProposalTransactions(address _pool, uint256 _proposalId)\n        external\n        view\n        returns (\n            string[] memory actions,\n            bytes[] memory params,\n            uint256[] memory transactionValues,\n            address[] memory contractAddresses\n        );\n}\n\ncontract WunderPoolDelta is WunderVaultDelta {\n    address public wunderProposal;\n    uint256[] public proposalIds;\n\n    address[] public whiteList;\n    mapping(address => bool) public whiteListLookup;\n\n    address[] public members;\n    mapping(address => bool) public memberLookup;\n\n    string public name;\n    address public launcherAddress;\n    uint256 public entryBarrier;\n\n    bool public poolClosed = false;\n\n    modifier exceptPool() {\n        require(msg.sender != address(this));\n        _;\n    }\n\n    event NewProposal(\n        uint256 indexed id,\n        address indexed creator,\n        string title\n    );\n    event Voted(\n        uint256 indexed proposalId,\n        address indexed voter,\n        uint256 mode\n    );\n    event ProposalExecuted(\n        uint256 indexed proposalId,\n        address indexed executor,\n        bytes[] result\n    );\n    event NewMember(address indexed memberAddress, uint256 stake);\n\n    constructor(\n        string memory _name,\n        address _launcher,\n        address _governanceToken,\n        uint256 _entryBarrier,\n        address _creator\n    ) WunderVaultDelta(_governanceToken) {\n        name = _name;\n        launcherAddress = _launcher;\n        entryBarrier = _entryBarrier;\n        whiteList.push(_creator);\n        whiteListLookup[_creator] = true;\n        addToken(USDC, false, 0);\n    }\n\n    receive() external payable {}\n\n    function createProposalForUser(\n        address _user,\n        string memory _title,\n        string memory _description,\n        address[] memory _contractAddresses,\n        string[] memory _actions,\n        bytes[] memory _params,\n        uint256[] memory _transactionValues,\n        uint256 _deadline,\n        bytes memory _signature\n    ) public {\n        uint256 nextProposalId = proposalIds.length;\n        proposalIds.push(nextProposalId);\n\n        bytes32 message = prefixed(\n            keccak256(\n                abi.encode(\n                    _user,\n                    address(this),\n                    _title,\n                    _description,\n                    _contractAddresses,\n                    _actions,\n                    _params,\n                    _transactionValues,\n                    _deadline,\n                    nextProposalId\n                )\n            )\n        );\n\n        require(\n            recoverSigner(message, _signature) == _user,\n            \"Invalid Signature\"\n        );\n        require(isMember(_user), \"Only Members can create Proposals\");\n\n        WunderProposal(IPoolLauncher(launcherAddress).wunderProposal())\n            .createProposal(\n                _user,\n                nextProposalId,\n                _title,\n                _description,\n                _contractAddresses,\n                _actions,\n                _params,\n                _transactionValues,\n                _deadline\n            );\n\n        emit NewProposal(nextProposalId, msg.sender, _title);\n    }\n\n    function voteForUser(\n        address _user,\n        uint256 _proposalId,\n        uint256 _mode,\n        bytes memory _signature\n    ) public {\n        bytes32 message = prefixed(\n            keccak256(\n                abi.encodePacked(_user, address(this), _proposalId, _mode)\n            )\n        );\n\n        require(\n            recoverSigner(message, _signature) == _user,\n            \"Invalid Signature\"\n        );\n        WunderProposal(IPoolLauncher(launcherAddress).wunderProposal()).vote(\n            _proposalId,\n            _mode,\n            _user\n        );\n        emit Voted(_proposalId, _user, _mode);\n    }\n\n    function executeProposal(uint256 _proposalId) public {\n        poolClosed = true;\n        (bool executable, string memory errorMessage) = WunderProposal(\n            IPoolLauncher(launcherAddress).wunderProposal()\n        ).proposalExecutable(address(this), _proposalId);\n        require(executable, errorMessage);\n        WunderProposal(IPoolLauncher(launcherAddress).wunderProposal())\n            .setProposalExecuted(_proposalId);\n        (\n            string[] memory actions,\n            bytes[] memory params,\n            uint256[] memory transactionValues,\n            address[] memory contractAddresses\n        ) = WunderProposal(IPoolLauncher(launcherAddress).wunderProposal())\n                .getProposalTransactions(address(this), _proposalId);\n        bytes[] memory results = new bytes[](contractAddresses.length);\n\n        for (uint256 index = 0; index < contractAddresses.length; index++) {\n            address contractAddress = contractAddresses[index];\n            bytes memory callData = bytes.concat(\n                abi.encodeWithSignature(actions[index]),\n                params[index]\n            );\n\n            bool success = false;\n            bytes memory result;\n            (success, result) = contractAddress.call{\n                value: transactionValues[index]\n            }(callData);\n            require(success, \"Execution failed\");\n            results[index] = result;\n        }\n\n        emit ProposalExecuted(_proposalId, msg.sender, results);\n    }\n\n    function joinForUser(uint256 _amount, address _user) public exceptPool {\n        require(!poolClosed, \"Pool Closed\");\n        require(\n            (_amount >= entryBarrier && _amount >= governanceTokenPrice()),\n            \"Increase Stake\"\n        );\n        require(\n            ERC20Interface(USDC).transferFrom(_user, address(this), _amount),\n            \"USDC Transfer failed\"\n        );\n        addMember(_user);\n        _issueGovernanceTokens(_user, _amount);\n        emit NewMember(_user, _amount);\n    }\n\n    function fundPool(uint256 amount) external exceptPool {\n        require(!poolClosed, \"Pool Closed\");\n        require(\n            ERC20Interface(USDC).transferFrom(\n                msg.sender,\n                address(this),\n                amount\n            ),\n            \"USDC Transfer failed\"\n        );\n        _issueGovernanceTokens(msg.sender, amount);\n    }\n\n    function addMember(address _newMember) internal {\n        require(!isMember(_newMember), \"Already Member\");\n        require(isWhiteListed(_newMember), \"Not On Whitelist\");\n        members.push(_newMember);\n        memberLookup[_newMember] = true;\n        IPoolLauncher(launcherAddress).addPoolToMembersPools(\n            address(this),\n            _newMember\n        );\n    }\n\n    function addToWhiteListForUser(\n        address _user,\n        address _newMember,\n        bytes memory _signature\n    ) public {\n        require(isMember(_user), \"Only Members can Invite new Users\");\n        bytes32 message = prefixed(\n            keccak256(abi.encodePacked(_user, address(this), _newMember))\n        );\n\n        require(\n            recoverSigner(message, _signature) == _user,\n            \"Invalid Signature\"\n        );\n\n        if (!isWhiteListed(_newMember)) {\n            whiteList.push(_newMember);\n            whiteListLookup[_newMember] = true;\n            IPoolLauncher(launcherAddress).addPoolToMembersPools(\n                address(this),\n                _newMember\n            );\n        }\n    }\n\n    function isMember(address _maybeMember) public view returns (bool) {\n        return memberLookup[_maybeMember];\n    }\n\n    function isWhiteListed(address _user) public view returns (bool) {\n        return whiteListLookup[_user];\n    }\n\n    function poolMembers() public view returns (address[] memory) {\n        return members;\n    }\n\n    function getAllProposalIds() public view returns (uint256[] memory) {\n        return proposalIds;\n    }\n\n    function liquidatePool() public onlyPool {\n        _distributeFullBalanceOfAllTokensEvenly(members);\n        _distributeAllMaticEvenly(members);\n        _distributeAllNftsEvenly(members);\n        _destroyGovernanceToken();\n        selfdestruct(payable(msg.sender));\n    }\n\n    function splitSignature(bytes memory sig)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        require(sig.length == 65);\n\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n    }\n\n    function recoverSigner(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\n\n        return ecrecover(message, v, r, s);\n    }\n\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n            );\n    }\n}\n"
    },
    "contracts/delta/WunderVaultDelta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ERC20Interface {\n    function balanceOf(address account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n}\n\ninterface ERC721Interface {\n    function ownerOf(uint256 tokenId) external view returns (address);\n}\n\ninterface IGovernanceToken {\n    function issue(address, uint256) external;\n\n    function destroy() external;\n\n    function price() external view returns (uint256);\n}\n\ncontract WunderVaultDelta {\n    address public USDC = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\n\n    address public governanceToken;\n\n    address[] public ownedTokenAddresses;\n    mapping(address => bool) public ownedTokenLookup;\n\n    address[] public ownedNftAddresses;\n    mapping(address => uint256[]) ownedNftLookup;\n\n    modifier onlyPool() {\n        require(\n            msg.sender == address(this),\n            \"Not allowed. Try submitting a proposal\"\n        );\n        _;\n    }\n\n    event TokenAdded(\n        address indexed tokenAddress,\n        bool _isERC721,\n        uint256 _tokenId\n    );\n    event MaticWithdrawed(address indexed receiver, uint256 amount);\n    event TokensWithdrawed(\n        address indexed tokenAddress,\n        address indexed receiver,\n        uint256 amount\n    );\n\n    constructor(address _tokenAddress) {\n        governanceToken = _tokenAddress;\n    }\n\n    function addToken(\n        address _tokenAddress,\n        bool _isERC721,\n        uint256 _tokenId\n    ) public {\n        (, bytes memory nameData) = _tokenAddress.call(\n            abi.encodeWithSignature(\"name()\")\n        );\n        (, bytes memory symbolData) = _tokenAddress.call(\n            abi.encodeWithSignature(\"symbol()\")\n        );\n        (, bytes memory balanceData) = _tokenAddress.call(\n            abi.encodeWithSignature(\"balanceOf(address)\", address(this))\n        );\n\n        require(nameData.length > 0, \"Invalid Token\");\n        require(symbolData.length > 0, \"Invalid Token\");\n        require(balanceData.length > 0, \"Invalid Token\");\n\n        if (_isERC721) {\n            if (ownedNftLookup[_tokenAddress].length == 0) {\n                ownedNftAddresses.push(_tokenAddress);\n            }\n            if (\n                ERC721Interface(_tokenAddress).ownerOf(_tokenId) ==\n                address(this)\n            ) {\n                ownedNftLookup[_tokenAddress].push(_tokenId);\n            }\n        } else if (!ownedTokenLookup[_tokenAddress]) {\n            ownedTokenAddresses.push(_tokenAddress);\n            ownedTokenLookup[_tokenAddress] = true;\n        }\n        emit TokenAdded(_tokenAddress, _isERC721, _tokenId);\n    }\n\n    function removeNft(address _tokenAddress, uint256 _tokenId) public {\n        if (ERC721Interface(_tokenAddress).ownerOf(_tokenId) != address(this)) {\n            for (uint256 i = 0; i < ownedNftLookup[_tokenAddress].length; i++) {\n                if (ownedNftLookup[_tokenAddress][i] == _tokenId) {\n                    delete ownedNftLookup[_tokenAddress][i];\n                    ownedNftLookup[_tokenAddress][i] = ownedNftLookup[\n                        _tokenAddress\n                    ][ownedNftLookup[_tokenAddress].length - 1];\n                    ownedNftLookup[_tokenAddress].pop();\n                }\n            }\n        }\n    }\n\n    function getOwnedTokenAddresses() public view returns (address[] memory) {\n        return ownedTokenAddresses;\n    }\n\n    function getOwnedNftAddresses() public view returns (address[] memory) {\n        return ownedNftAddresses;\n    }\n\n    function getOwnedNftTokenIds(address _contractAddress)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return ownedNftLookup[_contractAddress];\n    }\n\n    function _distributeNftsEvenly(\n        address _tokenAddress,\n        address[] memory _receivers\n    ) public onlyPool {\n        for (uint256 i = 0; i < ownedNftLookup[_tokenAddress].length; i++) {\n            if (\n                ERC721Interface(_tokenAddress).ownerOf(\n                    ownedNftLookup[_tokenAddress][i]\n                ) == address(this)\n            ) {\n                uint256 sum = 0;\n                uint256 randomNumber = uint256(\n                    keccak256(\n                        abi.encode(\n                            _tokenAddress,\n                            ownedNftLookup[_tokenAddress][i],\n                            block.timestamp\n                        )\n                    )\n                ) % totalGovernanceTokens();\n                for (uint256 j = 0; j < _receivers.length; j++) {\n                    sum += governanceTokensOf(_receivers[j]);\n                    if (sum >= randomNumber) {\n                        (bool success, ) = _tokenAddress.call(\n                            abi.encodeWithSignature(\n                                \"transferFrom(address,address,uint256)\",\n                                address(this),\n                                _receivers[j],\n                                ownedNftLookup[_tokenAddress][i]\n                            )\n                        );\n                        require(success, \"Transfer failed\");\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function _distributeAllNftsEvenly(address[] memory _receivers)\n        public\n        onlyPool\n    {\n        for (uint256 i = 0; i < ownedNftAddresses.length; i++) {\n            _distributeNftsEvenly(ownedNftAddresses[i], _receivers);\n        }\n    }\n\n    function _distributeSomeBalanceOfTokenEvenly(\n        address _tokenAddress,\n        address[] memory _receivers,\n        uint256 _amount\n    ) public onlyPool {\n        for (uint256 index = 0; index < _receivers.length; index++) {\n            _withdrawTokens(\n                _tokenAddress,\n                _receivers[index],\n                (_amount * governanceTokensOf(_receivers[index])) /\n                    totalGovernanceTokens()\n            );\n        }\n    }\n\n    function _distributeFullBalanceOfTokenEvenly(\n        address _tokenAddress,\n        address[] memory _receivers\n    ) public onlyPool {\n        uint256 balance = ERC20Interface(_tokenAddress).balanceOf(\n            address(this)\n        );\n\n        _distributeSomeBalanceOfTokenEvenly(_tokenAddress, _receivers, balance);\n    }\n\n    function _distributeFullBalanceOfAllTokensEvenly(\n        address[] memory _receivers\n    ) public onlyPool {\n        for (uint256 index = 0; index < ownedTokenAddresses.length; index++) {\n            _distributeFullBalanceOfTokenEvenly(\n                ownedTokenAddresses[index],\n                _receivers\n            );\n        }\n    }\n\n    function _distributeMaticEvenly(\n        address[] memory _receivers,\n        uint256 _amount\n    ) public onlyPool {\n        for (uint256 index = 0; index < _receivers.length; index++) {\n            _withdrawMatic(\n                _receivers[index],\n                (_amount * governanceTokensOf(_receivers[index])) /\n                    totalGovernanceTokens()\n            );\n        }\n    }\n\n    function _distributeAllMaticEvenly(address[] memory _receivers)\n        public\n        onlyPool\n    {\n        uint256 balance = address(this).balance;\n        _distributeMaticEvenly(_receivers, balance);\n    }\n\n    function _withdrawTokens(\n        address _tokenAddress,\n        address _receiver,\n        uint256 _amount\n    ) public onlyPool {\n        if (_amount > 0) {\n            uint256 balance = ERC20Interface(_tokenAddress).balanceOf(\n                address(this)\n            );\n            require(balance >= _amount, \"Amount exceeds balance\");\n            require(\n                ERC20Interface(_tokenAddress).transfer(_receiver, _amount),\n                \"Withdraw Failed\"\n            );\n            emit TokensWithdrawed(_tokenAddress, _receiver, _amount);\n        }\n    }\n\n    function _withdrawMatic(address _receiver, uint256 _amount)\n        public\n        onlyPool\n    {\n        if (_amount > 0) {\n            require(address(this).balance >= _amount, \"Amount exceeds balance\");\n            payable(_receiver).transfer(_amount);\n            emit MaticWithdrawed(_receiver, _amount);\n        }\n    }\n\n    function _issueGovernanceTokens(address _newUser, uint256 _value) internal {\n        IGovernanceToken(governanceToken).issue(\n            _newUser,\n            _value / governanceTokenPrice()\n        );\n    }\n\n    function governanceTokensOf(address _user)\n        public\n        view\n        returns (uint256 balance)\n    {\n        return ERC20Interface(governanceToken).balanceOf(_user);\n    }\n\n    function totalGovernanceTokens() public view returns (uint256 balance) {\n        return ERC20Interface(governanceToken).totalSupply();\n    }\n\n    function governanceTokenPrice() public view returns (uint256 price) {\n        return IGovernanceToken(governanceToken).price();\n    }\n\n    function _destroyGovernanceToken() internal {\n        IGovernanceToken(governanceToken).destroy();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}