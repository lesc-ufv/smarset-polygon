{{
  "language": "Solidity",
  "sources": {
    "contracts/epsilon/WunderPoolEpsilon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./WunderVaultEpsilon.sol\";\n\ninterface IPoolLauncher {\n    function addPoolToMembersPools(address _pool, address _member) external;\n\n    function wunderProposal() external view returns (address);\n\n    function poolConfig() external view returns (address);\n}\n\ninterface WunderProposal {\n    function createProposal(\n        address creator,\n        uint256 proposalId,\n        string memory title,\n        string memory description,\n        address[] memory contractAddresses,\n        string[] memory actions,\n        bytes[] memory params,\n        uint256[] memory transactionValues\n    ) external;\n\n    function createJoinProposal(\n        address user,\n        uint256 proposalId,\n        string memory title,\n        string memory description,\n        uint256 amount,\n        uint256 governanceTokens,\n        address paymentToken,\n        address governanceToken\n    ) external;\n\n    function vote(\n        uint256 proposalId,\n        uint256 mode,\n        address voter\n    ) external;\n\n    function proposalExecutable(address _pool, uint256 _proposalId)\n        external\n        view\n        returns (bool executable, string memory errorMessage);\n\n    function setProposalExecuted(uint256 _proposalId) external;\n\n    function getProposalTransactions(address _pool, uint256 _proposalId)\n        external\n        view\n        returns (\n            string[] memory actions,\n            bytes[] memory params,\n            uint256[] memory transactionValues,\n            address[] memory contractAddresses\n        );\n}\n\ninterface PoolConfig {\n    function setupPool(\n        address pool,\n        uint256 minInvest,\n        uint256 maxInvest,\n        uint256 maxMembers,\n        uint8 votingThreshold,\n        uint256 votingTime,\n        uint256 minYesVoters\n    ) external;\n\n    function memberCanJoin(\n        address pool,\n        uint256 amount,\n        uint256 invested,\n        uint256 tokenPrice,\n        uint256 members\n    ) external view returns (bool, string memory);\n\n    function maxInvest(address) external view returns (uint256);\n}\n\ncontract WunderPoolEpsilon is WunderVaultEpsilon {\n    uint256[] internal proposalIds;\n\n    mapping(bytes32 => uint256) internal _secretWhiteList;\n    mapping(bytes32 => bool) internal _secretsUsed;\n\n    mapping(address => bool) internal whiteList;\n    mapping(address => uint256) public investOfUser;\n\n    address[] internal members;\n    mapping(address => bool) internal memberLookup;\n\n    string public name;\n    address public launcherAddress;\n\n    bool public poolClosed = false;\n\n    modifier exceptPool() {\n        require(msg.sender != address(this));\n        _;\n    }\n\n    event NewProposal(\n        uint256 indexed id,\n        address indexed creator,\n        string title\n    );\n    event Voted(\n        uint256 indexed proposalId,\n        address indexed voter,\n        uint256 mode\n    );\n    event ProposalExecuted(\n        uint256 indexed proposalId,\n        address indexed executor,\n        bytes[] result\n    );\n    event NewMember(address indexed memberAddress, uint256 stake);\n\n    constructor(\n        string memory _name,\n        address _launcher,\n        address _governanceToken,\n        address _creator,\n        address[] memory _members,\n        uint256 _amount\n    ) WunderVaultEpsilon(_governanceToken) {\n        name = _name;\n        launcherAddress = _launcher;\n        investOfUser[_creator] = _amount;\n        members.push(_creator);\n        memberLookup[_creator] = true;\n        addToken(USDC, false, 0);\n        for (uint256 i = 0; i < _members.length; i++) {\n            whiteList[_members[i]] = true;\n        }\n    }\n\n    receive() external payable {}\n\n    function createProposalForUser(\n        address _user,\n        string memory _title,\n        string memory _description,\n        address[] memory _contractAddresses,\n        string[] memory _actions,\n        bytes[] memory _params,\n        uint256[] memory _transactionValues,\n        bytes memory _signature\n    ) public {\n        uint256 nextProposalId = proposalIds.length;\n        proposalIds.push(nextProposalId);\n\n        bytes32 message = prefixed(\n            keccak256(\n                abi.encode(\n                    _user,\n                    address(this),\n                    _title,\n                    _description,\n                    _contractAddresses,\n                    _actions,\n                    _params,\n                    _transactionValues,\n                    nextProposalId\n                )\n            )\n        );\n\n        reqSig(message, _signature, _user);\n        reqMem(_user);\n\n        ProposalModule().createProposal(\n            _user,\n            nextProposalId,\n            _title,\n            _description,\n            _contractAddresses,\n            _actions,\n            _params,\n            _transactionValues\n        );\n\n        emit NewProposal(nextProposalId, _user, _title);\n    }\n\n    function createJoinProposal(\n        address _user,\n        string memory _title,\n        string memory _description,\n        uint256 _amount,\n        uint256 _governanceTokens\n    ) public {\n        uint256 nextProposalId = proposalIds.length;\n        proposalIds.push(nextProposalId);\n\n        ProposalModule().createJoinProposal(\n            _user,\n            nextProposalId,\n            _title,\n            _description,\n            _amount,\n            _governanceTokens,\n            USDC,\n            governanceToken\n        );\n\n        emit NewProposal(nextProposalId, _user, _title);\n    }\n\n    function voteForUser(\n        address _user,\n        uint256 _proposalId,\n        uint256 _mode,\n        bytes memory _signature\n    ) public {\n        bytes32 message = prefixed(\n            keccak256(\n                abi.encodePacked(_user, address(this), _proposalId, _mode)\n            )\n        );\n\n        reqSig(message, _signature, _user);\n        ProposalModule().vote(_proposalId, _mode, _user);\n        emit Voted(_proposalId, _user, _mode);\n    }\n\n    function executeProposal(uint256 _proposalId) public {\n        poolClosed = true;\n        (bool executable, string memory errorMessage) = ProposalModule()\n            .proposalExecutable(address(this), _proposalId);\n        require(executable, errorMessage);\n        ProposalModule().setProposalExecuted(_proposalId);\n        (\n            string[] memory actions,\n            bytes[] memory params,\n            uint256[] memory transactionValues,\n            address[] memory contractAddresses\n        ) = ProposalModule().getProposalTransactions(\n                address(this),\n                _proposalId\n            );\n        bytes[] memory results = new bytes[](contractAddresses.length);\n\n        for (uint256 index = 0; index < contractAddresses.length; index++) {\n            address contractAddress = contractAddresses[index];\n            bytes memory callData = bytes.concat(\n                abi.encodeWithSignature(actions[index]),\n                params[index]\n            );\n\n            bool success = false;\n            bytes memory result;\n            (success, result) = contractAddress.call{\n                value: transactionValues[index]\n            }(callData);\n            require(success, \"Execution failed\");\n            results[index] = result;\n        }\n\n        emit ProposalExecuted(_proposalId, msg.sender, results);\n    }\n\n    function joinForUser(\n        uint256 _amount,\n        address _user,\n        string memory _secret\n    ) public exceptPool {\n        if (governanceTokensOf(_user) <= 0) {\n            require(!poolClosed, \"Pool Closed\");\n            if (_secretWhiteList[keccak256(bytes(_secret))] > 0) {\n                _secretWhiteList[keccak256(bytes(_secret))] -= 1;\n            } else {\n                require(isWhiteListed(_user), \"Not On Whitelist\");\n            }\n\n            reqJoin(_amount, _user);\n            reqTra(USDC, _user, address(this), _amount);\n            investOfUser[_user] += _amount;\n            _issueGovernanceTokens(_user, _amount / governanceTokenPrice());\n        }\n        _addMember(_user);\n        emit NewMember(_user, _amount);\n    }\n\n    function fundPool(uint256 _amount) external exceptPool {\n        require(!poolClosed, \"Pool Closed\");\n        require(\n            investOfUser[msg.sender] + _amount <=\n                ConfigModule().maxInvest(address(this)),\n            \"maxInvest reached\"\n        );\n        investOfUser[msg.sender] += _amount;\n        reqTra(USDC, msg.sender, address(this), _amount);\n        _issueGovernanceTokens(msg.sender, _amount / governanceTokenPrice());\n    }\n\n    function addMember(address _newMember) public {\n        require(msg.sender == address(this));\n        _addMember(_newMember);\n    }\n\n    function _addMember(address _newMember) internal {\n        require(!isMember(_newMember), \"Already Member\");\n        members.push(_newMember);\n        memberLookup[_newMember] = true;\n        IPoolLauncher(launcherAddress).addPoolToMembersPools(\n            address(this),\n            _newMember\n        );\n    }\n\n    function addToWhiteListForUser(\n        address _user,\n        address _newMember,\n        bytes memory _signature\n    ) public {\n        reqMem(_user);\n        bytes32 message = prefixed(\n            keccak256(abi.encodePacked(_user, address(this), _newMember))\n        );\n\n        reqSig(message, _signature, _user);\n\n        if (!isWhiteListed(_newMember)) {\n            whiteList[_newMember] = true;\n            IPoolLauncher(launcherAddress).addPoolToMembersPools(\n                address(this),\n                _newMember\n            );\n        }\n    }\n\n    function addToWhiteListWithSecret(\n        address _user,\n        bytes32 _hashedSecret,\n        uint256 _validForCount,\n        bytes memory _signature\n    ) public {\n        reqMem(_user);\n        require(!_secretsUsed[_hashedSecret]);\n        bytes32 message = prefixed(\n            keccak256(\n                abi.encodePacked(\n                    _user,\n                    address(this),\n                    _hashedSecret,\n                    _validForCount\n                )\n            )\n        );\n\n        reqSig(message, _signature, _user);\n        _secretWhiteList[_hashedSecret] = _validForCount;\n        _secretsUsed[_hashedSecret] = true;\n    }\n\n    function isMember(address _maybeMember) public view returns (bool) {\n        return memberLookup[_maybeMember];\n    }\n\n    function isWhiteListed(address _user) public view returns (bool) {\n        return whiteList[_user];\n    }\n\n    function poolMembers() public view returns (address[] memory) {\n        return members;\n    }\n\n    function getAllProposalIds() public view returns (uint256[] memory) {\n        return proposalIds;\n    }\n\n    function liquidatePool() public {\n        require(msg.sender == address(this));\n        _distributeFullBalanceOfAllTokensEvenly(members);\n        _distributeAllMaticEvenly(members);\n        _distributeAllNftsEvenly(members);\n        _destroyGovernanceToken();\n        selfdestruct(payable(members[0]));\n    }\n\n    function ConfigModule() internal view returns (PoolConfig) {\n        return PoolConfig(IPoolLauncher(launcherAddress).poolConfig());\n    }\n\n    function ProposalModule() internal view returns (WunderProposal) {\n        return WunderProposal(IPoolLauncher(launcherAddress).wunderProposal());\n    }\n\n    function reqSig(\n        bytes32 _msg,\n        bytes memory _sig,\n        address _usr\n    ) internal pure {\n        require(recoverSigner(_msg, _sig) == _usr, \"Invalid Signature\");\n    }\n\n    function reqMem(address _usr) internal view {\n        require(isMember(_usr), \"Not a Member\");\n    }\n\n    function reqJoin(uint256 _amount, address _user) internal view {\n        (bool canJoin, string memory errMsg) = ConfigModule().memberCanJoin(\n            address(this),\n            _amount,\n            investOfUser[_user],\n            governanceTokenPrice(),\n            members.length\n        );\n        require(canJoin, errMsg);\n    }\n\n    function splitSignature(bytes memory sig)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        require(sig.length == 65);\n\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n    }\n\n    function recoverSigner(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\n\n        return ecrecover(message, v, r, s);\n    }\n\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n            );\n    }\n}\n"
    },
    "contracts/epsilon/WunderVaultEpsilon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ERC20Interface {\n    function balanceOf(address account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n}\n\ninterface ERC721Interface {\n    function ownerOf(uint256 tokenId) external view returns (address);\n}\n\ninterface IGovernanceToken {\n    function setPoolAddress(address _poolAddress) external;\n\n    function issue(address, uint256) external;\n\n    function destroy() external;\n\n    function price() external view returns (uint256);\n}\n\ncontract WunderVaultEpsilon {\n    address public USDC = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\n\n    address public governanceToken;\n\n    address[] internal ownedTokenAddresses;\n    mapping(address => bool) public ownedTokenLookup;\n\n    address[] internal ownedNftAddresses;\n    mapping(address => uint256[]) ownedNftLookup;\n\n    event TokenAdded(\n        address indexed tokenAddress,\n        bool _isERC721,\n        uint256 _tokenId\n    );\n    event TokensWithdrawed(\n        address indexed tokenAddress,\n        address indexed receiver,\n        uint256 amount\n    );\n\n    constructor(address _tokenAddress) {\n        governanceToken = _tokenAddress;\n    }\n\n    function addToken(\n        address _tokenAddress,\n        bool _isERC721,\n        uint256 _tokenId\n    ) public {\n        if (_isERC721) {\n            if (ownedNftLookup[_tokenAddress].length == 0) {\n                ownedNftAddresses.push(_tokenAddress);\n            }\n            if (\n                ERC721Interface(_tokenAddress).ownerOf(_tokenId) ==\n                address(this)\n            ) {\n                ownedNftLookup[_tokenAddress].push(_tokenId);\n            }\n        } else if (!ownedTokenLookup[_tokenAddress]) {\n            ownedTokenAddresses.push(_tokenAddress);\n            ownedTokenLookup[_tokenAddress] = true;\n        }\n        emit TokenAdded(_tokenAddress, _isERC721, _tokenId);\n    }\n\n    function removeNft(address _tokenAddress, uint256 _tokenId) public {\n        if (ERC721Interface(_tokenAddress).ownerOf(_tokenId) != address(this)) {\n            for (uint256 i = 0; i < ownedNftLookup[_tokenAddress].length; i++) {\n                if (ownedNftLookup[_tokenAddress][i] == _tokenId) {\n                    delete ownedNftLookup[_tokenAddress][i];\n                    ownedNftLookup[_tokenAddress][i] = ownedNftLookup[\n                        _tokenAddress\n                    ][ownedNftLookup[_tokenAddress].length - 1];\n                    ownedNftLookup[_tokenAddress].pop();\n                }\n            }\n        }\n    }\n\n    function getOwnedTokenAddresses() public view returns (address[] memory) {\n        return ownedTokenAddresses;\n    }\n\n    function getOwnedNftAddresses() public view returns (address[] memory) {\n        return ownedNftAddresses;\n    }\n\n    function getOwnedNftTokenIds(address _contractAddress)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return ownedNftLookup[_contractAddress];\n    }\n\n    function _distributeNftsEvenly(\n        address _tokenAddress,\n        address[] memory _receivers\n    ) internal {\n        for (uint256 i = 0; i < ownedNftLookup[_tokenAddress].length; i++) {\n            if (\n                ERC721Interface(_tokenAddress).ownerOf(\n                    ownedNftLookup[_tokenAddress][i]\n                ) == address(this)\n            ) {\n                uint256 sum = 0;\n                uint256 randomNumber = uint256(\n                    keccak256(\n                        abi.encode(\n                            _tokenAddress,\n                            ownedNftLookup[_tokenAddress][i],\n                            block.timestamp\n                        )\n                    )\n                ) % totalGovernanceTokens();\n                for (uint256 j = 0; j < _receivers.length; j++) {\n                    sum += governanceTokensOf(_receivers[j]);\n                    if (sum >= randomNumber) {\n                        (bool success, ) = _tokenAddress.call(\n                            abi.encodeWithSignature(\n                                \"transferFrom(address,address,uint256)\",\n                                address(this),\n                                _receivers[j],\n                                ownedNftLookup[_tokenAddress][i]\n                            )\n                        );\n                        require(success, \"Transfer failed\");\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function _distributeAllNftsEvenly(address[] memory _receivers) internal {\n        for (uint256 i = 0; i < ownedNftAddresses.length; i++) {\n            _distributeNftsEvenly(ownedNftAddresses[i], _receivers);\n        }\n    }\n\n    function _distributeSomeBalanceOfTokenEvenly(\n        address _tokenAddress,\n        address[] memory _receivers,\n        uint256 _amount\n    ) internal {\n        for (uint256 index = 0; index < _receivers.length; index++) {\n            _withdrawTokens(\n                _tokenAddress,\n                _receivers[index],\n                (_amount * governanceTokensOf(_receivers[index])) /\n                    totalGovernanceTokens()\n            );\n        }\n    }\n\n    function _distributeFullBalanceOfTokenEvenly(\n        address _tokenAddress,\n        address[] memory _receivers\n    ) internal {\n        uint256 balance = ERC20Interface(_tokenAddress).balanceOf(\n            address(this)\n        );\n\n        _distributeSomeBalanceOfTokenEvenly(_tokenAddress, _receivers, balance);\n    }\n\n    function _distributeFullBalanceOfAllTokensEvenly(\n        address[] memory _receivers\n    ) internal {\n        for (uint256 index = 0; index < ownedTokenAddresses.length; index++) {\n            _distributeFullBalanceOfTokenEvenly(\n                ownedTokenAddresses[index],\n                _receivers\n            );\n        }\n    }\n\n    function _distributeMaticEvenly(\n        address[] memory _receivers,\n        uint256 _amount\n    ) internal {\n        for (uint256 index = 0; index < _receivers.length; index++) {\n            _withdrawMatic(\n                _receivers[index],\n                (_amount * governanceTokensOf(_receivers[index])) /\n                    totalGovernanceTokens()\n            );\n        }\n    }\n\n    function _distributeAllMaticEvenly(address[] memory _receivers) internal {\n        uint256 balance = address(this).balance;\n        _distributeMaticEvenly(_receivers, balance);\n    }\n\n    function _withdrawTokens(\n        address _tokenAddress,\n        address _receiver,\n        uint256 _amount\n    ) internal {\n        if (_amount > 0) {\n            require(ERC20Interface(_tokenAddress).transfer(_receiver, _amount));\n            emit TokensWithdrawed(_tokenAddress, _receiver, _amount);\n        }\n    }\n\n    function _withdrawMatic(address _receiver, uint256 _amount) internal {\n        if (_amount > 0) {\n            payable(_receiver).transfer(_amount);\n            emit TokensWithdrawed(address(0), _receiver, _amount);\n        }\n    }\n\n    function _issueGovernanceTokens(address _newUser, uint256 _amount)\n        internal\n    {\n        IGovernanceToken(governanceToken).issue(_newUser, _amount);\n    }\n\n    function governanceTokensOf(address _user)\n        public\n        view\n        returns (uint256 balance)\n    {\n        return ERC20Interface(governanceToken).balanceOf(_user);\n    }\n\n    function totalGovernanceTokens() public view returns (uint256 balance) {\n        return ERC20Interface(governanceToken).totalSupply();\n    }\n\n    function governanceTokenPrice() public view returns (uint256 price) {\n        return IGovernanceToken(governanceToken).price();\n    }\n\n    function _destroyGovernanceToken() internal {\n        IGovernanceToken(governanceToken).destroy();\n    }\n\n    function reqTra(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        require(\n            ERC20Interface(token).transferFrom(from, to, amount),\n            \"Transfer Failed\"\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}