{{
  "language": "Solidity",
  "sources": {
    "contracts/CErc20Delegator.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./CTokenInterfaces.sol\";\nimport \"./ComptrollerStorage.sol\";\n\n/**\n * @title Compound's CErc20Delegator Contract\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Compound\n */\ncontract CErc20Delegator is CDelegationStorage {\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param implementation_ The address of the implementation the contract delegates to\n     * @param becomeImplementationData The encoded args for becomeImplementation\n     */\n    constructor(address underlying_,\n                ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                string memory name_,\n                string memory symbol_,\n                address implementation_,\n                bytes memory becomeImplementationData,\n                uint256 reserveFactorMantissa_,\n                uint256 adminFeeMantissa_) public {\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,string,string,uint256,uint256)\",\n                                                            underlying_,\n                                                            comptroller_,\n                                                            interestRateModel_,\n                                                            name_,\n                                                            symbol_,\n                                                            reserveFactorMantissa_,\n                                                            adminFeeMantissa_));\n\n        // New implementations always get set via the settor (post-initialize)\n        delegateTo(implementation_, abi.encodeWithSignature(\"_setImplementationSafe(address,bool,bytes)\", implementation_, false, becomeImplementationData));\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize)\n            }\n        }\n        return returnData;\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    function () external payable {\n        // Cannot send value to CErc20Delegator\n        require(msg.value == 0, \"CErc20Delegator:fallback: cannot send value to fallback\");\n\n        // Check for automatic implementation\n        delegateTo(implementation, abi.encodeWithSignature(\"_prepare()\"));\n\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n            switch success\n            case 0 { revert(free_mem_ptr, returndatasize) }\n            default { return(free_mem_ptr, returndatasize) }\n        }\n    }\n}\n"
    },
    "contracts/CTokenInterfaces.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./IFuseFeeDistributor.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\ncontract CTokenAdminStorage {\n    /**\n     * @notice Administrator for Fuse\n     */\n    IFuseFeeDistributor internal constant fuseAdmin =\n        IFuseFeeDistributor(0x52CA19E22f8D8a1d63c1beEe3fC882A9D41CDfA2);\n}\n\ncontract CTokenStorage is CTokenAdminStorage {\n    /**\n     * @dev Guard variable for re-entrancy checks\n     */\n    bool internal _notEntered;\n\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    string public name;\n\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    string public symbol;\n\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    uint8 public decimals;\n\n    /**\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     */\n    uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\n\n    /**\n     * @notice Maximum fraction of interest that can be set aside for reserves + fees\n     */\n    uint256 internal constant reserveFactorPlusFeesMaxMantissa = 1e18;\n\n    /**\n     * @notice LEGACY USE ONLY: Pending administrator for this contract\n     */\n    address payable private __pendingAdmin;\n\n    /**\n     * @notice Contract which oversees inter-cToken operations\n     */\n    ComptrollerInterface public comptroller;\n\n    /**\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModel public interestRateModel;\n\n    /**\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n     */\n    uint256 internal initialExchangeRateMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for admin fees\n     */\n    uint256 public adminFeeMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for Fuse fees\n     */\n    uint256 public fuseFeeMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for reserves\n     */\n    uint256 public reserveFactorMantissa;\n\n    /**\n     * @notice Block number that interest was last accrued at\n     */\n    uint256 public accrualBlockNumber;\n\n    /**\n     * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n    uint256 public borrowIndex;\n\n    /**\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n    uint256 public totalBorrows;\n\n    /**\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint256 public totalReserves;\n\n    /**\n     * @notice Total amount of admin fees of the underlying held in this market\n     */\n    uint256 public totalAdminFees;\n\n    /**\n     * @notice Total amount of Fuse fees of the underlying held in this market\n     */\n    uint256 public totalFuseFees;\n\n    /**\n     * @notice Total number of tokens in circulation\n     */\n    uint256 public totalSupply;\n\n    /**\n     * @notice Official record of token balances for each account\n     */\n    mapping(address => uint256) internal accountTokens;\n\n    /**\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping(address => mapping(address => uint256)) internal transferAllowances;\n\n    /**\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interestIndex;\n    }\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /**\n     * @notice Share of seized collateral that is added to reserves\n     */\n    uint256 public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n}\n\ncontract CTokenInterface is CTokenStorage {\n    /**\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n\n    /**\n     * @notice Indicator that this is or is not a CEther contract (for inspection)\n     */\n    bool public constant isCEther = false;\n\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(\n        uint256 cashPrior,\n        uint256 interestAccumulated,\n        uint256 borrowIndex,\n        uint256 totalBorrows\n    );\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        address cTokenCollateral,\n        uint256 seizeTokens\n    );\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when comptroller is changed\n     */\n    event NewComptroller(\n        ComptrollerInterface oldComptroller,\n        ComptrollerInterface newComptroller\n    );\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(\n        InterestRateModel oldInterestRateModel,\n        InterestRateModel newInterestRateModel\n    );\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(\n        uint256 oldReserveFactorMantissa,\n        uint256 newReserveFactorMantissa\n    );\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(\n        address benefactor,\n        uint256 addAmount,\n        uint256 newTotalReserves\n    );\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(\n        address admin,\n        uint256 reduceAmount,\n        uint256 newTotalReserves\n    );\n\n    /**\n     * @notice Event emitted when the admin fee is changed\n     */\n    event NewAdminFee(uint256 oldAdminFeeMantissa, uint256 newAdminFeeMantissa);\n\n    /**\n     * @notice Event emitted when the Fuse fee is changed\n     */\n    event NewFuseFee(uint256 oldFuseFeeMantissa, uint256 newFuseFeeMantissa);\n\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    /**\n     * @notice Failure event\n     */\n    event Failure(uint256 error, uint256 info, uint256 detail);\n\n    /*** User Interface ***/\n\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account) public view returns (uint256);\n\n    function exchangeRateCurrent() public returns (uint256);\n\n    function exchangeRateStored() public view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function accrueInterest() public returns (uint256);\n\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    /*** Admin Functions ***/\n\n    function _setReserveFactor(uint256 newReserveFactorMantissa)\n        external\n        returns (uint256);\n\n    function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n    function _setInterestRateModel(InterestRateModel newInterestRateModel)\n        public\n        returns (uint256);\n}\n\ncontract CErc20Storage {\n    /**\n     * @notice Underlying asset for this CToken\n     */\n    address public underlying;\n}\n\ncontract CErc20Interface is CErc20Storage {\n    /*** User Interface ***/\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        returns (uint256);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) external returns (uint256);\n}\n\ncontract CEtherInterface is CErc20Storage {\n    /**\n     * @notice Indicator that this is a CEther contract (for inspection)\n     */\n    bool public constant isCEther = true;\n}\n\ncontract CDelegationStorage {\n    /**\n     * @notice Implementation address for this contract\n     */\n    address public implementation;\n}\n\ncontract CDelegateInterface is CDelegationStorage {\n    /**\n     * @notice Emitted when implementation is changed\n     */\n    event NewImplementation(\n        address oldImplementation,\n        address newImplementation\n    );\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementationSafe(\n        address implementation_,\n        bool allowResign,\n        bytes calldata becomeImplementationData\n    ) external;\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @dev Should revert if any issues arise which make it unfit for delegation\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes calldata data) external;\n\n    /**\n     * @notice Function called before all delegator functions\n     * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary\n     */\n    function _prepare() external payable;\n}\n\ninterface ComptrollerV3StorageInterface {\n    function admin() external view returns (address);\n\n    function adminHasRights() external view returns (bool);\n\n    function fuseAdminHasRights() external view returns (bool);\n\n    function autoImplementation() external view returns (bool);\n}\n"
    },
    "contracts/ComptrollerStorage.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./IFuseFeeDistributor.sol\";\nimport \"./CToken.sol\";\nimport \"./PriceOracle.sol\";\n\ncontract UnitrollerAdminStorage {\n    /**\n     * @notice Administrator for Fuse\n     */\n    IFuseFeeDistributor internal constant fuseAdmin = IFuseFeeDistributor(0x52CA19E22f8D8a1d63c1beEe3fC882A9D41CDfA2);\n\n    /**\n    * @notice Administrator for this contract\n    */\n    address public admin;\n\n    /**\n    * @notice Pending administrator for this contract\n    */\n    address public pendingAdmin;\n\n    /**\n     * @notice Whether or not the Fuse admin has admin rights\n     */\n    bool public fuseAdminHasRights = true;\n\n    /**\n     * @notice Whether or not the admin has admin rights\n     */\n    bool public adminHasRights = true;\n\n    /**\n     * @notice Returns a boolean indicating if the sender has admin rights\n     */\n    function hasAdminRights() internal view returns (bool) {\n        return (msg.sender == admin && adminHasRights) || (msg.sender == address(fuseAdmin) && fuseAdminHasRights);\n    }\n\n    /**\n    * @notice Active brains of Unitroller\n    */\n    address public comptrollerImplementation;\n\n    /**\n    * @notice Pending brains of Unitroller\n    */\n    address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint public liquidationIncentiveMantissa;\n\n    /**\n     * @notice UNUSED AFTER UPGRADE: Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint internal maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => CToken[]) public accountAssets;\n\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n    struct Market {\n        /**\n         * @notice Whether or not this market is listed\n         */\n        bool isListed;\n\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint collateralFactorMantissa;\n\n        /**\n         * @notice Per-market mapping of \"accounts in this asset\"\n         */\n        mapping(address => bool) accountMembership;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /// @notice A list of all markets\n    CToken[] public allMarkets;\n\n    /**\n     * @dev Maps borrowers to booleans indicating if they have entered any markets\n     */\n    mapping(address => bool) internal borrowers;\n\n    /// @notice A list of all borrowers who have entered markets\n    address[] public allBorrowers;\n\n    /// @notice Indexes of borrower account addresses in the `allBorrowers` array\n    mapping(address => uint256) internal borrowerIndexes;\n\n    /**\n     * @dev Maps suppliers to booleans indicating if they have ever supplied to any markets\n     */\n    mapping(address => bool) public suppliers;\n\n    /// @notice All cTokens addresses mapped by their underlying token addresses\n    mapping(address => CToken) public cTokensByUnderlying;\n\n    /// @notice Whether or not the supplier whitelist is enforced\n    bool public enforceWhitelist;\n\n    /// @notice Maps addresses to booleans indicating if they are allowed to supply assets (i.e., mint cTokens)\n    mapping(address => bool) public whitelist;\n\n    /// @notice An array of all whitelisted accounts\n    address[] public whitelistArray;\n\n    /// @notice Indexes of account addresses in the `whitelistArray` array\n    mapping(address => uint256) internal whitelistIndexes;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     *  Actions which allow users to remove their own assets cannot be paused.\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\n     */\n    address public pauseGuardian;\n    bool public _mintGuardianPaused;\n    bool public _borrowGuardianPaused;\n    bool public transferGuardianPaused;\n    bool public seizeGuardianPaused;\n    mapping(address => bool) public mintGuardianPaused;\n    mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n    /**\n     * @dev Whether or not the implementation should be auto-upgraded.\n     */\n    bool public autoImplementation;\n\n    /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint) public borrowCaps;\n\n    /// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n    mapping(address => uint) public supplyCaps;\n\n    /// @notice RewardsDistributor contracts to notify of flywheel changes.\n    address[] public rewardsDistributors;\n\n    /// @dev Guard variable for pool-wide/cross-asset re-entrancy checks\n    bool internal _notEntered;\n\n    /// @dev Whether or not _notEntered has been initialized\n    bool internal _notEnteredInitialized;\n}\n"
    },
    "contracts/InterestRateModel.sol": {
      "content": "pragma solidity ^0.5.16;\n\n/**\n  * @title Compound's InterestRateModel Interface\n  * @author Compound\n  */\ncontract InterestRateModel {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    bool public constant isInterestRateModel = true;\n\n    /**\n      * @notice Calculates the current borrow interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint);\n\n    /**\n      * @notice Calculates the current supply interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @param reserveFactorMantissa The current reserve factor the market has\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view returns (uint);\n\n}\n"
    },
    "contracts/ComptrollerInterface.sol": {
      "content": "pragma solidity ^0.5.16;\n\ncontract ComptrollerInterface {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    bool public constant isComptroller = true;\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n    function exitMarket(address cToken) external returns (uint);\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint);\n    function mintWithinLimits(address cToken, uint exchangeRateMantissa, uint accountTokens, uint mintAmount) external returns (uint);\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external;\n\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint);\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);\n    function borrowWithinLimits(address cToken, uint accountBorrowsNew) external returns (uint);\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) external;\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) external returns (uint);\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount,\n        uint borrowerIndex) external;\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount) external returns (uint);\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount,\n        uint seizeTokens) external;\n\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) external returns (uint);\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) external;\n\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint);\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint repayAmount) external view returns (uint, uint);\n    \n    /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n    function _beforeNonReentrant() external;\n    function _afterNonReentrant() external;\n}\n"
    },
    "contracts/IFuseFeeDistributor.sol": {
      "content": "pragma solidity ^0.5.16;\n\ninterface IFuseFeeDistributor {\n    function minBorrowEth() external view returns (uint256);\n    function maxSupplyEth() external view returns (uint256);\n    function maxUtilizationRate() external view returns (uint256);\n    function interestFeeRate() external view returns (uint256);\n    function comptrollerImplementationWhitelist(address oldImplementation, address newImplementation) external view returns (bool);\n    function cErc20DelegateWhitelist(address oldImplementation, address newImplementation, bool allowResign) external view returns (bool);\n    function cEtherDelegateWhitelist(address oldImplementation, address newImplementation, bool allowResign) external view returns (bool);\n    function latestComptrollerImplementation(address oldImplementation) external view returns (address);\n    function latestCErc20Delegate(address oldImplementation) external view returns (address cErc20Delegate, bool allowResign, bytes memory becomeImplementationData);\n    function latestCEtherDelegate(address oldImplementation) external view returns (address cEtherDelegate, bool allowResign, bytes memory becomeImplementationData);\n    function deployCEther(bytes calldata constructorData) external returns (address);\n    function deployCErc20(bytes calldata constructorData) external returns (address);\n    function () external payable;\n}\n"
    },
    "contracts/PriceOracle.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\n\ncontract PriceOracle {\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\n    bool public constant isPriceOracle = true;\n\n    /**\n      * @notice Get the underlying price of a cToken asset\n      * @param cToken The cToken to get the underlying price of\n      * @return The underlying asset price mantissa (scaled by 1e18).\n      *  Zero means the price is unavailable.\n      */\n    function getUnderlyingPrice(CToken cToken) external view returns (uint);\n}\n"
    },
    "contracts/CToken.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ncontract CToken is CTokenInterface, Exponential, TokenErrorReporter {\n    /**\n     * @notice Returns a boolean indicating if the sender has admin rights\n     */\n    function hasAdminRights() internal view returns (bool) {\n        ComptrollerV3StorageInterface comptrollerStorage = ComptrollerV3StorageInterface(\n                address(comptroller)\n            );\n        return\n            (msg.sender == comptrollerStorage.admin() &&\n                comptrollerStorage.adminHasRights()) ||\n            (msg.sender == address(fuseAdmin) &&\n                comptrollerStorage.fuseAdminHasRights());\n    }\n\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint256 reserveFactorMantissa_,\n        uint256 adminFeeMantissa_\n    ) public {\n        require(msg.sender == address(fuseAdmin), \"!fuseAdmin\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"init already\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"init exchange rate must > 0\");\n\n        // Set the comptroller\n        uint256 err = _setComptroller(comptroller_);\n        require(err == uint256(Error.NO_ERROR), \"setting cmp fail\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint256(Error.NO_ERROR), \"set irm fail\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // Set reserve factor\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n        require(err == uint256(Error.NO_ERROR), \"set reserve factor fail\");\n\n        // Set admin fee\n        err = _setAdminFeeFresh(adminFeeMantissa_);\n        require(err == uint256(Error.NO_ERROR), \"set admin fee fail\");\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Returns latest pending Fuse fee (to be set with `_setFuseFeeFresh`)\n     */\n    function getPendingFuseFeeFromAdmin() internal view returns (uint256) {\n        return fuseAdmin.interestFeeRate();\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(\n        address spender,\n        address src,\n        address dst,\n        uint256 tokens\n    ) internal returns (uint256) {\n        /* Fail if transfer not allowed */\n        uint256 allowed = comptroller.transferAllowed(\n            address(this),\n            src,\n            dst,\n            tokens\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.TRANSFER_COMPTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint256(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint256 allowanceNew;\n        uint256 srcTokensNew;\n        uint256 dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint256(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount)\n        external\n        nonReentrant(false)\n        returns (bool)\n    {\n        return\n            transferTokens(msg.sender, msg.sender, dst, amount) ==\n            uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external nonReentrant(false) returns (bool) {\n        return\n            transferTokens(msg.sender, src, dst, amount) ==\n            uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256)\n    {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint256 balance) = mulScalarTruncate(\n            exchangeRate,\n            accountTokens[owner]\n        );\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n        return balance;\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 cTokenBalance = accountTokens[account];\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (\n            uint256(Error.NO_ERROR),\n            cTokenBalance,\n            borrowBalance,\n            exchangeRateMantissa\n        );\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint256) {\n        return\n            interestRateModel.getBorrowRate(\n                getCashPrior(),\n                totalBorrows,\n                add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n            );\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view returns (uint256) {\n        return\n            interestRateModel.getSupplyRate(\n                getCashPrior(),\n                totalBorrows,\n                add_(totalReserves, add_(totalAdminFees, totalFuseFees)),\n                reserveFactorMantissa + fuseFeeMantissa + adminFeeMantissa\n            );\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent()\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"accrue interest failed\"\n        );\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"accrue interest failed\"\n        );\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account)\n        public\n        view\n        returns (uint256)\n    {\n        (MathError err, uint256 result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored:internal fail\");\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account)\n        internal\n        view\n        returns (MathError, uint256)\n    {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint256 principalTimesIndex;\n        uint256 result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(\n            borrowSnapshot.principal,\n            borrowIndex\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(\n            principalTimesIndex,\n            borrowSnapshot.interestIndex\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent()\n        public\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"accrue interest failed\"\n        );\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint256) {\n        (MathError err, uint256 result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"exchangeRateStored:internal fail\");\n        return result;\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal()\n        internal\n        view\n        returns (MathError, uint256)\n    {\n        uint256 _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)) / totalSupply\n             */\n            uint256 totalCash = getCashPrior();\n            uint256 cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\n                totalCash,\n                totalBorrows,\n                add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n            );\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(\n                cashPlusBorrowsMinusReserves,\n                _totalSupply\n            );\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint256) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public returns (uint256) {\n        /* Remember the initial block number */\n        uint256 currentBlockNumber = getBlockNumber();\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumber == currentBlockNumber) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint256 cashPrior = getCashPrior();\n\n        /* Calculate the current borrow interest rate */\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(\n            cashPrior,\n            totalBorrows,\n            add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n        );\n        require(\n            borrowRateMantissa <= borrowRateMaxMantissa,\n            \"borrow rate > max\"\n        );\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint256 blockDelta) = subUInt(\n            currentBlockNumber,\n            accrualBlockNumber\n        );\n        require(mathErr == MathError.NO_ERROR, \"couldn't calc block delta\");\n\n        return\n            finishInterestAccrual(\n                currentBlockNumber,\n                cashPrior,\n                borrowRateMantissa,\n                blockDelta\n            );\n    }\n\n    /**\n     * @dev Split off from `accrueInterest` to avoid \"stack too deep\" error\".\n     */\n    function finishInterestAccrual(\n        uint256 currentBlockNumber,\n        uint256 cashPrior,\n        uint256 borrowRateMantissa,\n        uint256 blockDelta\n    ) private returns (uint256) {\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  totalFuseFeesNew = interestAccumulated * fuseFee + totalFuseFees\n         *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(\n            Exp({mantissa: borrowRateMantissa}),\n            blockDelta\n        );\n        uint256 interestAccumulated = mul_ScalarTruncate(\n            simpleInterestFactor,\n            totalBorrows\n        );\n        uint256 totalBorrowsNew = add_(interestAccumulated, totalBorrows);\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\n            Exp({mantissa: reserveFactorMantissa}),\n            interestAccumulated,\n            totalReserves\n        );\n        uint256 totalFuseFeesNew = mul_ScalarTruncateAddUInt(\n            Exp({mantissa: fuseFeeMantissa}),\n            interestAccumulated,\n            totalFuseFees\n        );\n        uint256 totalAdminFeesNew = mul_ScalarTruncateAddUInt(\n            Exp({mantissa: adminFeeMantissa}),\n            interestAccumulated,\n            totalAdminFees\n        );\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(\n            simpleInterestFactor,\n            borrowIndex,\n            borrowIndex\n        );\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n        totalFuseFees = totalFuseFeesNew;\n        totalAdminFees = totalAdminFeesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(\n            cashPrior,\n            interestAccumulated,\n            borrowIndexNew,\n            totalBorrowsNew\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintInternal(uint256 mintAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (\n                fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED),\n                0\n            );\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 mintTokens;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n        uint256 actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint256 mintAmount)\n        internal\n        returns (uint256, uint256)\n    {\n        /* Fail if mint not allowed */\n        uint256 allowed = comptroller.mintAllowed(\n            address(this),\n            minter,\n            mintAmount\n        );\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.MINT_COMPTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK),\n                0\n            );\n        }\n\n        MintLocalVars memory vars;\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        // Check max supply\n        // unused function\n        /* allowed = comptroller.mintWithinLimits(address(this), vars.exchangeRateMantissa, accountTokens[minter], mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        } */\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualMintAmount,\n            Exp({mantissa: vars.exchangeRateMantissa})\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"MINT_EXCHANGE_CALCULATION_FAILED\"\n        );\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        vars.totalSupplyNew = add_(totalSupply, vars.mintTokens);\n\n        vars.accountTokensNew = add_(accountTokens[minter], vars.mintTokens);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n        comptroller.mintVerify(\n            address(this),\n            minter,\n            vars.actualMintAmount,\n            vars.mintTokens\n        );\n\n        return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemInternal(uint256 redeemTokens)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return\n                fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlyingInternal(uint256 redeemAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return\n                fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 redeemTokens;\n        uint256 redeemAmount;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(\n        address payable redeemer,\n        uint256 redeemTokensIn,\n        uint256 redeemAmountIn\n    ) internal returns (uint256) {\n        require(\n            redeemTokensIn == 0 || redeemAmountIn == 0,\n            \"one of redeemTokensIn or redeemAmountIn must be zero\"\n        );\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n                Exp({mantissa: vars.exchangeRateMantissa}),\n                redeemTokensIn\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n                redeemAmountIn,\n                Exp({mantissa: vars.exchangeRateMantissa})\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint256 allowed = comptroller.redeemAllowed(\n            address(this),\n            redeemer,\n            vars.redeemTokens\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.REDEEM_COMPTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.REDEEM_FRESHNESS_CHECK\n                );\n        }\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(\n            totalSupply,\n            vars.redeemTokens\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(\n            accountTokens[redeemer],\n            vars.redeemTokens\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(\n            address(this),\n            redeemer,\n            vars.redeemAmount,\n            vars.redeemTokens\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowInternal(uint256 borrowAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return\n                fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        return borrowFresh(msg.sender, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n    }\n\n    /**\n     * @notice Users borrow assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowFresh(address payable borrower, uint256 borrowAmount)\n        internal\n        returns (uint256)\n    {\n        /* Fail if borrow not allowed */\n        uint256 allowed = comptroller.borrowAllowed(\n            address(this),\n            borrower,\n            borrowAmount\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.BORROW_COMPTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.BORROW_FRESHNESS_CHECK\n                );\n        }\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        uint256 cashPrior = getCashPrior();\n\n        if (cashPrior < borrowAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.BORROW_CASH_NOT_AVAILABLE\n                );\n        }\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(\n            vars.accountBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        // Check min borrow for this user for this asset\n        allowed = comptroller.borrowWithinLimits(\n            address(this),\n            vars.accountBorrowsNew\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.BORROW_COMPTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(\n            totalBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(\n            borrower,\n            borrowAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(borrower, borrowAmount);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowInternal(uint256 repayAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowBehalfInternal(address borrower, uint256 repayAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 repayAmount;\n        uint256 borrowerIndex;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n        uint256 actualRepayAmount;\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) internal returns (uint256, uint256) {\n        /* Fail if repayBorrow not allowed */\n        uint256 allowed = comptroller.repayBorrowAllowed(\n            address(this),\n            payer,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.REPAY_BORROW_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint256(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(\n            vars.accountBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\"\n        );\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(\n            totalBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\"\n        );\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(\n            payer,\n            borrower,\n            vars.actualRepayAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowInternal(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) internal nonReentrant(false) returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        return\n            liquidateBorrowFresh(\n                msg.sender,\n                borrower,\n                repayAmount,\n                cTokenCollateral\n            );\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) internal returns (uint256, uint256) {\n        /* Fail if liquidate not allowed */\n        uint256 allowed = comptroller.liquidateBorrowAllowed(\n            address(this),\n            address(cTokenCollateral),\n            liquidator,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.LIQUIDATE_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        /* Verify cTokenCollateral market's block number equals current block number */\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (\n                fail(\n                    Error.INVALID_ACCOUNT_PAIR,\n                    FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER\n                ),\n                0\n            );\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (\n                fail(\n                    Error.INVALID_CLOSE_AMOUNT_REQUESTED,\n                    FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO\n                ),\n                0\n            );\n        }\n\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == uint256(-1)) {\n            return (\n                fail(\n                    Error.INVALID_CLOSE_AMOUNT_REQUESTED,\n                    FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX\n                ),\n                0\n            );\n        }\n\n        /* Fail if repayBorrow fails */\n        (\n            uint256 repayBorrowError,\n            uint256 actualRepayAmount\n        ) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(repayBorrowError),\n                    FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED\n                ),\n                0\n            );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (uint256 amountSeizeError, uint256 seizeTokens) = comptroller\n            .liquidateCalculateSeizeTokens(\n                address(this),\n                address(cTokenCollateral),\n                actualRepayAmount\n            );\n        require(\n            amountSeizeError == uint256(Error.NO_ERROR),\n            \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\"\n        );\n\n        /* Revert if borrower collateral token balance < seizeTokens */\n        require(\n            cTokenCollateral.balanceOf(borrower) >= seizeTokens,\n            \"LIQUIDATE_SEIZE_TOO_MUCH\"\n        );\n\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n        uint256 seizeError;\n        if (address(cTokenCollateral) == address(this)) {\n            seizeError = seizeInternal(\n                address(this),\n                liquidator,\n                borrower,\n                seizeTokens\n            );\n        } else {\n            seizeError = cTokenCollateral.seize(\n                liquidator,\n                borrower,\n                seizeTokens\n            );\n        }\n\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(\n            liquidator,\n            borrower,\n            actualRepayAmount,\n            address(cTokenCollateral),\n            seizeTokens\n        );\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\n\n        return (uint256(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external nonReentrant(true) returns (uint256) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    struct SeizeInternalLocalVars {\n        MathError mathErr;\n        uint256 borrowerTokensNew;\n        uint256 liquidatorTokensNew;\n        uint256 liquidatorSeizeTokens;\n        uint256 protocolSeizeTokens;\n        uint256 protocolSeizeAmount;\n        uint256 exchangeRateMantissa;\n        uint256 totalReservesNew;\n        uint256 totalSupplyNew;\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(\n        address seizerToken,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) internal returns (uint256) {\n        /* Fail if seize not allowed */\n        uint256 allowed = comptroller.seizeAllowed(\n            address(this),\n            seizerToken,\n            liquidator,\n            borrower,\n            seizeTokens\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return\n                fail(\n                    Error.INVALID_ACCOUNT_PAIR,\n                    FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER\n                );\n        }\n\n        SeizeInternalLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        (vars.mathErr, vars.borrowerTokensNew) = subUInt(\n            accountTokens[borrower],\n            seizeTokens\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        vars.protocolSeizeTokens = mul_(\n            seizeTokens,\n            Exp({mantissa: protocolSeizeShareMantissa})\n        );\n        vars.liquidatorSeizeTokens = sub_(\n            seizeTokens,\n            vars.protocolSeizeTokens\n        );\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n\n        vars.protocolSeizeAmount = mul_ScalarTruncate(\n            Exp({mantissa: vars.exchangeRateMantissa}),\n            vars.protocolSeizeTokens\n        );\n\n        vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\n        vars.totalSupplyNew = sub_(totalSupply, vars.protocolSeizeTokens);\n\n        (vars.mathErr, vars.liquidatorTokensNew) = addUInt(\n            accountTokens[liquidator],\n            vars.liquidatorSeizeTokens\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        totalReserves = vars.totalReservesNew;\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[borrower] = vars.borrowerTokensNew;\n        accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n        emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n        emit ReservesAdded(\n            address(this),\n            vars.protocolSeizeAmount,\n            vars.totalReservesNew\n        );\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Internal function to set a new comptroller\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptroller(ComptrollerInterface newComptroller)\n        internal\n        returns (uint256)\n    {\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), \"!isComptroller\");\n\n        // Set market's comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and sets a new admin fee for the protocol using _setAdminFeeFresh\n     * @dev Admin function to accrue interest and set a new admin fee\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setAdminFee(uint256 newAdminFeeMantissa)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee change failed.\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _setAdminFeeFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setAdminFeeFresh(newAdminFeeMantissa);\n    }\n\n    /**\n     * @notice Sets a new admin fee for the protocol (*requires fresh interest accrual)\n     * @dev Admin function to set a new admin fee\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setAdminFeeFresh(uint256 newAdminFeeMantissa)\n        internal\n        returns (uint256)\n    {\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_ADMIN_FEE_FRESH_CHECK\n                );\n        }\n\n        // Sanitize newAdminFeeMantissa\n        if (newAdminFeeMantissa == uint256(-1))\n            newAdminFeeMantissa = adminFeeMantissa;\n\n        // Get latest Fuse fee\n        uint256 newFuseFeeMantissa = getPendingFuseFeeFromAdmin();\n\n        // Check reserveFactorMantissa + newAdminFeeMantissa + newFuseFeeMantissa  reserveFactorPlusFeesMaxMantissa\n        if (\n            add_(\n                add_(reserveFactorMantissa, newAdminFeeMantissa),\n                newFuseFeeMantissa\n            ) > reserveFactorPlusFeesMaxMantissa\n        ) {\n            return\n                fail(Error.BAD_INPUT, FailureInfo.SET_ADMIN_FEE_BOUNDS_CHECK);\n        }\n\n        // If setting admin fee\n        if (adminFeeMantissa != newAdminFeeMantissa) {\n            // Check caller is admin\n            if (!hasAdminRights()) {\n                return\n                    fail(\n                        Error.UNAUTHORIZED,\n                        FailureInfo.SET_ADMIN_FEE_ADMIN_CHECK\n                    );\n            }\n\n            // Set admin fee\n            uint256 oldAdminFeeMantissa = adminFeeMantissa;\n            adminFeeMantissa = newAdminFeeMantissa;\n\n            // Emit event\n            emit NewAdminFee(oldAdminFeeMantissa, newAdminFeeMantissa);\n        }\n\n        // If setting Fuse fee\n        if (fuseFeeMantissa != newFuseFeeMantissa) {\n            // Set Fuse fee\n            uint256 oldFuseFeeMantissa = fuseFeeMantissa;\n            fuseFeeMantissa = newFuseFeeMantissa;\n\n            // Emit event\n            emit NewFuseFee(oldFuseFeeMantissa, newFuseFeeMantissa);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactor(uint256 newReserveFactorMantissa)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /**\n     * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n     * @dev Admin function to set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactorFresh(uint256 newReserveFactorMantissa)\n        internal\n        returns (uint256)\n    {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK\n                );\n        }\n\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK\n                );\n        }\n\n        // Check newReserveFactor  maxReserveFactor\n        if (\n            add_(\n                add_(newReserveFactorMantissa, adminFeeMantissa),\n                fuseFeeMantissa\n            ) > reserveFactorPlusFeesMaxMantissa\n        ) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK\n                );\n        }\n\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(\n            oldReserveFactorMantissa,\n            newReserveFactorMantissa\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReserves(uint256 reduceAmount)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReservesFresh(uint256 reduceAmount)\n        internal\n        returns (uint256)\n    {\n        // totalReserves - reduceAmount\n        uint256 totalReservesNew;\n\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.REDUCE_RESERVES_ADMIN_CHECK\n                );\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.REDUCE_RESERVES_FRESH_CHECK\n                );\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        // Check reduceAmount  reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return\n                fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n        totalReservesNew = sub_(totalReserves, reduceAmount);\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(msg.sender, reduceAmount);\n\n        emit ReservesReduced(msg.sender, reduceAmount, totalReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces Fuse fees by transferring to Fuse\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawFuseFees(uint256 withdrawAmount)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted Fuse fee withdrawal failed.\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _withdrawFuseFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _withdrawFuseFeesFresh(withdrawAmount);\n    }\n\n    /**\n     * @notice Reduces Fuse fees by transferring to Fuse\n     * @dev Requires fresh interest accrual\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawFuseFeesFresh(uint256 withdrawAmount)\n        internal\n        returns (uint256)\n    {\n        // totalFuseFees - reduceAmount\n        uint256 totalFuseFeesNew;\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.WITHDRAW_FUSE_FEES_FRESH_CHECK\n                );\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < withdrawAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        // Check withdrawAmount  fuseFees[n] (totalFuseFees)\n        if (withdrawAmount > totalFuseFees) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.WITHDRAW_FUSE_FEES_VALIDATION\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked withdrawAmount <= totalFuseFees above, so this should never revert.\n        totalFuseFeesNew = sub_(totalFuseFees, withdrawAmount);\n\n        // Store fuseFees[n+1] = fuseFees[n] - withdrawAmount\n        totalFuseFees = totalFuseFeesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(address(fuseAdmin), withdrawAmount);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces admin fees by transferring to admin\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawAdminFees(uint256 withdrawAmount)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee withdrawal failed.\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _withdrawAdminFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _withdrawAdminFeesFresh(withdrawAmount);\n    }\n\n    /**\n     * @notice Reduces admin fees by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawAdminFeesFresh(uint256 withdrawAmount)\n        internal\n        returns (uint256)\n    {\n        // totalAdminFees - reduceAmount\n        uint256 totalAdminFeesNew;\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.WITHDRAW_ADMIN_FEES_FRESH_CHECK\n                );\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < withdrawAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        // Check withdrawAmount  adminFees[n] (totalAdminFees)\n        if (withdrawAmount > totalAdminFees) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.WITHDRAW_ADMIN_FEES_VALIDATION\n                );\n        }\n\n        /// @dev this is unitroller to be specific\n        require(\n            ComptrollerV3StorageInterface(address(comptroller)).admin() ==\n                msg.sender,\n            \"!admin\"\n        );\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked withdrawAmount <= totalAdminFees above, so this should never revert.\n        totalAdminFeesNew = sub_(totalAdminFees, withdrawAmount);\n\n        // Store adminFees[n+1] = adminFees[n] - withdrawAmount\n        totalAdminFees = totalAdminFeesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(address(uint160(msg.sender)), withdrawAmount);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel)\n        public\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /**\n     * @notice updates the interest rate model (*requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel)\n        internal\n        returns (uint256)\n    {\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK\n                );\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK\n                );\n        }\n\n        // Track the market's current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(\n            newInterestRateModel.isInterestRateModel(),\n            \"!isInterestRateModel\"\n        );\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(\n            oldInterestRateModel,\n            newInterestRateModel\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice updates the cToken ERC20 name and symbol\n     * @dev Admin function to update the cToken ERC20 name and symbol\n     * @param _name the new ERC20 token name to use\n     * @param _symbol the new ERC20 token symbol to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setNameAndSymbol(string calldata _name, string calldata _symbol)\n        external\n    {\n        // Check caller is admin\n        require(hasAdminRights(), \"!admin\");\n\n        // Set ERC20 name and symbol\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256);\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function doTransferIn(address from, uint256 amount)\n        internal\n        returns (uint256);\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function doTransferOut(address payable to, uint256 amount) internal;\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant(bool localOnly) {\n        _beforeNonReentrant(localOnly);\n        _;\n        _afterNonReentrant(localOnly);\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\n     */\n    function _beforeNonReentrant(bool localOnly) private {\n        require(_notEntered, \"re-entered\");\n        if (!localOnly) comptroller._beforeNonReentrant();\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\n     */\n    function _afterNonReentrant(bool localOnly) private {\n        _notEntered = true; // get a gas-refund post-Istanbul\n        if (!localOnly) comptroller._afterNonReentrant();\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param errorMessage The revert string to return on failure.\n     */\n    function _functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.call(data);\n\n        if (!success) {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n\n        return returndata;\n    }\n}\n"
    },
    "contracts/Exponential.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n}\n"
    },
    "contracts/EIP20NonStandardInterface.sol": {
      "content": "pragma solidity ^0.5.16;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n\n    /**\n     * @notice Get the total number of tokens in circulation\n     * @return The supply of tokens\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transfer(address dst, uint256 amount) external;\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved\n      * @return Whether or not the approval succeeded\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return The number of tokens allowed to be spent\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/EIP20Interface.sol": {
      "content": "pragma solidity ^0.5.16;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n\n    /**\n      * @notice Get the total number of tokens in circulation\n      * @return The supply of tokens\n      */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return Whether or not the transfer succeeded\n      */\n    function transfer(address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return Whether or not the transfer succeeded\n      */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved (-1 means infinite)\n      * @return Whether or not the approval succeeded\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return The number of tokens allowed to be spent (-1 means infinite)\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/ErrorReporter.sol": {
      "content": "pragma solidity ^0.5.16;\n\ncontract ComptrollerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        COMPTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED, // no longer possible\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY,\n        SUPPLIER_NOT_WHITELISTED,\n        BORROW_BELOW_MIN,\n        SUPPLY_ABOVE_MAX,\n        NONZERO_TOTAL_SUPPLY\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n        TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SET_WHITELIST_ENFORCEMENT_OWNER_CHECK,\n        SET_WHITELIST_STATUS_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\n        UNSUPPORT_MARKET_OWNER_CHECK,\n        UNSUPPORT_MARKET_DOES_NOT_EXIST,\n        UNSUPPORT_MARKET_IN_USE\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        BAD_INPUT,\n        COMPTROLLER_REJECTION,\n        COMPTROLLER_CALCULATION_ERROR,\n        INTEREST_RATE_MODEL_ERROR,\n        INVALID_ACCOUNT_PAIR,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        INVALID_COLLATERAL_FACTOR,\n        MATH_ERROR,\n        MARKET_NOT_FRESH,\n        MARKET_NOT_LISTED,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_IN_FAILED,\n        TOKEN_TRANSFER_OUT_FAILED,\n        UTILIZATION_ABOVE_MAX\n    }\n\n    /*\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n     *       This is because FailureInfo grows significantly faster, and\n     *       the order of Error has some meaning, while the order of FailureInfo\n     *       is entirely arbitrary.\n     */\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_FUSE_FEES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_ADMIN_FEES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_ACCRUE_INTEREST_FAILED,\n        BORROW_CASH_NOT_AVAILABLE,\n        BORROW_FRESHNESS_CHECK,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        BORROW_MARKET_NOT_LISTED,\n        BORROW_COMPTROLLER_REJECTION,\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        LIQUIDATE_COMPTROLLER_REJECTION,\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        LIQUIDATE_FRESHNESS_CHECK,\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_SEIZE_TOO_MUCH,\n        MINT_ACCRUE_INTEREST_FAILED,\n        MINT_COMPTROLLER_REJECTION,\n        MINT_EXCHANGE_CALCULATION_FAILED,\n        MINT_EXCHANGE_RATE_READ_FAILED,\n        MINT_FRESHNESS_CHECK,\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        MINT_TRANSFER_IN_FAILED,\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\n        NEW_UTILIZATION_RATE_ABOVE_MAX,\n        REDEEM_ACCRUE_INTEREST_FAILED,\n        REDEEM_COMPTROLLER_REJECTION,\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\n        REDEEM_FRESHNESS_CHECK,\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n        WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED,\n        WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE,\n        WITHDRAW_FUSE_FEES_FRESH_CHECK,\n        WITHDRAW_FUSE_FEES_VALIDATION,\n        WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED,\n        WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE,\n        WITHDRAW_ADMIN_FEES_FRESH_CHECK,\n        WITHDRAW_ADMIN_FEES_VALIDATION,\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n        REDUCE_RESERVES_ADMIN_CHECK,\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_RESERVES_FRESH_CHECK,\n        REDUCE_RESERVES_VALIDATION,\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_COMPTROLLER_REJECTION,\n        REPAY_BORROW_FRESHNESS_CHECK,\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COMPTROLLER_OWNER_CHECK,\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_ORACLE_MARKET_NOT_LISTED,\n        TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED,\n        SET_ADMIN_FEE_ADMIN_CHECK,\n        SET_ADMIN_FEE_FRESH_CHECK,\n        SET_ADMIN_FEE_BOUNDS_CHECK,\n        SET_FUSE_FEE_ACCRUE_INTEREST_FAILED,\n        SET_FUSE_FEE_FRESH_CHECK,\n        SET_FUSE_FEE_BOUNDS_CHECK,\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\n        SET_RESERVE_FACTOR_FRESH_CHECK,\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\n        TRANSFER_COMPTROLLER_REJECTION,\n        TRANSFER_NOT_ALLOWED,\n        TRANSFER_NOT_ENOUGH,\n        TRANSFER_TOO_MUCH,\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_RESERVES_FRESH_CHECK,\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return err == Error.COMPTROLLER_REJECTION ? 1000 + opaqueError : uint(err);\n    }\n}"
    },
    "contracts/ExponentialNoError.sol": {
      "content": "pragma solidity ^0.5.16;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint constant expScale = 1e18;\n    uint constant doubleScale = 1e36;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\n        require(n < 2**224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint a, uint b) pure internal returns (uint) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        uint c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint a, uint b) pure internal returns (uint) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) pure internal returns (uint) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Double memory b) pure internal returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) pure internal returns (uint) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n    }\n}\n"
    },
    "contracts/CarefulMath.sol": {
      "content": "pragma solidity ^0.5.16;\n\n/**\n  * @title Careful Math\n  * @author Compound\n  * @notice Derived from OpenZeppelin's SafeMath library\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n  */\ncontract CarefulMath {\n\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n    * @dev Multiplies two numbers, returns an error on overflow.\n    */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev Adds two numbers, returns an error on overflow.\n    */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev add a and b and then subtract c\n    */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}