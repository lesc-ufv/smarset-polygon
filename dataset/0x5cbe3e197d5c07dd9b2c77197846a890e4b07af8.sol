{{
  "language": "Solidity",
  "sources": {
    "contracts/tier/CombineTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {RainVM, State} from \"../vm/RainVM.sol\";\nimport {VMState, StateConfig} from \"../vm/libraries/VMState.sol\";\nimport {BlockOps} from \"../vm/ops/BlockOps.sol\";\nimport {TierOps} from \"../vm/ops/TierOps.sol\";\nimport {TierwiseCombine} from \"./libraries/TierwiseCombine.sol\";\nimport {ReadOnlyTier, ITier} from \"./ReadOnlyTier.sol\";\n\n/// @title CombineTier\n/// @notice Implements `ReadOnlyTier` over RainVM. Allows combining the reports\n/// from any other `ITier` contracts referenced in the `ImmutableSource` set at\n/// construction.\n/// The value at the top of the stack after executing the rain script will be\n/// used as the return of `report`.\ncontract CombineTier is ReadOnlyTier, RainVM, VMState, Initializable {\n    /// @dev local opcode to put tier report account on the stack.\n    uint256 private constant ACCOUNT = 0;\n    /// @dev local opcodes length.\n    uint256 internal constant LOCAL_OPS_LENGTH = 1;\n\n    /// @dev local offset for block ops.\n    uint256 private immutable blockOpsStart;\n    /// @dev local offset for tier ops.\n    uint256 private immutable tierOpsStart;\n    /// @dev local offset for combine tier ops.\n    uint256 private immutable localOpsStart;\n\n    address private vmStatePointer;\n\n    constructor() {\n        /// These local opcode offsets are calculated as immutable but are\n        /// really just compile time constants. They only depend on the\n        /// imported libraries and contracts. These are calculated at\n        /// construction to future-proof against underlying ops being\n        /// added/removed and potentially breaking the offsets here.\n        blockOpsStart = RainVM.OPS_LENGTH;\n        tierOpsStart = blockOpsStart + BlockOps.OPS_LENGTH;\n        localOpsStart = tierOpsStart + TierOps.OPS_LENGTH;\n    }\n\n    function initialize(StateConfig memory config_) external initializer {\n        vmStatePointer = _snapshot(_newState(config_));\n    }\n\n    /// @inheritdoc RainVM\n    function applyOp(\n        bytes memory context_,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view override {\n        unchecked {\n            if (opcode_ < tierOpsStart) {\n                BlockOps.applyOp(\n                    context_,\n                    state_,\n                    opcode_ - blockOpsStart,\n                    operand_\n                );\n            } else if (opcode_ < localOpsStart) {\n                TierOps.applyOp(\n                    context_,\n                    state_,\n                    opcode_ - tierOpsStart,\n                    operand_\n                );\n            } else {\n                opcode_ -= localOpsStart;\n                require(opcode_ < LOCAL_OPS_LENGTH, \"MAX_OPCODE\");\n                if (opcode_ == ACCOUNT) {\n                    address account_ = abi.decode(context_, (address));\n                    state_.stack[state_.stackIndex] = uint256(\n                        uint160(account_)\n                    );\n                    state_.stackIndex++;\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc ITier\n    function report(address account_)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        State memory state_ = _restore(vmStatePointer);\n        eval(abi.encode(account_), state_, 0);\n        return state_.stack[state_.stackIndex - 1];\n    }\n}\n"
    },
    "contracts/vm/RainVM.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\n/// Everything required to evaluate and track the state of a rain script.\n/// As this is a struct it will be in memory when passed to `RainVM` and so\n/// will be modified by reference internally. This is important for gas\n/// efficiency; the stack, arguments and stackIndex will likely be mutated by\n/// the running script.\n/// @param stackIndex Opcodes write to the stack at the stack index and can\n/// consume from the stack by decrementing the index and reading between the\n/// old and new stack index.\n/// IMPORANT: The stack is never zeroed out so the index must be used to\n/// find the \"top\" of the stack as the result of an `eval`.\n/// @param stack Stack is the general purpose runtime state that opcodes can\n/// read from and write to according to their functionality.\n/// @param sources Sources available to be executed by `eval`.\n/// Notably `ZIPMAP` can also select a source to execute by index.\n/// @param constants Constants that can be copied to the stack by index by\n/// `VAL`.\n/// @param arguments `ZIPMAP` populates arguments which can be copied to the\n/// stack by `VAL`.\nstruct State {\n    uint256 stackIndex;\n    uint256[] stack;\n    bytes[] sources;\n    uint256[] constants;\n    uint256[] arguments;\n}\n\n/// @title RainVM\n/// @notice micro VM for implementing and executing custom contract DSLs.\n/// Libraries and contracts map opcodes to `view` functionality then RainVM\n/// runs rain scripts using these opcodes. Rain scripts dispatch as pairs of\n/// bytes. The first byte is an opcode to run and the second byte is a value\n/// the opcode can use contextually to inform how to run. Typically opcodes\n/// will read/write to the stack to produce some meaningful final state after\n/// all opcodes have been dispatched.\n///\n/// The only thing required to run a rain script is a `State` struct to pass\n/// to `eval`, and the index of the source to run. Additional context can\n/// optionally be provided to be used by opcodes. For example, an `ITier`\n/// contract can take the input of `report`, abi encode it as context, then\n/// expose a local opcode that copies this account to the stack. The state will\n/// be mutated by reference rather than returned by `eval`, this is to make it\n/// very clear to implementers that the inline mutation is occurring.\n///\n/// Rain scripts run \"bottom to top\", i.e. \"right to left\"!\n/// See the tests for examples on how to construct rain script in JavaScript\n/// then pass to `ImmutableSource` contracts deployed by a factory that then\n/// run `eval` to produce a final value.\n///\n/// There are only 3 \"core\" opcodes for `RainVM`:\n/// - `0`: Skip self and optionally additional opcodes, `0 0` is a noop\n/// - `1`: Copy value from either `constants` or `arguments` at index `operand`\n///   to the top of the stack. High bit of `operand` is `0` for `constants` and\n///   `1` for `arguments`.\n/// - `2`: Zipmap takes N values from the stack, interprets each as an array of\n///   configurable length, then zips them into `arguments` and maps a source\n///   from `sources` over these. See `zipmap` for more details.\n///\n/// To do anything useful the contract that inherits `RainVM` needs to provide\n/// opcodes to build up an internal DSL. This may sound complex but it only\n/// requires mapping opcode integers to functions to call, and reading/writing\n/// values to the stack as input/output for these functions. Further, opcode\n/// packs are provided in rain that any inheriting contract can use as a normal\n/// solidity library. See `MathOps.sol` opcode pack and the\n/// `CalculatorTest.sol` test contract for an example of how to dispatch\n/// opcodes and handle the results in a wrapping contract.\n///\n/// RainVM natively has no concept of branching logic such as `if` or loops.\n/// An opcode pack could implement these similar to the core zipmap by lazily\n/// evaluating a source from `sources` based on some condition, etc. Instead\n/// some simpler, eagerly evaluated selection tools such as `min` and `max` in\n/// the `MathOps` opcode pack are provided. Future versions of `RainVM` MAY\n/// implement lazy `if` and other similar patterns.\n///\n/// The `eval` function is `view` because rain scripts are expected to compute\n/// results only without modifying any state. The contract wrapping the VM is\n/// free to mutate as usual. This model encourages exposing only read-only\n/// functionality to end-user deployers who provide scripts to a VM factory.\n/// Removing all writes remotes a lot of potential foot-guns for rain script\n/// authors and allows VM contract authors to reason more clearly about the\n/// input/output of the wrapping solidity code.\n///\n/// Internally `RainVM` makes heavy use of unchecked math and assembly logic\n/// as the opcode dispatch logic runs on a tight loop and so gas costs can ramp\n/// up very quickly. Implementing contracts and opcode packs SHOULD require\n/// that opcodes they receive do not exceed the codes they are expecting.\nabstract contract RainVM {\n    /// `0` is a skip as this is the fallback value for unset solidity bytes.\n    /// Any additional \"whitespace\" in rain scripts will be noops as `0 0` is\n    /// \"skip self\". The val can be used to skip additional opcodes but take\n    /// care to not underflow the source itself.\n    uint256 private constant OP_SKIP = 0;\n    /// `1` copies a value either off `constants` or `arguments` to the top of\n    /// the stack. The high bit of the operand specifies which, `0` for\n    /// `constants` and `1` for `arguments`.\n    uint256 private constant OP_VAL = 1;\n    /// Duplicates the top of the stack.\n    uint256 private constant OP_DUP = 2;\n    /// `2` takes N values off the stack, interprets them as an array then zips\n    /// and maps a source from `sources` over them. The source has access to\n    /// the original constants using `1 0` and to zipped arguments as `1 1`.\n    uint256 private constant OP_ZIPMAP = 3;\n    /// Number of provided opcodes for `RainVM`.\n    uint256 internal constant OPS_LENGTH = 4;\n\n    /// Zipmap is rain script's native looping construct.\n    /// N values are taken from the stack as `uint256` then split into `uintX`\n    /// values where X is configurable by `operand_`. Each 1 increment in the\n    /// operand size config doubles the number of items in the implied arrays.\n    /// For example, size 0 is 1 `uint256` value, size 1 is\n    /// `2x `uint128` values, size 2 is 4x `uint64` values and so on.\n    ///\n    /// The implied arrays are zipped and then copied into `arguments` and\n    /// mapped over with a source from `sources`. Each iteration of the mapping\n    /// copies values into `arguments` from index `0` but there is no attempt\n    /// to zero out any values that may already be in the `arguments` array.\n    /// It is the callers responsibility to ensure that the `arguments` array\n    /// is correctly sized and populated for the mapped source.\n    ///\n    /// The `operand_` for the zipmap opcode is split into 3 components:\n    /// - 2 low bits: The index of the source to use from `sources`.\n    /// - 3 middle bits: The size of the loop, where 0 is 1 iteration\n    /// - 3 high bits: The number of vals to be zipped from the stack where 0\n    ///   is 1 value to be zipped.\n    ///\n    /// This is a separate function to avoid blowing solidity compile stack.\n    /// In the future it may be moved inline to `eval` for gas efficiency.\n    ///\n    /// See https://en.wikipedia.org/wiki/Zipping_(computer_science)\n    /// See https://en.wikipedia.org/wiki/Map_(higher-order_function)\n    /// @param context_ Domain specific context the wrapping contract can\n    /// provide to passthrough back to its own opcodes.\n    /// @param state_ The execution state of the VM.\n    /// @param operand_ The operand_ associated with this dispatch to zipmap.\n    function zipmap(\n        bytes memory context_,\n        State memory state_,\n        uint256 operand_\n    ) internal view {\n        unchecked {\n            uint256 sourceIndex_;\n            uint256 stepSize_;\n            uint256 offset_;\n            uint256 valLength_;\n            // assembly here to shave some gas.\n            assembly {\n                // rightmost 3 bits are the index of the source to use from\n                // sources in `state_`.\n                sourceIndex_ := and(operand_, 0x07)\n                // bits 4 and 5 indicate size of the loop. Each 1 increment of\n                // the size halves the bits of the arguments to the zipmap.\n                // e.g. 256 `stepSize_` would copy all 256 bits of the uint256\n                // into args for the inner `eval`. A loop size of `1` would\n                // shift `stepSize_` by 1 (halving it) and meaning the uint256\n                // is `eval` as 2x 128 bit values (runs twice). A loop size of\n                // `2` would run 4 times as 64 bit values, and so on.\n                //\n                // Slither false positive here for the shift of constant `256`.\n                // slither-disable-next-line incorrect-shift\n                stepSize_ := shr(and(shr(3, operand_), 0x03), 256)\n                // `offset_` is used by the actual bit shifting operations and\n                // is precalculated here to save some gas as this is a hot\n                // performance path.\n                offset_ := sub(256, stepSize_)\n                // bits 5+ determine the number of vals to be zipped. At least\n                // one value must be provided so a `valLength_` of `0` is one\n                // value to loop over.\n                valLength_ := add(shr(5, operand_), 1)\n            }\n            state_.stackIndex -= valLength_;\n\n            uint256[] memory baseVals_ = new uint256[](valLength_);\n            for (uint256 a_ = 0; a_ < valLength_; a_++) {\n                baseVals_[a_] = state_.stack[state_.stackIndex + a_];\n            }\n\n            for (uint256 step_ = 0; step_ < 256; step_ += stepSize_) {\n                for (uint256 a_ = 0; a_ < valLength_; a_++) {\n                    state_.arguments[a_] =\n                        (baseVals_[a_] << (offset_ - step_)) >>\n                        offset_;\n                }\n                eval(context_, state_, sourceIndex_);\n            }\n        }\n    }\n\n    /// Evaluates a rain script.\n    /// The main workhorse of the rain VM, `eval` runs any core opcodes and\n    /// dispatches anything it is unaware of to the implementing contract.\n    /// For a script to be useful the implementing contract must override\n    /// `applyOp` and dispatch non-core opcodes to domain specific logic. This\n    /// could be mathematical operations for a calculator, tier reports for\n    /// a membership combinator, entitlements for a minting curve, etc.\n    ///\n    /// Everything required to coordinate the execution of a rain script to\n    /// completion is contained in the `State`. The context and source index\n    /// are provided so the caller can provide additional data and kickoff the\n    /// opcode dispatch from the correct source in `sources`.\n    function eval(\n        bytes memory context_,\n        State memory state_,\n        uint256 sourceIndex_\n    ) internal view {\n        // Everything in eval can be checked statically, there are no dynamic\n        // runtime values read from the stack that can cause out of bounds\n        // behaviour. E.g. sourceIndex in zipmap and size of a skip are both\n        // taken from the operand in the source, not the stack. A program that\n        // operates out of bounds SHOULD be flagged by static code analysis and\n        // avoided by end-users.\n        unchecked {\n            uint256 i_ = 0;\n            uint256 opcode_;\n            uint256 operand_;\n            uint256 len_;\n            uint256 sourceLocation_;\n            uint256 constantsLocation_;\n            uint256 argumentsLocation_;\n            uint256 stackLocation_;\n            assembly {\n                stackLocation_ := mload(add(state_, 0x20))\n                sourceLocation_ := mload(\n                    add(\n                        mload(add(state_, 0x40)),\n                        add(0x20, mul(sourceIndex_, 0x20))\n                    )\n                )\n                constantsLocation_ := mload(add(state_, 0x60))\n                argumentsLocation_ := mload(add(state_, 0x80))\n                len_ := mload(sourceLocation_)\n            }\n\n            // Loop until complete.\n            while (i_ < len_) {\n                assembly {\n                    i_ := add(i_, 2)\n                    let op_ := mload(add(sourceLocation_, i_))\n                    opcode_ := byte(30, op_)\n                    operand_ := byte(31, op_)\n                }\n                if (opcode_ < OPS_LENGTH) {\n                    if (opcode_ == OP_VAL) {\n                        assembly {\n                            let location_ := argumentsLocation_\n                            if iszero(and(operand_, 0x80)) {\n                                location_ := constantsLocation_\n                            }\n\n                            let stackIndex_ := mload(state_)\n                            // Copy value to stack.\n                            mstore(\n                                add(\n                                    stackLocation_,\n                                    add(0x20, mul(stackIndex_, 0x20))\n                                ),\n                                mload(\n                                    add(\n                                        location_,\n                                        add(\n                                            0x20,\n                                            mul(and(operand_, 0x7F), 0x20)\n                                        )\n                                    )\n                                )\n                            )\n                            mstore(state_, add(stackIndex_, 1))\n                        }\n                    } else if (opcode_ == OP_DUP) {\n                        assembly {\n                            let stackIndex_ := mload(state_)\n                            mstore(\n                                add(\n                                    stackLocation_,\n                                    add(0x20, mul(stackIndex_, 0x20))\n                                ),\n                                mload(\n                                    add(\n                                        stackLocation_,\n                                        add(0x20, mul(operand_, 0x20))\n                                    )\n                                )\n                            )\n                            mstore(state_, add(stackIndex_, 1))\n                        }\n                    } else if (opcode_ == OP_ZIPMAP) {\n                        zipmap(context_, state_, operand_);\n                    } else {\n                        // if the high bit of the operand is nonzero then take\n                        // the top of the stack and if it is zero we do NOT\n                        // skip.\n                        // analogous to `JUMPI` in evm opcodes.\n                        // If high bit of the operand is zero then we always\n                        // skip.\n                        // analogous to `JUMP` in evm opcodes.\n                        // the operand is interpreted as a signed integer so\n                        // that we can skip forwards or backwards. Notable\n                        // difference between skip and jump from evm is that\n                        // skip moves a relative distance from the current\n                        // position and is known at compile time, while jump\n                        // moves to an absolute position read from the stack at\n                        // runtime. The relative simplicity of skip means we\n                        // can check for out of bounds behaviour at compile\n                        // time and each source can never goto a position in a\n                        // different source.\n\n                        // manually sign extend 1 bit.\n                        // normal signextend works on bytes not bits.\n                        int8 shift_ = int8(\n                            uint8(operand_) & ((uint8(operand_) << 1) | 0x7F)\n                        );\n\n                        // if the high bit is 1...\n                        if (operand_ & 0x80 > 0) {\n                            // take the top of the stack and only skip if it is\n                            // nonzero.\n                            state_.stackIndex--;\n                            if (state_.stack[state_.stackIndex] == 0) {\n                                continue;\n                            }\n                        }\n                        if (shift_ != 0) {\n                            if (shift_ < 0) {\n                                // This is not particularly intuitive.\n                                // Converting between int and uint and then\n                                // moving `i_` back another 2 bytes to\n                                // compensate for the addition of 2 bytes at\n                                // the start of the next loop.\n                                i_ -= uint8(~shift_ + 2) * 2;\n                            } else {\n                                i_ += uint8(shift_ * 2);\n                            }\n                        }\n                    }\n                } else {\n                    applyOp(context_, state_, opcode_, operand_);\n                }\n            }\n        }\n    }\n\n    /// Every contract that implements `RainVM` should override `applyOp` so\n    /// that useful opcodes are available to script writers.\n    /// For an example of a simple and efficient `applyOp` implementation that\n    /// dispatches over several opcode packs see `CalculatorTest.sol`.\n    /// Implementing contracts are encouraged to handle the dispatch with\n    /// unchecked math as the dispatch is a critical performance path and\n    /// default solidity checked math can significantly increase gas cost for\n    /// each opcode dispatched. Consider that a single zipmap could loop over\n    /// dozens of opcode dispatches internally.\n    /// Stack is modified by reference NOT returned.\n    /// @param context_ Bytes that the implementing contract can passthrough\n    /// to be ready internally by its own opcodes. RainVM ignores the context.\n    /// @param state_ The RainVM state that tracks the execution progress.\n    /// @param opcode_ The current opcode to dispatch.\n    /// @param operand_ Additional information to inform the opcode dispatch.\n    function applyOp(\n        bytes memory context_,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view virtual {} //solhint-disable-line no-empty-blocks\n}\n"
    },
    "contracts/vm/libraries/VMState.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport {State} from \"../RainVM.sol\";\nimport \"../../sstore2/SSTORE2.sol\";\n\n/// Config required to build a new `State`.\n/// @param sources Sources verbatim.\n/// @param constants Constants verbatim.\n/// @param stackLength Sets the length of the uint256[] of the stack.\n/// @param argumentsLength Sets the length of the uint256[] of the arguments.\nstruct StateConfig {\n    bytes[] sources;\n    uint256[] constants;\n    uint256 stackLength;\n    uint256 argumentsLength;\n}\n\n/// @title StateSnapshot\n/// @notice Deploys everything required to build a fresh `State` for rainVM\n/// execution as an evm contract onchain. Uses SSTORE2 to abi encode rain\n/// script into evm bytecode, then stores an immutable pointer to the resulting\n/// contract. Allows arbitrary length rain script source, constants and stack.\n/// Gas scales for reads much better for longer data than attempting to put\n/// all the source into storage.\n/// See https://github.com/0xsequence/sstore2\ncontract VMState {\n    /// A new shapshot has been deployed onchain.\n    /// @param sender `msg.sender` of the deployer.\n    /// @param pointer Pointer to the onchain snapshot contract.\n    /// @param state `State` of the snapshot that was deployed.\n    event Snapshot(address sender, address pointer, State state);\n\n    /// Builds a new `State` from `StateConfig`.\n    /// Empty stack and arguments with stack index 0.\n    /// @param config_ State config to build the new `State`.\n    function _newState(StateConfig memory config_)\n        internal\n        pure\n        returns (State memory)\n    {\n        return\n            State(\n                0,\n                new uint256[](config_.stackLength),\n                config_.sources,\n                config_.constants,\n                new uint256[](config_.argumentsLength)\n            );\n    }\n\n    /// Snapshot a RainVM state as an immutable onchain contract.\n    /// Usually `State` will be new as per `newState` but can be a snapshot of\n    /// an \"in flight\" execution state also.\n    /// @param state_ The state to snapshot.\n    function _snapshot(State memory state_) internal returns (address) {\n        address pointer_ = SSTORE2.write(abi.encode(state_));\n        emit Snapshot(msg.sender, pointer_, state_);\n        return pointer_;\n    }\n\n    /// Builds a fresh state for rainVM execution from all construction data.\n    /// This can be passed directly to `eval` for a `RainVM` contract.\n    /// @param pointer_ The pointer (address) of the snapshot to restore.\n    function _restore(address pointer_) internal view returns (State memory) {\n        return abi.decode(SSTORE2.read(pointer_), (State));\n    }\n}\n"
    },
    "contracts/sstore2/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./utils/Bytecode.sol\";\n\n/**\n  @title A key-value storage with auto-generated keys for storing chunks of\n  data with a lower write & read cost.\n  @author Agustin Aguilar <aa@horizon.io>\n\n  Readme: https://github.com/0xsequence/sstore2#readme\n*/\nlibrary SSTORE2 {\n    error WriteError();\n\n    /**\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\n    @dev The pointer is a contract address with `_data` as code\n    @param _data to be written\n    @return pointer Pointer to the written `_data`\n  */\n    function write(bytes memory _data) internal returns (address pointer) {\n        // Append 00 to _data so contract can't be called\n        // Build init code\n        bytes memory code = Bytecode.creationCodeFor(\n            abi.encodePacked(hex\"00\", _data)\n        );\n\n        // Deploy contract using create\n        assembly {\n            pointer := create(0, add(code, 32), mload(code))\n        }\n\n        // Address MUST be non-zero\n        if (pointer == address(0)) revert WriteError();\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @return data read from `_pointer` contract\n  */\n    function read(address _pointer) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @return data read from `_pointer` contract\n  */\n    function read(address _pointer, uint256 _start)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @param _end index before which to end extraction\n    @return data read from `_pointer` contract\n  */\n    function read(\n        address _pointer,\n        uint256 _start,\n        uint256 _end\n    ) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\n    }\n}\n"
    },
    "contracts/sstore2/utils/Bytecode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nlibrary Bytecode {\n    error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\n\n    /**\n    @notice Generate a creation code that results on a contract with `_code` as\n    bytecode\n    @param _code The returning value of the resulting `creationCode`\n    @return creationCode (constructor) for new contract\n  */\n    function creationCodeFor(bytes memory _code)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        /*\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\n      0x01    0x80         0x80        DUP1                size size\n      0x02    0x60         0x600e      PUSH1 14            14 size size\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\n      0x04    0x39         0x39        CODECOPY            size\n      0x05    0x60         0x6000      PUSH1 00            0 size\n      0x06    0xf3         0xf3        RETURN\n      <CODE>\n    */\n\n        return\n            abi.encodePacked(\n                hex\"63\",\n                uint32(_code.length),\n                hex\"80_60_0E_60_00_39_60_00_F3\",\n                _code\n            );\n    }\n\n    /**\n    @notice Returns the size of the code on a given address\n    @param _addr Address that may or may not contain code\n    @return size of the code on the given `_addr`\n  */\n    function codeSize(address _addr) internal view returns (uint256 size) {\n        assembly {\n            size := extcodesize(_addr)\n        }\n    }\n\n    /**\n    @notice Returns the code of a given address\n    @dev It will fail if `_end < _start`\n    @param _addr Address that may or may not contain code\n    @param _start number of bytes of code to skip on read\n    @param _end index before which to end extraction\n    @return oCode read from `_addr` deployed bytecode\n\n    Forked: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\n  */\n    function codeAt(\n        address _addr,\n        uint256 _start,\n        uint256 _end\n    ) internal view returns (bytes memory oCode) {\n        uint256 csize = codeSize(_addr);\n        if (csize == 0) return bytes(\"\");\n\n        if (_start > csize) return bytes(\"\");\n        if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end);\n\n        unchecked {\n            uint256 reqSize = _end - _start;\n            uint256 maxSize = csize - _start;\n\n            uint256 size = maxSize < reqSize ? maxSize : reqSize;\n\n            assembly {\n                // allocate output byte array - this could also be done without\n                // assembly\n                // by using o_code = new bytes(size)\n                oCode := mload(0x40)\n                // new \"memory end\" including padding\n                mstore(\n                    0x40,\n                    add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))\n                )\n                // store length in memory\n                mstore(oCode, size)\n                // actually retrieve the code, this needs assembly\n                extcodecopy(_addr, add(oCode, 0x20), _start, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/BlockOps.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport {State} from \"../RainVM.sol\";\n\n/// @title BlockOps\n/// @notice RainVM opcode pack to access the current block number.\nlibrary BlockOps {\n    /// Opcode for the block number.\n    uint256 private constant BLOCK_NUMBER = 0;\n    /// Opcode for the block timestamp.\n    uint256 private constant BLOCK_TIMESTAMP = 1;\n    /// Number of provided opcodes for `BlockOps`.\n    uint256 internal constant OPS_LENGTH = 2;\n\n    function applyOp(\n        bytes memory,\n        State memory state_,\n        uint256 opcode_,\n        uint256\n    ) internal view {\n        unchecked {\n            require(opcode_ < OPS_LENGTH, \"MAX_OPCODE\");\n            // Stack the current `block.number`.\n            if (opcode_ == BLOCK_NUMBER) {\n                state_.stack[state_.stackIndex] = block.number;\n                state_.stackIndex++;\n            }\n            // Stack the current `block.timestamp`.\n            else if (opcode_ == BLOCK_TIMESTAMP) {\n                // solhint-disable-next-line not-rely-on-time\n                state_.stack[state_.stackIndex] = block.timestamp;\n                state_.stackIndex++;\n            }\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/TierOps.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport {State} from \"../RainVM.sol\";\nimport \"../../tier/libraries/TierReport.sol\";\nimport \"../../tier/libraries/TierwiseCombine.sol\";\n\n/// @title TierOps\n/// @notice RainVM opcode pack to operate on tier reports.\nlibrary TierOps {\n    /// Opcode to call `report` on an `ITier` contract.\n    uint256 private constant REPORT = 0;\n    /// Opcode to stack a report that has never been held for all tiers.\n    uint256 private constant NEVER = 1;\n    /// Opcode to stack a report that has always been held for all tiers.\n    uint256 private constant ALWAYS = 2;\n    /// Opcode to calculate the tierwise diff of two reports.\n    uint256 private constant SATURATING_DIFF = 3;\n    /// Opcode to update the blocks over a range of tiers for a report.\n    uint256 private constant UPDATE_BLOCKS_FOR_TIER_RANGE = 4;\n    /// Opcode to tierwise select the best block lte a reference block.\n    uint256 private constant SELECT_LTE = 5;\n    /// Number of provided opcodes for `TierOps`.\n    uint256 internal constant OPS_LENGTH = 6;\n\n    function applyOp(\n        bytes memory,\n        State memory state_,\n        uint256 opcode_,\n        uint256 operand_\n    ) internal view {\n        unchecked {\n            require(opcode_ < OPS_LENGTH, \"MAX_OPCODE\");\n            uint256 baseIndex_;\n            // Stack the report returned by an `ITier` contract.\n            // Top two stack vals are used as the address and `ITier` contract\n            // to check against.\n            if (opcode_ == REPORT) {\n                state_.stackIndex -= 1;\n                baseIndex_ = state_.stackIndex - 1;\n                state_.stack[baseIndex_] = ITier(\n                    address(uint160(state_.stack[baseIndex_]))\n                ).report(address(uint160(state_.stack[baseIndex_ + 1])));\n            }\n            // Stack a report that has never been held at any tier.\n            else if (opcode_ == NEVER) {\n                state_.stack[state_.stackIndex] = TierConstants.NEVER_REPORT;\n                state_.stackIndex++;\n            }\n            // Stack a report that has always been held at every tier.\n            else if (opcode_ == ALWAYS) {\n                state_.stack[state_.stackIndex] = TierConstants.ALWAYS;\n                state_.stackIndex++;\n            }\n            // Stack the tierwise saturating subtraction of two reports.\n            // If the older report is newer than newer report the result will\n            // be `0`, else a tierwise diff in blocks will be obtained.\n            // The older and newer report are taken from the stack.\n            else if (opcode_ == SATURATING_DIFF) {\n                state_.stackIndex -= 2;\n                baseIndex_ = state_.stackIndex;\n                uint256 newerReport_ = state_.stack[baseIndex_];\n                uint256 olderReport_ = state_.stack[baseIndex_ + 1];\n                state_.stack[baseIndex_] = TierwiseCombine.saturatingSub(\n                    newerReport_,\n                    olderReport_\n                );\n                state_.stackIndex++;\n            }\n            // Stacks a report with updated blocks over tier range.\n            // The start and end tier are taken from the low and high bits of\n            // the `operand_` respectively.\n            // The block number to update to and the report to update over are\n            // both taken from the stack.\n            else if (opcode_ == UPDATE_BLOCKS_FOR_TIER_RANGE) {\n                uint256 startTier_ = operand_ & 0x0f; // & 00001111\n                uint256 endTier_ = (operand_ >> 4) & 0x0f; // & 00001111\n                state_.stackIndex -= 2;\n                baseIndex_ = state_.stackIndex;\n                uint256 report_ = state_.stack[baseIndex_];\n                uint256 blockNumber_ = state_.stack[baseIndex_ + 1];\n                state_.stack[baseIndex_] = TierReport.updateBlocksForTierRange(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    blockNumber_\n                );\n                state_.stackIndex++;\n            }\n            // Stacks the result of a `selectLte` combinator.\n            // All `selectLte` share the same stack and argument handling.\n            // In the future these may be combined into a single opcode, taking\n            // the `logic_` and `mode_` from the `operand_` high bits.\n            else if (opcode_ == SELECT_LTE) {\n                uint256 logic_ = operand_ >> 7;\n                uint256 mode_ = (operand_ >> 5) & 0x3; // & 00000011\n                uint256 reportsLength_ = operand_ & 0x1F; // & 00011111\n\n                // Need one more than reports length to include block number.\n                state_.stackIndex -= reportsLength_ + 1;\n                baseIndex_ = state_.stackIndex;\n                uint256 cursor_ = baseIndex_;\n\n                uint256[] memory reports_ = new uint256[](reportsLength_);\n                for (uint256 a_ = 0; a_ < reportsLength_; a_++) {\n                    reports_[a_] = state_.stack[cursor_];\n                    cursor_++;\n                }\n                uint256 blockNumber_ = state_.stack[cursor_];\n\n                state_.stack[baseIndex_] = TierwiseCombine.selectLte(\n                    reports_,\n                    blockNumber_,\n                    logic_,\n                    mode_\n                );\n                state_.stackIndex++;\n            }\n        }\n    }\n}\n"
    },
    "contracts/tier/libraries/TierReport.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport {ITier} from \"../ITier.sol\";\nimport \"./TierConstants.sol\";\n\n/// @title TierReport\n/// @notice `TierReport` implements several pure functions that can be\n/// used to interface with reports.\n/// - `tierAtBlockFromReport`: Returns the highest status achieved relative to\n/// a block number and report. Statuses gained after that block are ignored.\n/// - `tierBlock`: Returns the block that a given tier has been held\n/// since according to a report.\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\n/// - `updateBlocksForTierRange`: Updates a report with a block\n/// number for every tier in a range.\n/// - `updateReportWithTierAtBlock`: Updates a report to a new tier.\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\n/// The low-level bit shifting can be difficult to get right so this\n/// factors that out.\nlibrary TierReport {\n    /// Enforce upper limit on tiers so we can do unchecked math.\n    modifier maxTier(uint256 tier_) {\n        require(tier_ <= TierConstants.MAX_TIER, \"MAX_TIER\");\n        _;\n    }\n\n    /// Returns the highest tier achieved relative to a block number\n    /// and report.\n    ///\n    /// Note that typically the report will be from the _current_ contract\n    /// state, i.e. `block.number` but not always. Tiers gained after the\n    /// reference block are ignored.\n    ///\n    /// When the `report` comes from a later block than the `blockNumber` this\n    /// means the user must have held the tier continuously from `blockNumber`\n    /// _through_ to the report block.\n    /// I.e. NOT a snapshot.\n    ///\n    /// @param report_ A report as per `ITier`.\n    /// @param blockNumber_ The block number to check the tiers against.\n    /// @return The highest tier held since `blockNumber` as per `report`.\n    function tierAtBlockFromReport(uint256 report_, uint256 blockNumber_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            for (uint256 i_ = 0; i_ < 8; i_++) {\n                if (uint32(uint256(report_ >> (i_ * 32))) > blockNumber_) {\n                    return i_;\n                }\n            }\n            return TierConstants.MAX_TIER;\n        }\n    }\n\n    /// Returns the block that a given tier has been held since from a report.\n    ///\n    /// The report MUST encode \"never\" as 0xFFFFFFFF. This ensures\n    /// compatibility with `tierAtBlockFromReport`.\n    ///\n    /// @param report_ The report to read a block number from.\n    /// @param tier_ The Tier to read the block number for.\n    /// @return The block number this has been held since.\n    function tierBlock(uint256 report_, uint256 tier_)\n        internal\n        pure\n        maxTier(tier_)\n        returns (uint256)\n    {\n        unchecked {\n            // ZERO is a special case. Everyone has always been at least ZERO,\n            // since block 0.\n            if (tier_ == 0) {\n                return 0;\n            }\n\n            uint256 offset_ = (tier_ - 1) * 32;\n            return uint256(uint32(uint256(report_ >> offset_)));\n        }\n    }\n\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\n    ///\n    /// @param report_ Report to truncate with high bit 1s.\n    /// @param tier_ Tier to truncate above (exclusive).\n    /// @return Truncated report.\n    function truncateTiersAbove(uint256 report_, uint256 tier_)\n        internal\n        pure\n        maxTier(tier_)\n        returns (uint256)\n    {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\n            return report_ | mask_;\n        }\n    }\n\n    /// Updates a report with a block number for a given tier.\n    /// More gas efficient than `updateBlocksForTierRange` if only a single\n    /// tier is being modified.\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\n    /// the block for tier `1`.\n    function updateBlockAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 blockNumber_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            return\n                (report_ &\n                    ~uint256(uint256(TierConstants.NEVER_TIER) << offset_)) |\n                uint256(blockNumber_ << offset_);\n        }\n    }\n\n    /// Updates a report with a block number for every tier in a range.\n    ///\n    /// Does nothing if the end status is equal or less than the start tier.\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier at the start of the range (exclusive).\n    /// @param endTier_ The tier at the end of the range (inclusive).\n    /// @param blockNumber_ The block number to set for every tier in the\n    /// range.\n    /// @return The updated report.\n    function updateBlocksForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 blockNumber_\n    ) internal pure maxTier(startTier_) maxTier(endTier_) returns (uint256) {\n        unchecked {\n            uint256 offset_;\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\n                offset_ = i_ * 32;\n                report_ =\n                    (report_ &\n                        ~uint256(\n                            uint256(TierConstants.NEVER_TIER) << offset_\n                        )) |\n                    uint256(blockNumber_ << offset_);\n            }\n            return report_;\n        }\n    }\n\n    /// Updates a report to a new status.\n    ///\n    /// Internally dispatches to `truncateTiersAbove` and\n    /// `updateBlocksForTierRange`.\n    /// The dispatch is based on whether the new tier is above or below the\n    /// current tier.\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\n    /// It is expected the caller will know the current tier when\n    /// calling this function and need to do other things in the calling scope\n    /// with it.\n    ///\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier to start updating relative to. Data above\n    /// this tier WILL BE LOST so probably should be the current tier.\n    /// @param endTier_ The new highest tier held, at the given block number.\n    /// @param blockNumber_ The block number to update the highest tier to, and\n    /// intermediate tiers from `startTier_`.\n    /// @return The updated report.\n    function updateReportWithTierAtBlock(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 blockNumber_\n    ) internal pure returns (uint256) {\n        return\n            endTier_ < startTier_\n                ? truncateTiersAbove(report_, endTier_)\n                : updateBlocksForTierRange(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    blockNumber_\n                );\n    }\n}\n"
    },
    "contracts/tier/ITier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\n/// @title ITier\n/// @notice `ITier` is a simple interface that contracts can\n/// implement to provide membership lists for other contracts.\n///\n/// There are many use-cases for a time-preserving conditional membership list.\n///\n/// Some examples include:\n///\n/// - Self-serve whitelist to participate in fundraising\n/// - Lists of users who can claim airdrops and perks\n/// - Pooling resources with implied governance/reward tiers\n/// - POAP style attendance proofs allowing access to future exclusive events\n///\n/// @dev Standard interface to a tiered membership.\n///\n/// A \"membership\" can represent many things:\n/// - Exclusive access.\n/// - Participation in some event or process.\n/// - KYC completion.\n/// - Combination of sub-memberships.\n/// - Etc.\n///\n/// The high level requirements for a contract implementing `ITier`:\n/// - MUST represent held tiers as a `uint`.\n/// - MUST implement `report`.\n///   - The report is a `uint256` that SHOULD represent the block each tier has\n///     been continuously held since encoded as `uint32`.\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\n///     been held.\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\n///   - If a tier is lost the block data is erased for that tier and will be\n///     set if/when the tier is regained to the new block.\n///   - If the historical block information is not available the report MAY\n///     return `0x00000000` for all held tiers.\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\n/// - SHOULD implement `setTier`.\n///   - Contracts SHOULD revert with `SET_TIER` error if they cannot\n///     meaningfully set a tier directly.\n///     For example a contract that can only derive a membership tier by\n///     reading the state of an external contract cannot set tiers.\n///   - Contracts implementing `setTier` SHOULD error with `SET_ZERO_TIER`\n///     if tier 0 is being set.\n/// - MUST emit `TierChange` when `setTier` successfully writes a new tier.\n///   - Contracts that cannot meaningfully set a tier are exempt.\ninterface ITier {\n    /// Every time a tier changes we log start and end tier against the\n    /// account.\n    /// This MAY NOT be emitted if reports are being read from the state of an\n    /// external contract.\n    /// The start tier MAY be lower than the current tier as at the block this\n    /// event is emitted in.\n    /// @param sender The `msg.sender` that authorized the tier change.\n    /// @param account The account changing tier.\n    /// @param startTier The previous tier the account held.\n    /// @param endTier The newly acquired tier the account now holds.\n    event TierChange(\n        address sender,\n        address account,\n        uint256 startTier,\n        uint256 endTier\n    );\n\n    /// @notice Users can set their own tier by calling `setTier`.\n    ///\n    /// The contract that implements `ITier` is responsible for checking\n    /// eligibility and/or taking actions required to set the tier.\n    ///\n    /// For example, the contract must take/refund any tokens relevant to\n    /// changing the tier.\n    ///\n    /// Obviously the user is responsible for any approvals for this action\n    /// prior to calling `setTier`.\n    ///\n    /// When the tier is changed a `TierChange` event will be emmited as:\n    /// ```\n    /// event TierChange(address account, uint startTier, uint endTier);\n    /// ```\n    ///\n    /// The `setTier` function includes arbitrary data as the third\n    /// parameter. This can be used to disambiguate in the case that\n    /// there may be many possible options for a user to achieve some tier.\n    ///\n    /// For example, consider the case where tier 3 can be achieved\n    /// by EITHER locking 1x rare NFT or 3x uncommon NFTs. A user with both\n    /// could use `data` to explicitly state their intent.\n    ///\n    /// NOTE however that _any_ address can call `setTier` for any other\n    /// address.\n    ///\n    /// If you implement `data` or anything that changes state then be very\n    /// careful to avoid griefing attacks.\n    ///\n    /// The `data` parameter can also be ignored by the contract implementing\n    /// `ITier`. For example, ERC20 tokens are fungible so only the balance\n    /// approved by the user is relevant to a tier change.\n    ///\n    /// The `setTier` function SHOULD prevent users from reassigning\n    /// tier 0 to themselves.\n    ///\n    /// The tier 0 status represents never having any status.\n    /// @dev Updates the tier of an account.\n    ///\n    /// The implementing contract is responsible for all checks and state\n    /// changes required to set the tier. For example, taking/refunding\n    /// funds/NFTs etc.\n    ///\n    /// Contracts may disallow directly setting tiers, preferring to derive\n    /// reports from other onchain data.\n    /// In this case they should `revert(\"SET_TIER\");`.\n    ///\n    /// @param account Account to change the tier for.\n    /// @param endTier Tier after the change.\n    /// @param data Arbitrary input to disambiguate ownership\n    /// (e.g. NFTs to lock).\n    function setTier(\n        address account,\n        uint256 endTier,\n        bytes memory data\n    ) external;\n\n    /// @notice A tier report is a `uint256` that contains each of the block\n    /// numbers each tier has been held continously since as a `uint32`.\n    /// There are 9 possible tier, starting with tier 0 for `0` offset or\n    /// \"never held any tier\" then working up through 8x 4 byte offsets to the\n    /// full 256 bits.\n    ///\n    /// Low bits = Lower tier.\n    ///\n    /// In hexadecimal every 8 characters = one tier, starting at tier 8\n    /// from high bits and working down to tier 1.\n    ///\n    /// `uint32` should be plenty for any blockchain that measures block times\n    /// in seconds, but reconsider if deploying to an environment with\n    /// significantly sub-second block times.\n    ///\n    /// ~135 years of 1 second blocks fit into `uint32`.\n    ///\n    /// `2^8 / (365 * 24 * 60 * 60)`\n    ///\n    /// When a user INCREASES their tier they keep all the block numbers they\n    /// already had, and get new block times for each increased tiers they have\n    /// earned.\n    ///\n    /// When a user DECREASES their tier they return to `0xFFFFFFFF` (never)\n    /// for every tier level they remove, but keep their block numbers for the\n    /// remaining tiers.\n    ///\n    /// GUIs are encouraged to make this dynamic very clear for users as\n    /// round-tripping to a lower status and back is a DESTRUCTIVE operation\n    /// for block times.\n    ///\n    /// The intent is that downstream code can provide additional benefits for\n    /// members who have maintained a certain tier for/since a long time.\n    /// These benefits can be provided by inspecting the report, and by\n    /// on-chain contracts directly,\n    /// rather than needing to work with snapshots etc.\n    /// @dev Returns the earliest block the account has held each tier for\n    /// continuously.\n    /// This is encoded as a uint256 with blocks represented as 8x\n    /// concatenated uint32.\n    /// I.e. Each 4 bytes of the uint256 represents a u32 tier start time.\n    /// The low bits represent low tiers and high bits the high tiers.\n    /// Implementing contracts should return 0xFFFFFFFF for lost and\n    /// never-held tiers.\n    ///\n    /// @param account Account to get the report for.\n    /// @return The report blocks encoded as a uint256.\n    function report(address account) external view returns (uint256);\n}\n"
    },
    "contracts/tier/libraries/TierConstants.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\n/// @title TierConstants\n/// @notice Constants for use with tier logic.\nlibrary TierConstants {\n    /// NEVER is 0xFF.. as it is infinitely in the future.\n    /// NEVER for an entire report.\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\n    /// NEVER for a single tier.\n    uint32 internal constant NEVER_TIER = type(uint32).max;\n\n    /// Always is 0 as it is the genesis block.\n    /// Tiers can't predate the chain but they can predate an `ITier` contract.\n    uint256 internal constant ALWAYS = 0;\n\n    /// Account has never held a tier.\n    uint256 internal constant TIER_ZERO = 0;\n\n    /// Magic number for tier one.\n    uint256 internal constant TIER_ONE = 1;\n    /// Magic number for tier two.\n    uint256 internal constant TIER_TWO = 2;\n    /// Magic number for tier three.\n    uint256 internal constant TIER_THREE = 3;\n    /// Magic number for tier four.\n    uint256 internal constant TIER_FOUR = 4;\n    /// Magic number for tier five.\n    uint256 internal constant TIER_FIVE = 5;\n    /// Magic number for tier six.\n    uint256 internal constant TIER_SIX = 6;\n    /// Magic number for tier seven.\n    uint256 internal constant TIER_SEVEN = 7;\n    /// Magic number for tier eight.\n    uint256 internal constant TIER_EIGHT = 8;\n    /// Maximum tier is `TIER_EIGHT`.\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\n}\n"
    },
    "contracts/tier/libraries/TierwiseCombine.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./TierReport.sol\";\nimport \"../../math/SaturatingMath.sol\";\n\nlibrary TierwiseCombine {\n    using Math for uint256;\n    using SaturatingMath for uint256;\n\n    /// Every lte check in `selectLte` must pass.\n    uint256 internal constant LOGIC_EVERY = 0;\n    /// Only one lte check in `selectLte` must pass.\n    uint256 internal constant LOGIC_ANY = 1;\n\n    /// Select the minimum block number from passing blocks in `selectLte`.\n    uint256 internal constant MODE_MIN = 0;\n    /// Select the maximum block number from passing blocks in `selectLte`.\n    uint256 internal constant MODE_MAX = 1;\n    /// Select the first block number that passes in `selectLte`.\n    uint256 internal constant MODE_FIRST = 2;\n\n    /// Performs a tierwise saturating subtraction of two reports.\n    /// Intepret as \"# of blocks older report was held before newer report\".\n    /// If older report is in fact newer then `0` will be returned.\n    /// i.e. the diff cannot be negative, older report as simply spent 0 blocks\n    /// existing before newer report, if it is in truth the newer report.\n    /// @param newerReport_ Block to subtract from.\n    /// @param olderReport_ Block to subtract.\n    function saturatingSub(uint256 newerReport_, uint256 olderReport_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 ret_;\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\n                uint256 newerBlock_ = TierReport.tierBlock(newerReport_, tier_);\n                uint256 olderBlock_ = TierReport.tierBlock(olderReport_, tier_);\n                uint256 diff_ = newerBlock_.saturatingSub(olderBlock_);\n                ret_ = TierReport.updateBlockAtTier(ret_, tier_ - 1, diff_);\n            }\n            return ret_;\n        }\n    }\n\n    /// Given a list of reports, selects the best tier in a tierwise fashion.\n    /// The \"best\" criteria can be configured by `logic_` and `mode_`.\n    /// Logic can be \"every\" or \"any\", which means that the reports for a given\n    /// tier must either all or any be less than or equal to the reference\n    /// `blockNumber_`.\n    /// Mode can be \"min\", \"max\", \"first\" which selects between all the block\n    /// numbers for a given tier that meet the lte criteria.\n    /// @param reports_ The list of reports to select over.\n    /// @param blockNumber_ The block number that tier blocks must be lte.\n    /// @param logic_ `LOGIC_EVERY` or `LOGIC_ANY`.\n    /// @param mode_ `MODE_MIN`, `MODE_MAX` or `MODE_FIRST`.\n    function selectLte(\n        uint256[] memory reports_,\n        uint256 blockNumber_,\n        uint256 logic_,\n        uint256 mode_\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 ret_;\n            uint256 block_;\n            bool anyLte_;\n            uint256 length_ = reports_.length;\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\n                uint256 accumulator_;\n                // Nothing lte the reference block for this tier yet.\n                anyLte_ = false;\n\n                // Initialize the accumulator for this tier.\n                if (mode_ == MODE_MIN) {\n                    accumulator_ = TierConstants.NEVER_REPORT;\n                } else {\n                    accumulator_ = 0;\n                }\n\n                // Filter all the blocks at the current tier from all the\n                // reports against the reference tier and each other.\n                for (uint256 i_ = 0; i_ < length_; i_++) {\n                    block_ = TierReport.tierBlock(reports_[i_], tier_);\n\n                    if (block_ <= blockNumber_) {\n                        // Min and max need to compare current value against\n                        // the accumulator.\n                        if (mode_ == MODE_MIN) {\n                            accumulator_ = block_.min(accumulator_);\n                        } else if (mode_ == MODE_MAX) {\n                            accumulator_ = block_.max(accumulator_);\n                        } else if (mode_ == MODE_FIRST && !anyLte_) {\n                            accumulator_ = block_;\n                        }\n                        anyLte_ = true;\n                    } else if (logic_ == LOGIC_EVERY) {\n                        // Can short circuit for an \"every\" check.\n                        accumulator_ = TierConstants.NEVER_REPORT;\n                        break;\n                    }\n                }\n                if (!anyLte_) {\n                    accumulator_ = TierConstants.NEVER_REPORT;\n                }\n                ret_ = TierReport.updateBlockAtTier(\n                    ret_,\n                    tier_ - 1,\n                    accumulator_\n                );\n            }\n            return ret_;\n        }\n    }\n}\n"
    },
    "contracts/math/SaturatingMath.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\n/// @title SaturatingMath\n/// @notice Sometimes we neither want math operations to error nor wrap around\n/// on an overflow or underflow. In the case of transferring assets an error\n/// may cause assets to be locked in an irretrievable state within the erroring\n/// contract, e.g. due to a tiny rounding/calculation error. We also can't have\n/// assets underflowing and attempting to approve/transfer \"infinity\" when we\n/// wanted \"almost or exactly zero\" but some calculation bug underflowed zero.\n/// Ideally there are no calculation mistakes, but in guarding against bugs it\n/// may be safer pragmatically to saturate arithmatic at the numeric bounds.\n/// Note that saturating div is not supported because 0/0 is undefined.\nlibrary SaturatingMath {\n    /// Saturating addition.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ + b_ and max uint256.\n    function saturatingAdd(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 c_ = a_ + b_;\n            return c_ < a_ ? type(uint256).max : c_;\n        }\n    }\n\n    /// Saturating subtraction.\n    /// @param a_ Minuend.\n    /// @param b_ Subtrahend.\n    /// @return a_ - b_ if a_ greater than b_, else 0.\n    function saturatingSub(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return a_ > b_ ? a_ - b_ : 0;\n        }\n    }\n\n    /// Saturating multiplication.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ * b_ and max uint256.\n    function saturatingMul(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being\n            // zero, but the benefit is lost if 'b' is also tested.\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a_ == 0) return 0;\n            uint256 c_ = a_ * b_;\n            return c_ / a_ != b_ ? type(uint256).max : c_;\n        }\n    }\n}\n"
    },
    "contracts/tier/ReadOnlyTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport {ITier} from \"./ITier.sol\";\nimport {TierReport} from \"./libraries/TierReport.sol\";\n\n/// @title ReadOnlyTier\n/// @notice `ReadOnlyTier` is a base contract that other contracts\n/// are expected to inherit.\n///\n/// It does not allow `setStatus` and expects `report` to derive from\n/// some existing onchain data.\n///\n/// @dev A contract inheriting `ReadOnlyTier` cannot call `setTier`.\n///\n/// `ReadOnlyTier` is abstract because it does not implement `report`.\n/// The expectation is that `report` will derive tiers from some\n/// external data source.\nabstract contract ReadOnlyTier is ITier {\n    /// Always reverts because it is not possible to set a read only tier.\n    /// @inheritdoc ITier\n    function setTier(\n        address,\n        uint256,\n        bytes memory\n    ) external pure override {\n        revert(\"SET_TIER\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}