{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IProtocolGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./utils/IDefaultAccessControl.sol\";\nimport \"./IUnitPricesGovernance.sol\";\n\ninterface IProtocolGovernance is IDefaultAccessControl, IUnitPricesGovernance {\n    /// @notice CommonLibrary protocol params.\n    /// @param maxTokensPerVault Max different token addresses that could be managed by the vault\n    /// @param governanceDelay The delay (in secs) that must pass before setting new pending params to commiting them\n    /// @param protocolTreasury The address that collects protocolFees, if protocolFee is not zero\n    /// @param forceAllowMask If a permission bit is set in this mask it forces all addresses to have this permission as true\n    /// @param withdrawLimit Withdraw limit (in unit prices, i.e. usd)\n    struct Params {\n        uint256 maxTokensPerVault;\n        uint256 governanceDelay;\n        address protocolTreasury;\n        uint256 forceAllowMask;\n        uint256 withdrawLimit;\n    }\n\n    // -------------------  EXTERNAL, VIEW  -------------------\n\n    /// @notice Timestamp after which staged granted permissions for the given address can be committed.\n    /// @param target The given address\n    /// @return Zero if there are no staged permission grants, timestamp otherwise\n    function stagedPermissionGrantsTimestamps(address target) external view returns (uint256);\n\n    /// @notice Staged granted permission bitmask for the given address.\n    /// @param target The given address\n    /// @return Bitmask\n    function stagedPermissionGrantsMasks(address target) external view returns (uint256);\n\n    /// @notice Permission bitmask for the given address.\n    /// @param target The given address\n    /// @return Bitmask\n    function permissionMasks(address target) external view returns (uint256);\n\n    /// @notice Timestamp after which staged pending protocol parameters can be committed\n    /// @return Zero if there are no staged parameters, timestamp otherwise.\n    function stagedParamsTimestamp() external view returns (uint256);\n\n    /// @notice Staged pending protocol parameters.\n    function stagedParams() external view returns (Params memory);\n\n    /// @notice Current protocol parameters.\n    function params() external view returns (Params memory);\n\n    /// @notice Addresses for which non-zero permissions are set.\n    function permissionAddresses() external view returns (address[] memory);\n\n    /// @notice Permission addresses staged for commit.\n    function stagedPermissionGrantsAddresses() external view returns (address[] memory);\n\n    /// @notice Return all addresses where rawPermissionMask bit for permissionId is set to 1.\n    /// @param permissionId Id of the permission to check.\n    /// @return A list of dirty addresses.\n    function addressesByPermission(uint8 permissionId) external view returns (address[] memory);\n\n    /// @notice Checks if address has permission or given permission is force allowed for any address.\n    /// @param addr Address to check\n    /// @param permissionId Permission to check\n    function hasPermission(address addr, uint8 permissionId) external view returns (bool);\n\n    /// @notice Checks if address has all permissions.\n    /// @param target Address to check\n    /// @param permissionIds A list of permissions to check\n    function hasAllPermissions(address target, uint8[] calldata permissionIds) external view returns (bool);\n\n    /// @notice Max different ERC20 token addresses that could be managed by the protocol.\n    function maxTokensPerVault() external view returns (uint256);\n\n    /// @notice The delay for committing any governance params.\n    function governanceDelay() external view returns (uint256);\n\n    /// @notice The address of the protocol treasury.\n    function protocolTreasury() external view returns (address);\n\n    /// @notice Permissions mask which defines if ordinary permission should be reverted.\n    /// This bitmask is xored with ordinary mask.\n    function forceAllowMask() external view returns (uint256);\n\n    /// @notice Withdraw limit per token per block.\n    /// @param token Address of the token\n    /// @return Withdraw limit per token per block\n    function withdrawLimit(address token) external view returns (uint256);\n\n    /// @notice Addresses that has staged validators.\n    function stagedValidatorsAddresses() external view returns (address[] memory);\n\n    /// @notice Timestamp after which staged granted permissions for the given address can be committed.\n    /// @param target The given address\n    /// @return Zero if there are no staged permission grants, timestamp otherwise\n    function stagedValidatorsTimestamps(address target) external view returns (uint256);\n\n    /// @notice Staged validator for the given address.\n    /// @param target The given address\n    /// @return Validator\n    function stagedValidators(address target) external view returns (address);\n\n    /// @notice Addresses that has validators.\n    function validatorsAddresses() external view returns (address[] memory);\n\n    /// @notice Address that has validators.\n    /// @param i The number of address\n    /// @return Validator address\n    function validatorsAddress(uint256 i) external view returns (address);\n\n    /// @notice Validator for the given address.\n    /// @param target The given address\n    /// @return Validator\n    function validators(address target) external view returns (address);\n\n    // -------------------  EXTERNAL, MUTATING, GOVERNANCE, IMMEDIATE  -------------------\n\n    /// @notice Rollback all staged validators.\n    function rollbackStagedValidators() external;\n\n    /// @notice Revoke validator instantly from the given address.\n    /// @param target The given address\n    function revokeValidator(address target) external;\n\n    /// @notice Stages a new validator for the given address\n    /// @param target The given address\n    /// @param validator The validator for the given address\n    function stageValidator(address target, address validator) external;\n\n    /// @notice Commits validator for the given address.\n    /// @dev Reverts if governance delay has not passed yet.\n    /// @param target The given address.\n    function commitValidator(address target) external;\n\n    /// @notice Commites all staged validators for which governance delay passed\n    /// @return Addresses for which validators were committed\n    function commitAllValidatorsSurpassedDelay() external returns (address[] memory);\n\n    /// @notice Rollback all staged granted permission grant.\n    function rollbackStagedPermissionGrants() external;\n\n    /// @notice Commits permission grants for the given address.\n    /// @dev Reverts if governance delay has not passed yet.\n    /// @param target The given address.\n    function commitPermissionGrants(address target) external;\n\n    /// @notice Commites all staged permission grants for which governance delay passed.\n    /// @return An array of addresses for which permission grants were committed.\n    function commitAllPermissionGrantsSurpassedDelay() external returns (address[] memory);\n\n    /// @notice Revoke permission instantly from the given address.\n    /// @param target The given address.\n    /// @param permissionIds A list of permission ids to revoke.\n    function revokePermissions(address target, uint8[] memory permissionIds) external;\n\n    /// @notice Commits staged protocol params.\n    /// Reverts if governance delay has not passed yet.\n    function commitParams() external;\n\n    // -------------------  EXTERNAL, MUTATING, GOVERNANCE, DELAY  -------------------\n\n    /// @notice Sets new pending params that could have been committed after governance delay expires.\n    /// @param newParams New protocol parameters to set.\n    function stageParams(Params memory newParams) external;\n\n    /// @notice Stage granted permissions that could have been committed after governance delay expires.\n    /// Resets commit delay and permissions if there are already staged permissions for this address.\n    /// @param target Target address\n    /// @param permissionIds A list of permission ids to grant\n    function stagePermissionGrants(address target, uint8[] memory permissionIds) external;\n}\n"
    },
    "contracts/interfaces/IUnitPricesGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"./utils/IDefaultAccessControl.sol\";\n\ninterface IUnitPricesGovernance is IDefaultAccessControl, IERC165 {\n    // -------------------  EXTERNAL, VIEW  -------------------\n\n    /// @notice Estimated amount of token worth 1 USD staged for commit.\n    /// @param token Address of the token\n    /// @return The amount of token\n    function stagedUnitPrices(address token) external view returns (uint256);\n\n    /// @notice Timestamp after which staged unit prices for the given token can be committed.\n    /// @param token Address of the token\n    /// @return Timestamp\n    function stagedUnitPricesTimestamps(address token) external view returns (uint256);\n\n    /// @notice Estimated amount of token worth 1 USD.\n    /// @param token Address of the token\n    /// @return The amount of token\n    function unitPrices(address token) external view returns (uint256);\n\n    // -------------------  EXTERNAL, MUTATING  -------------------\n\n    /// @notice Stage estimated amount of token worth 1 USD staged for commit.\n    /// @param token Address of the token\n    /// @param value The amount of token\n    function stageUnitPrice(address token, uint256 value) external;\n\n    /// @notice Reset staged value\n    /// @param token Address of the token\n    function rollbackUnitPrice(address token) external;\n\n    /// @notice Commit staged unit price\n    /// @param token Address of the token\n    function commitUnitPrice(address token) external;\n}\n"
    },
    "contracts/interfaces/IVaultRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"./IProtocolGovernance.sol\";\n\ninterface IVaultRegistry is IERC721 {\n    /// @notice Get Vault for the giver NFT ID.\n    /// @param nftId NFT ID\n    /// @return vault Address of the Vault contract\n    function vaultForNft(uint256 nftId) external view returns (address vault);\n\n    /// @notice Get NFT ID for given Vault contract address.\n    /// @param vault Address of the Vault contract\n    /// @return nftId NFT ID\n    function nftForVault(address vault) external view returns (uint256 nftId);\n\n    /// @notice Checks if the nft is locked for all transfers\n    /// @param nft NFT to check for lock\n    /// @return `true` if locked, false otherwise\n    function isLocked(uint256 nft) external view returns (bool);\n\n    /// @notice Register new Vault and mint NFT.\n    /// @param vault address of the vault\n    /// @param owner owner of the NFT\n    /// @return nft Nft minted for the given Vault\n    function registerVault(address vault, address owner) external returns (uint256 nft);\n\n    /// @notice Number of Vaults registered.\n    function vaultsCount() external view returns (uint256);\n\n    /// @notice All Vaults registered.\n    function vaults() external view returns (address[] memory);\n\n    /// @notice Address of the ProtocolGovernance.\n    function protocolGovernance() external view returns (IProtocolGovernance);\n\n    /// @notice Address of the staged ProtocolGovernance.\n    function stagedProtocolGovernance() external view returns (IProtocolGovernance);\n\n    /// @notice Minimal timestamp when staged ProtocolGovernance can be applied.\n    function stagedProtocolGovernanceTimestamp() external view returns (uint256);\n\n    /// @notice Stage new ProtocolGovernance.\n    /// @param newProtocolGovernance new ProtocolGovernance\n    function stageProtocolGovernance(IProtocolGovernance newProtocolGovernance) external;\n\n    /// @notice Commit new ProtocolGovernance.\n    function commitStagedProtocolGovernance() external;\n\n    /// @notice Approve nft to new address\n    /// @dev This can be called only by the Protocol Governance. It is used to disable the strategy for a vault\n    /// @param newAddress address that will be approved\n    /// @param nft for re-approval\n    function adminApprove(address newAddress, uint256 nft) external;\n\n    /// @notice Lock NFT for transfers\n    /// @dev Use this method when vault structure is set up and should become immutable. Can be called by owner.\n    /// @param nft - NFT to lock\n    function lockNft(uint256 nft) external;\n}\n"
    },
    "contracts/interfaces/external/univ3/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/external/univ3/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.9;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "contracts/interfaces/utils/IContractMeta.sol": {
      "content": "// SPDX-License-Identifier: BSL-1.1\npragma solidity 0.8.9;\n\ninterface IContractMeta {\n    function contractName() external view returns (string memory);\n    function contractNameBytes() external view returns (bytes32);\n\n    function contractVersion() external view returns (string memory);\n    function contractVersionBytes() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/utils/IDefaultAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/IAccessControlEnumerable.sol\";\n\ninterface IDefaultAccessControl is IAccessControlEnumerable {\n    /// @notice Checks that the address is contract admin.\n    /// @param who Address to check\n    /// @return `true` if who is admin, `false` otherwise\n    function isAdmin(address who) external view returns (bool);\n\n    /// @notice Checks that the address is contract admin.\n    /// @param who Address to check\n    /// @return `true` if who is operator, `false` otherwise\n    function isOperator(address who) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/validators/IBaseValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../IProtocolGovernance.sol\";\n\ninterface IBaseValidator {\n    /// @notice Validator parameters\n    /// @param protocolGovernance Reference to Protocol Governance\n    struct ValidatorParams {\n        IProtocolGovernance protocolGovernance;\n    }\n\n    /// @notice Validator params staged to commit.\n    function stagedValidatorParams() external view returns (ValidatorParams memory);\n\n    /// @notice Timestamp after which validator params can be committed.\n    function stagedValidatorParamsTimestamp() external view returns (uint256);\n\n    /// @notice Current validator params.\n    function validatorParams() external view returns (ValidatorParams memory);\n\n    /// @notice Stage new validator params for commit.\n    /// @param newParams New params for commit\n    function stageValidatorParams(ValidatorParams calldata newParams) external;\n\n    /// @notice Commit new validator params.\n    function commitValidatorParams() external;\n}\n"
    },
    "contracts/interfaces/validators/IValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"./IBaseValidator.sol\";\n\ninterface IValidator is IBaseValidator, IERC165 {\n    // @notice Validate if call can be made to external contract.\n    // @dev Reverts if validation failed. Returns nothing if validation is ok\n    // @param sender Sender of the externalCall method\n    // @param addr Address of the called contract\n    // @param value Ether value for the call\n    // @param selector Selector of the called method\n    // @param data Call data after selector\n    function validate(\n        address sender,\n        address addr,\n        uint256 value,\n        bytes4 selector,\n        bytes calldata data\n    ) external view;\n}\n"
    },
    "contracts/interfaces/vaults/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./IVaultGovernance.sol\";\n\ninterface IVault is IERC165 {\n    /// @notice Checks if the vault is initialized\n\n    function initialized() external view returns (bool);\n\n    /// @notice VaultRegistry NFT for this vault\n    function nft() external view returns (uint256);\n\n    /// @notice Address of the Vault Governance for this contract.\n    function vaultGovernance() external view returns (IVaultGovernance);\n\n    /// @notice ERC20 tokens under Vault management.\n    function vaultTokens() external view returns (address[] memory);\n\n    /// @notice Checks if a token is vault token\n    /// @param token Address of the token to check\n    /// @return `true` if this token is managed by Vault\n    function isVaultToken(address token) external view returns (bool);\n\n    /// @notice Total value locked for this contract.\n    /// @dev Generally it is the underlying token value of this contract in some\n    /// other DeFi protocol. For example, for USDC Yearn Vault this would be total USDC balance that could be withdrawn for Yearn to this contract.\n    /// The tvl itself is estimated in some range. Sometimes the range is exact, sometimes it's not\n    /// @return minTokenAmounts Lower bound for total available balances estimation (nth tokenAmount corresponds to nth token in vaultTokens)\n    /// @return maxTokenAmounts Upper bound for total available balances estimation (nth tokenAmount corresponds to nth token in vaultTokens)\n    function tvl() external view returns (uint256[] memory minTokenAmounts, uint256[] memory maxTokenAmounts);\n\n    /// @notice Existential amounts for each token\n    function pullExistentials() external view returns (uint256[] memory);\n}\n"
    },
    "contracts/interfaces/vaults/IVaultGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../IProtocolGovernance.sol\";\nimport \"../IVaultRegistry.sol\";\nimport \"./IVault.sol\";\n\ninterface IVaultGovernance {\n    /// @notice Internal references of the contract.\n    /// @param protocolGovernance Reference to Protocol Governance\n    /// @param registry Reference to Vault Registry\n    struct InternalParams {\n        IProtocolGovernance protocolGovernance;\n        IVaultRegistry registry;\n        IVault singleton;\n    }\n\n    // -------------------  EXTERNAL, VIEW  -------------------\n\n    /// @notice Timestamp in unix time seconds after which staged Delayed Strategy Params could be committed.\n    /// @param nft Nft of the vault\n    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256);\n\n    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params could be committed.\n    function delayedProtocolParamsTimestamp() external view returns (uint256);\n\n    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params Per Vault could be committed.\n    /// @param nft Nft of the vault\n    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256);\n\n    /// @notice Timestamp in unix time seconds after which staged Internal Params could be committed.\n    function internalParamsTimestamp() external view returns (uint256);\n\n    /// @notice Internal Params of the contract.\n    function internalParams() external view returns (InternalParams memory);\n\n    /// @notice Staged new Internal Params.\n    /// @dev The Internal Params could be committed after internalParamsTimestamp\n    function stagedInternalParams() external view returns (InternalParams memory);\n\n    // -------------------  EXTERNAL, MUTATING  -------------------\n\n    /// @notice Stage new Internal Params.\n    /// @param newParams New Internal Params\n    function stageInternalParams(InternalParams memory newParams) external;\n\n    /// @notice Commit staged Internal Params.\n    function commitInternalParams() external;\n}\n"
    },
    "contracts/libraries/ExceptionsLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\n/// @notice Exceptions stores project`s smart-contracts exceptions\nlibrary ExceptionsLibrary {\n    string constant ADDRESS_ZERO = \"AZ\";\n    string constant VALUE_ZERO = \"VZ\";\n    string constant EMPTY_LIST = \"EMPL\";\n    string constant NOT_FOUND = \"NF\";\n    string constant INIT = \"INIT\";\n    string constant DUPLICATE = \"DUP\";\n    string constant NULL = \"NULL\";\n    string constant TIMESTAMP = \"TS\";\n    string constant FORBIDDEN = \"FRB\";\n    string constant ALLOWLIST = \"ALL\";\n    string constant LIMIT_OVERFLOW = \"LIMO\";\n    string constant LIMIT_UNDERFLOW = \"LIMU\";\n    string constant INVALID_VALUE = \"INV\";\n    string constant INVARIANT = \"INVA\";\n    string constant INVALID_TARGET = \"INVTR\";\n    string constant INVALID_TOKEN = \"INVTO\";\n    string constant INVALID_INTERFACE = \"INVI\";\n    string constant INVALID_SELECTOR = \"INVS\";\n    string constant INVALID_STATE = \"INVST\";\n    string constant INVALID_LENGTH = \"INVL\";\n    string constant LOCK = \"LCKD\";\n    string constant DISABLED = \"DIS\";\n}\n"
    },
    "contracts/libraries/PermissionIdsLibrary.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\n/// @notice Stores permission ids for addresses\nlibrary PermissionIdsLibrary {\n    // The msg.sender is allowed to register vault\n    uint8 constant REGISTER_VAULT = 0;\n    // The msg.sender is allowed to create vaults\n    uint8 constant CREATE_VAULT = 1;\n    // The token is allowed to be transfered by vault\n    uint8 constant ERC20_TRANSFER = 2;\n    // The token is allowed to be added to vault\n    uint8 constant ERC20_VAULT_TOKEN = 3;\n    // Trusted protocols that are allowed to be approved of vault ERC20 tokens by any strategy\n    uint8 constant ERC20_APPROVE = 4;\n    // Trusted protocols that are allowed to be approved of vault ERC20 tokens by trusted strategy\n    uint8 constant ERC20_APPROVE_RESTRICTED = 5;\n    // Strategy allowed using restricted API\n    uint8 constant TRUSTED_STRATEGY = 6;\n}\n"
    },
    "contracts/utils/ContractMeta.sol": {
      "content": "// SPDX-License-Identifier: BSL-1.1\npragma solidity 0.8.9;\n\nimport \"../interfaces/utils/IContractMeta.sol\";\n\nabstract contract ContractMeta is IContractMeta {\n    // -------------------  EXTERNAL, VIEW  -------------------\n\n    function contractName() external pure returns (string memory) {\n        return _bytes32ToString(_contractName());\n    }\n\n    function contractNameBytes() external pure returns (bytes32) {\n        return _contractName();\n    }\n\n    function contractVersion() external pure returns (string memory) {\n        return _bytes32ToString(_contractVersion());\n    }\n\n    function contractVersionBytes() external pure returns (bytes32) {\n        return _contractVersion();\n    }\n\n    // -------------------  INTERNAL, VIEW  -------------------\n\n    function _contractName() internal pure virtual returns (bytes32);\n\n    function _contractVersion() internal pure virtual returns (bytes32);\n\n    function _bytes32ToString(bytes32 b) internal pure returns (string memory s) {\n        s = new string(32);\n        uint256 len = 32;\n        for (uint256 i = 0; i < 32; ++i) {\n            if (uint8(b[i]) == 0) {\n                len = i;\n                break;\n            }\n        }\n        assembly {\n            mstore(s, len)\n            mstore(add(s, 0x20), b)\n        }\n    }\n}\n"
    },
    "contracts/validators/BaseValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../interfaces/validators/IBaseValidator.sol\";\nimport \"../interfaces/IProtocolGovernance.sol\";\nimport \"../libraries/ExceptionsLibrary.sol\";\n\ncontract BaseValidator is IBaseValidator {\n    IBaseValidator.ValidatorParams internal _validatorParams;\n    IBaseValidator.ValidatorParams internal _stagedValidatorParams;\n    uint256 internal _stagedValidatorParamsTimestamp;\n\n    constructor(IProtocolGovernance protocolGovernance) {\n        _validatorParams = IBaseValidator.ValidatorParams({protocolGovernance: protocolGovernance});\n    }\n\n    // -------------------  EXTERNAL, VIEW  -------------------\n\n    /// @inheritdoc IBaseValidator\n    function stagedValidatorParams() external view returns (ValidatorParams memory) {\n        return _stagedValidatorParams;\n    }\n\n    /// @inheritdoc IBaseValidator\n    function stagedValidatorParamsTimestamp() external view returns (uint256) {\n        return _stagedValidatorParamsTimestamp;\n    }\n\n    /// @inheritdoc IBaseValidator\n    function validatorParams() external view returns (ValidatorParams memory) {\n        return _validatorParams;\n    }\n\n    // -------------------  EXTERNAL, MUTATING  -------------------\n\n    /// @notice Stages params that could have been committed after governance delay expires.\n    /// @param newParams Params to stage\n    function stageValidatorParams(IBaseValidator.ValidatorParams calldata newParams) external {\n        IProtocolGovernance governance = _validatorParams.protocolGovernance;\n        require(governance.isAdmin(msg.sender), ExceptionsLibrary.FORBIDDEN);\n        _stagedValidatorParams = newParams;\n        _stagedValidatorParamsTimestamp = block.timestamp + governance.governanceDelay();\n        emit StagedValidatorParams(tx.origin, msg.sender, newParams, _stagedValidatorParamsTimestamp);\n    }\n\n    /// @notice Commits staged params\n    function commitValidatorParams() external {\n        require(_stagedValidatorParamsTimestamp != 0, ExceptionsLibrary.INVALID_STATE);\n        IProtocolGovernance governance = _validatorParams.protocolGovernance;\n        require(governance.isAdmin(msg.sender), ExceptionsLibrary.FORBIDDEN);\n        require(block.timestamp >= _stagedValidatorParamsTimestamp, ExceptionsLibrary.TIMESTAMP);\n        _validatorParams = _stagedValidatorParams;\n        delete _stagedValidatorParams;\n        delete _stagedValidatorParamsTimestamp;\n        emit CommittedValidatorParams(tx.origin, msg.sender, _validatorParams);\n    }\n\n    /// @notice Emitted when new params are staged for commit\n    /// @param origin Origin of the transaction (tx.origin)\n    /// @param sender Sender of the call (msg.sender)\n    /// @param newParams New params that were staged for commit\n    /// @param when When the params could be committed\n    event StagedValidatorParams(\n        address indexed origin,\n        address indexed sender,\n        IBaseValidator.ValidatorParams newParams,\n        uint256 when\n    );\n\n    /// @notice Emitted when new params are staged for commit\n    /// @param origin Origin of the transaction (tx.origin)\n    /// @param sender Sender of the call (msg.sender)\n    /// @param params New params that were staged for commit\n    event CommittedValidatorParams(\n        address indexed origin,\n        address indexed sender,\n        IBaseValidator.ValidatorParams params\n    );\n}\n"
    },
    "contracts/validators/UniV3Validator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../interfaces/external/univ3/ISwapRouter.sol\";\nimport \"../interfaces/external/univ3/IUniswapV3Factory.sol\";\nimport \"../interfaces/vaults/IVault.sol\";\nimport \"../interfaces/IProtocolGovernance.sol\";\nimport \"../libraries/PermissionIdsLibrary.sol\";\nimport \"../libraries/ExceptionsLibrary.sol\";\nimport \"../utils/ContractMeta.sol\";\nimport \"./Validator.sol\";\n\ncontract UniV3Validator is ContractMeta, Validator {\n    bytes4 public constant EXACT_INPUT_SINGLE_SELECTOR = ISwapRouter.exactInputSingle.selector;\n    bytes4 public constant EXACT_INPUT_SELECTOR = ISwapRouter.exactInput.selector;\n    bytes4 public constant EXACT_OUTPUT_SINGLE_SELECTOR = ISwapRouter.exactOutputSingle.selector;\n    bytes4 public constant EXACT_OUTPUT_SELECTOR = ISwapRouter.exactOutput.selector;\n    address public immutable swapRouter;\n    IUniswapV3Factory public immutable factory;\n\n    constructor(\n        IProtocolGovernance protocolGovernance_,\n        address swapRouter_,\n        IUniswapV3Factory factory_\n    ) BaseValidator(protocolGovernance_) {\n        swapRouter = swapRouter_;\n        factory = factory_;\n    }\n\n    // -------------------  EXTERNAL, VIEW  -------------------\n\n    // @inhericdoc IValidator\n    function validate(\n        address,\n        address addr,\n        uint256 value,\n        bytes4 selector,\n        bytes calldata data\n    ) external view {\n        require(address(swapRouter) == addr, ExceptionsLibrary.INVALID_TARGET);\n        require(value == 0, ExceptionsLibrary.INVALID_VALUE);\n        IVault vault = IVault(msg.sender);\n        if (selector == EXACT_INPUT_SINGLE_SELECTOR) {\n            ISwapRouter.ExactInputSingleParams memory params = abi.decode(data, (ISwapRouter.ExactInputSingleParams));\n            _verifySingleCall(vault, params.recipient, params.tokenIn, params.tokenOut, params.fee);\n        } else if (selector == EXACT_OUTPUT_SINGLE_SELECTOR) {\n            ISwapRouter.ExactOutputSingleParams memory params = abi.decode(data, (ISwapRouter.ExactOutputSingleParams));\n            _verifySingleCall(vault, params.recipient, params.tokenIn, params.tokenOut, params.fee);\n        } else if (selector == EXACT_INPUT_SELECTOR) {\n            ISwapRouter.ExactInputParams memory params = abi.decode(data, (ISwapRouter.ExactInputParams));\n            _verifyMultiCall(vault, params.recipient, params.path);\n        } else if (selector == EXACT_OUTPUT_SELECTOR) {\n            ISwapRouter.ExactOutputParams memory params = abi.decode(data, (ISwapRouter.ExactOutputParams));\n            _verifyMultiCall(vault, params.recipient, params.path);\n        } else {\n            revert(ExceptionsLibrary.INVALID_SELECTOR);\n        }\n    }\n\n    // -------------------  INTERNAL, VIEW  -------------------\n\n    function _contractName() internal pure override returns (bytes32) {\n        return bytes32(\"UniV3Validator\");\n    }\n\n    function _contractVersion() internal pure override returns (bytes32) {\n        return bytes32(\"1.0.0\");\n    }\n\n    function _verifyMultiCall(\n        IVault vault,\n        address recipient,\n        bytes memory path\n    ) private view {\n        uint256 i;\n        address token0;\n        address token1;\n        uint24 fee;\n        uint256 feeMask = (1 << 24) - 1;\n        uint256 tokenMask = (1 << 160) - 1;\n        require(recipient == address(vault), ExceptionsLibrary.INVALID_TARGET);\n        // the sample UniV3 path structure is (DAI address,DAI-USDC fee, USDC, USDC-WETH fee, WETH)\n        // addresses are 20 bytes, fees are 3 bytes\n        require(((path.length + 3) % 23 == 0) && (path.length >= 43), ExceptionsLibrary.INVALID_LENGTH);\n        while (path.length - i > 20) {\n            assembly {\n                let o := add(add(path, 0x20), i)\n                let d := mload(o)\n                d := shr(72, d)\n                fee := and(d, feeMask)\n                token0 := shr(24, d)\n                d := mload(add(o, 11))\n                token1 := and(d, tokenMask)\n            }\n            _verifyPathItem(token0, token1, fee);\n            i += 23;\n        }\n        require(vault.isVaultToken(token1), ExceptionsLibrary.INVALID_TOKEN);\n    }\n\n    function _verifySingleCall(\n        IVault vault,\n        address recipient,\n        address tokenIn,\n        address tokenOut,\n        uint24 fee\n    ) private view {\n        require(recipient == address(vault), ExceptionsLibrary.INVALID_TARGET);\n        require(vault.isVaultToken(tokenOut), ExceptionsLibrary.INVALID_TOKEN);\n        _verifyPathItem(tokenIn, tokenOut, fee);\n    }\n\n    function _verifyPathItem(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee\n    ) private view {\n        require(tokenIn != tokenOut, ExceptionsLibrary.INVALID_TOKEN);\n        IProtocolGovernance protocolGovernance = _validatorParams.protocolGovernance;\n        address pool = factory.getPool(tokenIn, tokenOut, fee);\n        require(\n            protocolGovernance.hasPermission(pool, PermissionIdsLibrary.ERC20_APPROVE),\n            ExceptionsLibrary.FORBIDDEN\n        );\n    }\n}\n"
    },
    "contracts/validators/Validator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../interfaces/validators/IValidator.sol\";\nimport \"./BaseValidator.sol\";\n\nabstract contract Validator is IValidator, ERC165, BaseValidator {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return (interfaceId == type(IValidator).interfaceId) || super.supportsInterface(interfaceId);\n    }\n}\n"
    }
  }
}}