{{
  "language": "Solidity",
  "sources": {
    "contracts/MockDAI.sol": {
      "content": "pragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport \"@0xsequence/erc20-meta-token/contracts/mocks/ERC20Mock.sol\";\n\ncontract MockDAI is ERC20Mock {}"
    },
    "contracts/FreeConquestEntriesFactory.sol": {
      "content": "pragma solidity 0.7.4;\n\nimport \"@horizongames/skyweaver-contracts/contracts/factories/RewardFactory.sol\";\n\ncontract FreeConquestEntriesFactory is RewardFactory {\n  constructor(\n    address _initialOwner,\n    address _assetsAddr,\n    uint256 _periodLength,\n    uint256 _periodMintLimit\n  ) RewardFactory(_initialOwner, _assetsAddr, _periodLength, _periodMintLimit) public {}\n}"
    },
    "@horizongames/skyweaver-contracts/contracts/factories/RewardFactory.sol": {
      "content": "pragma solidity 0.7.4;\n\nimport \"../utils/TieredOwnable.sol\";\nimport \"../interfaces/ISkyweaverAssets.sol\";\nimport \"@0xsequence/erc-1155/contracts/utils/SafeMath.sol\";\nimport \"@0xsequence/erc-1155/contracts/interfaces/IERC165.sol\";\n\n/**\n * @notice This is a contract allowing contract owner to mint up to N \n *         assets per period of 6 hours.\n * @dev This contract should only be able to mint some asset types\n */\ncontract RewardFactory is TieredOwnable {\n  using SafeMath for uint256;\n\n  /***********************************|\n  |             Variables             |\n  |__________________________________*/\n\n  // Token information\n  ISkyweaverAssets immutable public skyweaverAssets; // ERC-1155 Skyweaver assets contract\n\n  // Period variables\n  uint256 internal period;                // Current period\n  uint256 internal availableSupply;       // Amount of assets that can currently be minted\n  uint256 public periodMintLimit;         // Amount that can be minted within 6h\n  uint256 immutable public PERIOD_LENGTH; // Length of each mint periods in seconds\n\n  // Event\n  event PeriodMintLimitChanged(uint256 oldMintingLimit, uint256 newMintingLimit);\n  \n  /***********************************|\n  |            Constructor            |\n  |__________________________________*/\n\n  /**\n   * @notice Create factory, link skyweaver assets and store initial parameters\n   * @param _firstOwner       Address of the first owner\n   * @param _assetsAddr       The address of the ERC-1155 Assets Token contract\n   * @param _periodLength     Number of seconds each period lasts\n   * @param _periodMintLimit  Can only mint N assets per period\n   */\n  constructor(\n    address _firstOwner,\n    address _assetsAddr,\n    uint256 _periodLength,\n    uint256 _periodMintLimit\n  ) TieredOwnable(_firstOwner) public {\n    require(\n      _assetsAddr != address(0) &&\n      _periodLength > 0 &&\n      _periodMintLimit > 0,\n      \"RewardFactory#constructor: INVALID_INPUT\"\n    );\n\n    // Assets\n    skyweaverAssets = ISkyweaverAssets(_assetsAddr);\n\n    // Set Period length\n    PERIOD_LENGTH = _periodLength;\n\n    // Set current period\n    period = block.timestamp / _periodLength; // From livePeriod()\n    availableSupply = _periodMintLimit;\n\n    // Rewards parameters\n    periodMintLimit = _periodMintLimit;\n    emit PeriodMintLimitChanged(0, _periodMintLimit);\n  }\n\n\n  /***********************************|\n  |         Management Methods        |\n  |__________________________________*/\n\n  /**\n   * @notice Will update the daily mint limit\n   * @dev This change will take effect immediatly once executed\n   * @param _newPeriodMintLimit Amount of assets that can be minted within a period\n   */\n  function updatePeriodMintLimit(uint256 _newPeriodMintLimit) external onlyOwnerTier(HIGHEST_OWNER_TIER) {\n    // Immediately update supply instead of waiting for next period\n    if (availableSupply > _newPeriodMintLimit) {\n      availableSupply = _newPeriodMintLimit;\n    }\n\n    emit PeriodMintLimitChanged(periodMintLimit, _newPeriodMintLimit);\n    periodMintLimit = _newPeriodMintLimit;\n  }\n\n\n  /***********************************|\n  |      Receiver Method Handler      |\n  |__________________________________*/\n\n  /**\n   * @notice Prevents receiving Ether or calls to unsuported methods\n   */\n  fallback () external {\n    revert(\"RewardFactory#_: UNSUPPORTED_METHOD\");\n  }\n\n  /***********************************|\n  |         Minting Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Will mint tokens to user\n   * @dev Can only mint up to the periodMintLimit in a given 6hour period\n   * @param _to      The address that receives the assets\n   * @param _ids     Array of Tokens ID that are minted\n   * @param _amounts Amount of Tokens id minted for each corresponding Token id in _ids\n   * @param _data    Byte array passed to recipient if recipient is a contract\n   */\n  function batchMint(address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data)\n    external onlyOwnerTier(1)\n  {\n    uint256 live_period = livePeriod();\n    uint256 stored_period = period;\n    uint256 available_supply;\n\n    // Update period and refresh the available supply if period\n    // is different, otherwise use current available supply.\n    if (live_period == stored_period) {\n      available_supply = availableSupply;\n    } else {\n      available_supply = periodMintLimit;\n      period = live_period;\n    }\n\n    // If there is an insufficient available supply, this will revert\n    for (uint256 i = 0; i < _ids.length; i++) {\n      available_supply = available_supply.sub(_amounts[i]);\n    }\n\n    // Store available supply\n    availableSupply = available_supply;\n    \n    // Mint assets\n    skyweaverAssets.batchMint(_to, _ids, _amounts, _data);\n  }\n\n\n  /***********************************|\n  |         Utility Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Returns how many cards can currently be minted by this factory\n   */\n  function getAvailableSupply() external view returns (uint256) {\n    return livePeriod() == period ? availableSupply : periodMintLimit;\n  }\n\n  /**\n   * @notice Calculate the current period\n   */\n  function livePeriod() public view returns (uint256) {\n    return block.timestamp / PERIOD_LENGTH;\n  }\n\n  /**\n   * @notice Indicates whether a contract implements a given interface.\n   * @param interfaceID The ERC-165 interface ID that is queried for support.\n   * @return True if contract interface is supported.\n   */\n  function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n    return  interfaceID == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "@horizongames/skyweaver-contracts/contracts/utils/TieredOwnable.sol": {
      "content": "pragma solidity 0.7.4;\n\n/**\n * @notice The TieredOwnable can assign ownership tiers to addresses,\n * allowing inheriting contracts to choose which tier can call which function.\n */\ncontract TieredOwnable {\n  uint256 constant internal HIGHEST_OWNER_TIER = 2**256-1; //Highest possible tier\n\n  mapping(address => uint256) internal ownerTier;\n  event OwnershipGranted(address indexed owner, uint256 indexed previousTier, uint256 indexed newTier);\n\n  /**\n   * @dev Sets the _firstOwner provided to highest owner tier\n   * @dev _firstOwner First address to be a owner of this contract\n   */\n  constructor (address _firstOwner) {\n    require(_firstOwner != address(0), \"TieredOwnable#constructor: INVALID_FIRST_OWNER\");\n    ownerTier[_firstOwner] = HIGHEST_OWNER_TIER;\n    emit OwnershipGranted(_firstOwner, 0, HIGHEST_OWNER_TIER);\n  }\n\n  /**\n   * @dev Throws if called by an account that's in lower ownership tier than expected\n   */\n  modifier onlyOwnerTier(uint256 _minTier) {\n    require(ownerTier[msg.sender] >= _minTier, \"TieredOwnable#onlyOwnerTier: OWNER_TIER_IS_TOO_LOW\");\n    _;\n  }\n\n  /**\n   * @notice Highest owners can change ownership tier of other owners\n   * @dev Prevents changing sender's tier to ensure there is always at least one HIGHEST_OWNER_TIER owner.\n   * @param _address Address of the owner\n   * @param _tier    Ownership tier assigned to owner\n   */\n  function assignOwnership(address _address, uint256 _tier) external onlyOwnerTier(HIGHEST_OWNER_TIER) {\n    require(_address != address(0), \"TieredOwnable#assignOwnership: INVALID_ADDRESS\");\n    require(msg.sender != _address, \"TieredOwnable#assignOwnership: UPDATING_SELF_TIER\");\n    emit OwnershipGranted(_address, ownerTier[_address], _tier);\n    ownerTier[_address] = _tier;\n  }\n\n  /**\n   * @notice Returns the ownership tier of provided owner\n   * @param _owner Owner's address to query ownership tier\n   */\n  function getOwnerTier(address _owner) external view returns (uint256) {\n    return ownerTier[_owner];\n  }\n}"
    },
    "@horizongames/skyweaver-contracts/contracts/interfaces/ISkyweaverAssets.sol": {
      "content": "pragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\ninterface ISkyweaverAssets {\n\n  /***********************************|\n  |               Events              |\n  |__________________________________*/\n\n  event FactoryActivation(address indexed factory);\n  event FactoryShutdown(address indexed factory);\n  event MintPermissionAdded(address indexed factory, AssetRange new_range);\n  event MintPermissionRemoved(address indexed factory, AssetRange deleted_range);\n\n  // Struct for mint ID ranges permissions\n  struct AssetRange {\n    uint256 minID;\n    uint256 maxID;\n  }\n\n  /***********************************|\n  |    Supplies Management Methods    |\n  |__________________________________*/\n\n  /**\n   * @notice Set max issuance for some token IDs that can't ever be increased\n   * @dev Can only decrease the max issuance if already set, but can't set it *back* to 0.\n   * @param _ids Array of token IDs to set the max issuance\n   * @param _newMaxIssuances Array of max issuances for each corresponding ID\n   */\n  function setMaxIssuances(uint256[] calldata _ids, uint256[] calldata _newMaxIssuances) external;\n\n  /***********************************|\n  |     Factory Management Methods    |\n  |__________________________________*/\n\n  /**\n   * @notice Will allow a factory to mint some token ids\n   * @param _factory  Address of the factory to update permission\n   * @param _minRange Minimum ID (inclusive) in id range that factory will be able to mint\n   * @param _maxRange Maximum ID (inclusive) in id range that factory will be able to mint\n   */\n  function addMintPermission(address _factory, uint256 _minRange, uint256 _maxRange) external;\n\n  /**\n   * @notice Will remove the permission a factory has to mint some token ids\n   * @param _factory    Address of the factory to update permission\n   * @param _rangeIndex Array's index where the range to delete is located for _factory\n   */\n  function removeMintPermission(address _factory, uint256 _rangeIndex) external;\n\n  /**\n   * @notice Will ALLOW factory to print some assets specified in `canPrint` mapping\n   * @param _factory Address of the factory to activate\n   */\n  function activateFactory(address _factory) external;\n\n  /**\n   * @notice Will DISALLOW factory to print any asset\n   * @param _factory Address of the factory to shutdown\n   */\n  function shutdownFactory(address _factory) external;\n\n  /**\n   * @notice Will forever prevent new mint permissions for provided ids\n   * @param _range AssetRange struct for range of asset that can't be granted\n   *               new mint permission to\n   */\n  function lockRangeMintPermissions(AssetRange calldata _range) external;\n\n\n  /***********************************|\n  |         Getter Functions          |\n  |__________________________________*/\n\n  /**\n   * @return Returns whether a factory is active or not\n   */\n  function getFactoryStatus(address _factory) external view returns (bool);\n\n  /**\n   * @return Returns whether the sale has ended or not\n   */\n  function getFactoryAccessRanges(address _factory) external view returns ( AssetRange[] memory);\n\n  /**\n   * @notice Get the max issuance of multiple asset IDs\n   * @dev The max issuance of a token does not reflect the maximum supply, only\n   *      how many tokens can be minted once the maxIssuance for a token is set.\n   * @param _ids Array containing the assets IDs\n   * @return The current max issuance of each asset ID in _ids\n   */\n  function getMaxIssuances(uint256[] calldata _ids) external view returns (uint256[] memory);\n\n  /**\n   * @notice Get the current issuanc of multiple asset ID\n   * @dev The current issuance of a token does not reflect the current supply, only\n   *      how many tokens since a max issuance was set for a given token id.\n   * @param _ids Array containing the assets IDs\n   * @return The current issuance of each asset ID in _ids\n   */\n  function getCurrentIssuances(uint256[] calldata _ids)external view returns (uint256[] memory);\n\n  /***************************************|\n  |           Minting Functions           |\n  |______________________________________*/\n\n  /**\n   * @dev Mint _amount of tokens of a given id if not frozen and if max supply not exceeded\n   * @param _to     The address to mint tokens to.\n   * @param _id     Token id to mint\n   * @param _amount The amount to be minted\n   * @param _data   Byte array of data to pass to recipient if it's a contract\n   */\n  function mint(address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\n\n  /**\n   * @dev Mint tokens for each ids in _ids\n   * @param _to      The address to mint tokens to.\n   * @param _ids     Array of ids to mint\n   * @param _amounts Array of amount of tokens to mint per id\n   * @param _data    Byte array of data to pass to recipient if it's a contract\n   */\n  function batchMint(address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\n\n\n  /***************************************|\n  |           Burning Functions           |\n  |______________________________________*/\n\n  /**\n   * @notice Burn sender's_amount of tokens of a given token id\n   * @param _id      Token id to burn\n   * @param _amount  The amount to be burned\n   */\n  function burn(uint256 _id, uint256 _amount) external;\n\n  /**\n   * @notice Burn sender's tokens of given token id for each (_ids[i], _amounts[i]) pair\n   * @param _ids      Array of token ids to burn\n   * @param _amounts  Array of the amount to be burned\n   */\n  function batchBurn(uint256[] calldata _ids, uint256[] calldata _amounts) external;\n}"
    },
    "@0xsequence/erc-1155/contracts/utils/SafeMath.sol": {
      "content": "pragma solidity 0.7.4;\n\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n   * @dev Multiplies two unsigned integers, reverts on overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath#mul: OVERFLOW\");\n\n    return c;\n  }\n\n  /**\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath#div: DIVISION_BY_ZERO\");\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath#sub: UNDERFLOW\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Adds two unsigned integers, reverts on overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath#add: OVERFLOW\");\n\n    return c; \n  }\n\n  /**\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n   * reverts when dividing by zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMath#mod: DIVISION_BY_ZERO\");\n    return a % b;\n  }\n}"
    },
    "@0xsequence/erc-1155/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\n\n/**\n * @title ERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas\n     * @param _interfaceId The interface identifier, as specified in ERC-165\n     */\n    function supportsInterface(bytes4 _interfaceId)\n    external\n    view\n    returns (bool);\n}\n"
    },
    "contracts/SilverRewardFactory.sol": {
      "content": "pragma solidity 0.7.4;\n\nimport \"@horizongames/skyweaver-contracts/contracts/factories/RewardFactory.sol\";\n\ncontract SilverRewardFactory is RewardFactory {\n  constructor(\n    address _initialOwner,\n    address _assetsAddr,\n    uint256 _periodLength,\n    uint256 _periodMintLimit\n  ) RewardFactory(_initialOwner, _assetsAddr, _periodLength, _periodMintLimit) public {}\n}"
    },
    "contracts/LeaderboardRewardFactory.sol": {
      "content": "pragma solidity 0.7.4;\n\nimport \"@horizongames/skyweaver-contracts/contracts/factories/RewardFactory.sol\";\n\ncontract LeaderboardRewardFactory is RewardFactory {\n  constructor(\n    address _initialOwner,\n    address _assetsAddr,\n    uint256 _periodLength,\n    uint256 _periodMintLimit\n  ) RewardFactory(_initialOwner, _assetsAddr, _periodLength, _periodMintLimit) public {}\n}"
    },
    "contracts/GoldRewardFactory.sol": {
      "content": "pragma solidity 0.7.4;\n\nimport \"@horizongames/skyweaver-contracts/contracts/factories/RewardFactory.sol\";\n\ncontract GoldRewardFactory is RewardFactory {\n  constructor(\n    address _initialOwner,\n    address _assetsAddr,\n    uint256 _periodLength,\n    uint256 _periodMintLimit\n  ) RewardFactory(_initialOwner, _assetsAddr, _periodLength, _periodMintLimit) public {}\n}"
    },
    "@0xsequence/erc20-meta-token/contracts/mocks/ERC20Mock.sol": {
      "content": "pragma solidity 0.7.4;\n\nimport \"@0xsequence/erc-1155/contracts/interfaces/IERC20.sol\";\nimport \"@0xsequence/erc-1155/contracts/utils/SafeMath.sol\";\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://eips.ethereum.org/EIPS/eip-20\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n\n  /**\n    * @dev Total number of tokens in existence\n    */\n  function totalSupply() public override view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return A uint256 representing the amount owned by the passed address.\n    */\n  function balanceOf(address owner) public override view returns (uint256) {\n    return _balances[owner];\n  }\n\n  /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param owner address The address which owns the funds.\n    * @param spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n  function allowance(address owner, address spender) public override view returns (uint256) {\n    return _allowed[owner][spender];\n  }\n\n  /**\n    * @dev Transfer token to a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n  function transfer(address to, uint256 value) public override returns (bool) {\n    _transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param spender The address which will spend the funds.\n    * @param value The amount of tokens to be spent.\n    */\n  function approve(address spender, uint256 value) public override returns (bool) {\n    _approve(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n    * @dev Transfer tokens from one address to another.\n    * Note that while this function emits an Approval event, this is not required as per the specification,\n    * and other compliant implementations may not emit the event.\n    * @param from address The address which you want to send tokens from\n    * @param to address The address which you want to transfer to\n    * @param value uint256 the amount of tokens to be transferred\n    */\n  function transferFrom(address from, address to, uint256 value) public override returns (bool) {\n    _transfer(from, to, value);\n    _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n    return true;\n  }\n\n  /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * Emits an Approval event.\n    * @param spender The address which will spend the funds.\n    * @param addedValue The amount of tokens to increase the allowance by.\n    */\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * Emits an Approval event.\n    * @param spender The address which will spend the funds.\n    * @param subtractedValue The amount of tokens to decrease the allowance by.\n    */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n    return true;\n  }\n\n  /**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n  function _transfer(address from, address to, uint256 value) internal {\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(from, to, value);\n  }\n\n  /**\n    * @dev Internal function that mints an amount of the token and assigns it to\n    * an account. This encapsulates the modification of balances such that the\n    * proper events are emitted.\n    * @param account The account that will receive the created tokens.\n    * @param value The amount that will be created.\n    */\n  function _mint(address account, uint256 value) internal {\n    require(account != address(0));\n\n    _totalSupply = _totalSupply.add(value);\n    _balances[account] = _balances[account].add(value);\n    emit Transfer(address(0), account, value);\n  }\n\n  /**\n    * @dev Internal function that burns an amount of the token of a given\n    * account.\n    * @param account The account whose tokens will be burnt.\n    * @param value The amount that will be burnt.\n    */\n  function _burn(address account, uint256 value) internal {\n    require(account != address(0));\n\n    _totalSupply = _totalSupply.sub(value);\n    _balances[account] = _balances[account].sub(value);\n    emit Transfer(account, address(0), value);\n  }\n\n  /**\n    * @dev Approve an address to spend another addresses' tokens.\n    * @param owner The address that owns the tokens.\n    * @param spender The address that will spend the tokens.\n    * @param value The number of tokens that can be spent.\n    */\n  function _approve(address owner, address spender, uint256 value) internal {\n    require(spender != address(0));\n    require(owner != address(0));\n\n    _allowed[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  }\n\n  /**\n    * @dev Internal function that burns an amount of the token of a given\n    * account, deducting from the sender's allowance for said account. Uses the\n    * internal burn function.\n    * Emits an Approval event (reflecting the reduced allowance).\n    * @param account The account whose tokens will be burnt.\n    * @param value The amount that will be burnt.\n    */\n  function _burnFrom(address account, uint256 value) internal {\n    _burn(account, value);\n    _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n  }\n\n}\n\ncontract ERC20Mock is ERC20 {\n  constructor() public { }\n\n  function mockMint(address _address, uint256 _amount) public {\n    _mint(_address, _amount);\n  }\n\n}\n\n\n"
    },
    "@0xsequence/erc-1155/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n  function transfer(address to, uint256 value) external returns (bool);\n  function approve(address spender, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address who) external view returns (uint256);\n  function allowance(address owner, address spender) external view returns (uint256);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000,
      "details": {
        "yul": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}