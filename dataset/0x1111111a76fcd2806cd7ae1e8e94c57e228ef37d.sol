{{
  "language": "Solidity",
  "sources": {
    "contracts/Main.sol": {
      "content": "// SPDX-License-Identifier: AGPL\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/ERC777.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Sender.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"./libs/SwapSettingsLib.sol\";\nimport \"./libs/FixedPoint.sol\";\nimport \"./minimums/libs/MinimumsLib.sol\";\nimport \"./ExecuteManager.sol\";\nimport \"./Liquidity.sol\";\n\n//import \"hardhat/console.sol\";\n\ncontract Main is Ownable, IERC777Recipient, IERC777Sender, ERC777, ExecuteManager {\n    using FixedPoint for *;\n    using MinimumsLib for MinimumsLib.UserStruct;\n\n    struct PriceNumDen {\n        uint256 numerator;\n        uint256 denominator;\n    }\n\n    struct Observation {\n        uint64 timestampLast;\n        uint256 price0CumulativeLast;\n        FixedPoint.uq112x112 price0Average;\n    }\n\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n    address private constant deadAddress = 0x000000000000000000000000000000000000dEaD;\n\n    /**\n     * @custom:shortd traded token address\n     * @notice traded token address\n     */\n    address public immutable tradedToken;\n\n    /**\n     * @custom:shortd reserve token address\n     * @notice reserve token address\n     */\n    address public immutable reserveToken;\n\n    /**\n     * @custom:shortd price drop (mul by fraction)\n     * @notice price drop (mul by fraction)\n     */\n    uint256 public immutable priceDrop;\n\n    PriceNumDen minClaimPrice;\n\n    /**\n     * @custom:shortd external token\n     * @notice external token\n     */\n    address public externalToken;\n    PriceNumDen externalTokenExchangePrice;\n\n    /**\n     * @custom:shortd uniswap v2 pair\n     * @notice uniswap v2 pair\n     */\n    address public uniswapV2Pair;\n\n    address internal uniswapRouter;\n    address internal uniswapRouterFactory;\n\n    // keep gas when try to get reserves\n    // if token01 == true then (IUniswapV2Pair(uniswapV2Pair).token0() == tradedToken) so reserve0 it's reserves of TradedToken\n    bool internal immutable token01;\n    bool internal alreadyRunStartupSync;\n\n    uint64 internal constant averagePriceWindow = 5;\n    uint64 internal constant FRACTION = 10000;\n    uint64 internal constant LOCKUP_INTERVAL = 24 * 60 * 60; // day in seconds\n    uint64 internal startupTimestamp;\n    uint64 internal lockupIntervalAmount;\n\n    uint256 public immutable buyTaxMax;\n    uint256 public immutable sellTaxMax;\n    uint256 public buyTax;\n    uint256 public sellTax;\n    uint256 public totalCumulativeClaimed;\n\n    Liquidity internal internalLiquidity;\n    Observation internal pairObservation;\n\n    mapping(address => MinimumsLib.UserStruct) internal tokensLocked;\n\n    mapping(address => uint64) internal managers;\n\n    event AddedLiquidity(uint256 tradedTokenAmount, uint256 priceAverageData);\n\n    modifier onlyManagers() {\n        require(owner() == _msgSender() || managers[_msgSender()] != 0, \"MANAGERS_ONLY\");\n        _;\n    }\n\n    /**\n     * @param tokenName_ token name\n     * @param tokenSymbol_ token symbol\n     * @param reserveToken_ reserve token address\n     * @param priceDrop_ price drop while add liquidity\n     * @param lockupIntervalAmount_ interval amount in days (see minimum lib)\n     * @param minClaimPrice_ (numerator,denominator) minimum claim price that should be after \"sell all claimed tokens\"\n     * @param externalToken_ external token address that used to change their tokens to traded\n     * @param externalTokenExchangePrice_ (numerator,denominator) exchange price. used when user trying to change external token to Traded\n     * @param buyTaxMax_ buyTaxMax_\n     * @param sellTaxMax_ sellTaxMax_\n     */\n    constructor(\n        string memory tokenName_,\n        string memory tokenSymbol_,\n        address reserveToken_, //‚Äù (USDC)\n        uint256 priceDrop_,\n        uint64 lockupIntervalAmount_,\n        PriceNumDen memory minClaimPrice_,\n        address externalToken_,\n        PriceNumDen memory externalTokenExchangePrice_,\n        uint256 buyTaxMax_,\n        uint256 sellTaxMax_\n    ) ERC777(tokenName_, tokenSymbol_, new address[](0)) {\n        buyTaxMax = buyTaxMax_;\n        sellTaxMax = sellTaxMax_;\n\n        require(reserveToken_ != address(0), \"reserveToken invalid\");\n\n        tradedToken = address(this);\n        reserveToken = reserveToken_;\n        priceDrop = priceDrop_;\n        lockupIntervalAmount = lockupIntervalAmount_;\n\n        minClaimPrice.numerator = minClaimPrice_.numerator;\n        minClaimPrice.denominator = minClaimPrice_.denominator;\n        externalToken = externalToken_;\n        externalTokenExchangePrice.numerator = externalTokenExchangePrice_.numerator;\n        externalTokenExchangePrice.denominator = externalTokenExchangePrice_.denominator;\n\n        // setup swap addresses\n        (uniswapRouter, uniswapRouterFactory) = SwapSettingsLib.netWorkSettings();\n\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n\n        //create Pair\n        uniswapV2Pair = IUniswapV2Factory(uniswapRouterFactory).createPair(tradedToken, reserveToken);\n        require(uniswapV2Pair != address(0), \"can't create pair\");\n\n        startupTimestamp = currentBlockTimestamp();\n        pairObservation.timestampLast = currentBlockTimestamp();\n\n        // TypeError: Cannot write to immutable here: Immutable variables cannot be initialized inside an if statement.\n        // if (IUniswapV2Pair(uniswapV2Pair).token0() == tradedToken) {\n        //     token01 = true;\n        // }\n        // but can do if use ternary operator :)\n        token01 = (IUniswapV2Pair(uniswapV2Pair).token0() == tradedToken) ? true : false;\n\n        // IUniswapV2Pair(uniswapV2Pair).sync(); !!!! not created yet\n\n        internalLiquidity = new Liquidity(tradedToken, reserveToken, uniswapRouter);\n    }\n\n    ////////////////////////////////////////////////////////////////////////\n    // external section ////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////\n    /**\n     * @notice part of IERC777Recipient\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external {}\n\n    /**\n     * @notice part of IERC777Sender\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external {}\n\n    ////////////////////////////////////////////////////////////////////////\n    // public section //////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////\n    function addManagers(\n        address manager\n    )\n        public\n        onlyManagers\n    {\n        managers[manager] = currentBlockTimestamp();\n    }\n    /**\n     * @notice setting buy tax\n     * @param fraction buy tax\n     * @custom:calledby owner\n     */\n    function setBuyTax(uint256 fraction) public onlyOwner {\n        require(fraction <= buyTaxMax, \"FRACTION_INVALID\");\n        buyTax = fraction;\n    }\n\n    /**\n     * @notice setting sell tax\n     * @param fraction sell tax\n     * @custom:calledby owner\n     */\n    function setSellTax(uint256 fraction) public onlyOwner {\n        require(fraction <= sellTaxMax, \"FRACTION_INVALID\");\n        sellTax = fraction;\n    }\n\n    /**\n     * @dev adding initial liquidity. need to donate `amountReserveToken` of reserveToken into the contract. can be called once\n     * @param amountTradedToken amount of traded token which will be claimed into contract and adding as liquidity\n     * @param amountReserveToken amount of reserve token which must be donate into contract by user and adding as liquidity\n     */\n    function addInitialLiquidity(uint256 amountTradedToken, uint256 amountReserveToken) public onlyOwner runOnlyOnce {\n        require(amountReserveToken <= ERC777(reserveToken).balanceOf(address(this)), \"INSUFFICIENT_RESERVE\");\n        _claim(amountTradedToken, address(this));\n\n        ERC777(tradedToken).transfer(address(internalLiquidity), amountTradedToken);\n        ERC777(reserveToken).transfer(address(internalLiquidity), amountReserveToken);\n\n        internalLiquidity.addLiquidity();\n\n        // singlePairSync() ??\n\n        // console.log(\"force sync start\");\n\n        //force sync\n        //IUniswapV2Pair(uniswapV2Pair).sync();\n\n        // // and update\n        // update();\n    }\n\n    /**\n     * @notice claims `tradedTokenAmount` to caller\n     * @param tradedTokenAmount amount of traded token to claim\n     * @custom:calledby owner\n     */\n    function claim(uint256 tradedTokenAmount) public onlyManagers {\n        _validateClaim(tradedTokenAmount);\n        _claim(tradedTokenAmount, msg.sender);\n    }\n\n    /**\n     * @notice claims to account\n     * @param tradedTokenAmount amount of traded token to claim\n     * @param account address to claim for\n     * @custom:calledby owner\n     */\n    function claim(uint256 tradedTokenAmount, address account)\n        public\n        onlyManagers\n    {\n        _validateClaim(tradedTokenAmount);\n        _claim(tradedTokenAmount, account);\n    }\n\n    /**\n     * @notice claims to account traded tokens instead external tokens(if set). external tokens will send to dead address\n     * @param externalTokenAmount amount of external token to claim traded token\n     * @param account address to claim for\n     */\n    function claimViaExternal(uint256 externalTokenAmount, address account) public {\n        require(externalToken != address(0), \"EMPTY_EXTERNALTOKEN\");\n        require(\n            externalTokenAmount <= ERC777(externalToken).allowance(msg.sender, address(this)),\n            \"INSUFFICIENT_AMOUNT\"\n        );\n\n        ERC777(externalToken).transferFrom(msg.sender, deadAddress, externalTokenAmount);\n\n        uint256 tradedTokenAmount = (externalTokenAmount * externalTokenExchangePrice.numerator) /\n            externalTokenExchangePrice.denominator;\n\n        _validateClaim(tradedTokenAmount);\n\n        _claim(tradedTokenAmount, account);\n    }\n\n    /**\n     * @dev claims, sells, adds liquidity, sends LP to 0x0\n     * @custom:calledby owner\n     */\n    function addLiquidity(uint256 tradedTokenAmount) public onlyManagers {\n        singlePairSync();\n\n        uint256 tradedReserve1;\n        uint256 tradedReserve2;\n        uint256 priceAverageData; // it's fixed point uint224\n\n        uint256 rTraded;\n        uint256 rReserved;\n        uint256 traded2Swap;\n        uint256 traded2Liq;\n        uint256 reserved2Liq;\n\n        FixedPoint.uq112x112 memory averageWithPriceDrop;\n\n        (tradedReserve1, tradedReserve2, priceAverageData) = _maxAddLiquidity();\n\n        bool err;\n\n        if (tradedReserve1 < tradedReserve2 && tradedTokenAmount <= (tradedReserve2 - tradedReserve1)) {\n            err = false;\n        } else {\n            err = true;\n        }\n\n        if (err == false) {\n            //if zero we've try to use max as possible of available tokens\n            if (tradedTokenAmount == 0) {\n                tradedTokenAmount = tradedReserve2 - tradedReserve1;\n            }\n\n            (rTraded, rReserved, traded2Swap, traded2Liq, reserved2Liq) = _calculateSellTradedAndLiquidity(\n                tradedTokenAmount\n            );\n\n            averageWithPriceDrop = (\n                FixedPoint\n                    .uq112x112(uint224(priceAverageData))\n                    .muluq(FixedPoint.encode(uint112(uint256(FRACTION) - priceDrop)))\n                    .muluq(FixedPoint.fraction(1, FRACTION))\n            );\n\n            // \"new_current_price\" should be more than \"average_price(1-price_drop)\"\n            if (\n                FixedPoint.fraction(rReserved, rTraded + traded2Swap + traded2Liq)._x <=\n                // (\n                //     FixedPoint.uq112x112(uint224(priceAverageData)).muluq(FixedPoint.encode(uint112(uint256(FRACTION) - priceDrop))).muluq(FixedPoint.fraction(1, FRACTION))\n                // )._x\n                averageWithPriceDrop._x\n            ) {\n                err = true;\n            }\n        }\n\n        require(err == false, \"PRICE_DROP_TOO_BIG\");\n\n        // trade trade tokens and add liquidity\n        _doSellTradedAndLiquidity(traded2Swap, traded2Liq);\n\n        emit AddedLiquidity(tradedTokenAmount, priceAverageData);\n\n        update();\n    }\n\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        if (uniswapV2Pair == recipient) {\n            uint256 taxAmount = (amount * sellTax) / FRACTION;\n            if (taxAmount != 0) {\n                amount -= taxAmount;\n                _burn(holder, taxAmount, \"\", \"\");\n            }\n        }\n        return super.transferFrom(holder, recipient, amount);\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        //address from = _msgSender();\n\n        // inject into transfer and burn tax from sender\n        // two ways:\n        // 1. make calculations, burn taxes from sender and do transaction with substracted values\n        if (uniswapV2Pair == _msgSender()) {\n            uint256 taxAmount = (amount * buyTax) / FRACTION;\n\n            if (taxAmount != 0) {\n                amount -= taxAmount;\n                _burn(_msgSender(), taxAmount, \"\", \"\");\n            }\n        }\n        return super.transfer(recipient, amount);\n\n        // 2. do usual transaction, then make calculation and burn tax from sides(buyer or seller)\n        // we DON'T USE this case, because have callbacks in _move method: _callTokensToSend and _callTokensReceived\n        // and than be send to some1 else in recipient contract callback\n    }\n\n    ////////////////////////////////////////////////////////////////////////\n    // internal section ////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////\n\n    // need to run immedialety after adding liquidity tx and sync cumulativePrice. BUT i's can't applicable if do in the same trasaction with addInitialLiquidity.\n    // reserve0 and reserve1 still zero and\n    function singlePairSync() internal {\n        if (alreadyRunStartupSync == false) {\n            alreadyRunStartupSync = true;\n            IUniswapV2Pair(uniswapV2Pair).sync();\n            //console.log(\"singlePairSync - synced\");\n        } else {\n            //console.log(\"singlePairSync - ALREADY synced\");\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address, /*operator*/\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if (\n            // if minted\n            (from == address(0)) ||\n            // or burnt itself\n            (from == address(this) && to == address(0)) // ||\n        ) {\n            //skip validation\n        } else {\n            uint256 balance = balanceOf(from);\n            uint256 locked = tokensLocked[from]._getMinimum();\n            require(balance - locked >= amount, \"INSUFFICIENT_AMOUNT\");\n        }\n    }\n\n    /**\n     * @notice helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**64 - 1]\n     */\n    function currentBlockTimestamp() internal view returns (uint64) {\n        return uint64(block.timestamp % 2**64);\n    }\n\n    /**\n     * @notice wrapper for getting uniswap reserves function. we use `token01` var here to be sure that reserve0 and token0 are always traded token data\n     */\n    function _uniswapReserves()\n        internal\n        view\n        returns (\n            // reserveTraded, reserveReserved, blockTimestampLast\n            uint112,\n            uint112,\n            uint32\n        )\n    {\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(uniswapV2Pair).getReserves();\n        require(reserve0 != 0 && reserve1 != 0, \"RESERVES_EMPTY\");\n\n        if (token01) {\n            return (reserve0, reserve1, blockTimestampLast);\n        } else {\n            return (reserve1, reserve0, blockTimestampLast);\n        }\n    }\n\n    /**\n    * @notice \n        validate params when user claims\n        here we should simulate swap totalCumulativeClaimed to reserve token and check price\n        price should be less than minClaimPrice\n    */\n    function _validateClaim(uint256 tradedTokenAmount) internal view {\n        (uint112 _reserve0, uint112 _reserve1, ) = IUniswapV2Pair(uniswapV2Pair).getReserves();\n        uint256 currentIterationTotalCumulativeClaimed = totalCumulativeClaimed + tradedTokenAmount;\n        // amountin reservein reserveout\n        uint256 amountOut = IUniswapV2Router02(uniswapRouter).getAmountOut(\n            currentIterationTotalCumulativeClaimed,\n            _reserve0,\n            _reserve1\n        );\n\n        require(amountOut > 0, \"CLAIM_VALIDATION_ERROR\");\n\n        require(\n            FixedPoint.fraction(_reserve1 - amountOut, _reserve0 + currentIterationTotalCumulativeClaimed)._x >\n                FixedPoint.fraction(minClaimPrice.numerator, minClaimPrice.denominator)._x,\n            \"PRICE_HAS_BECOME_A_LOWER_THAN_MINCLAIMPRICE\"\n        );\n    }\n\n    /**\n     * @notice do claim to the `account` and locked tokens if\n     */\n    function _claim(uint256 tradedTokenAmount, address account) internal {\n        totalCumulativeClaimed += tradedTokenAmount;\n\n        _mint(account, tradedTokenAmount, \"\", \"\");\n\n        // lockup tokens for any except:\n        // - owner(because it's owner)\n        // - current contract(because do sell traded tokens and add liquidity)\n        if (_msgSender() != owner() && _msgSender() != address(this)) {\n            tokensLocked[account]._minimumsAdd(tradedTokenAmount, lockupIntervalAmount, LOCKUP_INTERVAL, true);\n        }\n    }\n\n    //\n    /**\n     * @notice do swap for internal liquidity contract\n     */\n    function doSwapOnUniswap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address beneficiary\n    ) internal returns (uint256 amountOut) {\n        require(ERC777(tokenIn).approve(address(uniswapRouter), amountIn), \"APPROVE_FAILED\");\n\n        address[] memory path = new address[](2);\n        path[0] = address(tokenIn);\n        path[1] = address(tokenOut);\n        // amountOutMin is set to 0, so only do this with pairs that have deep liquidity\n\n        uint256[] memory outputAmounts = IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(\n            amountIn,\n            0,\n            path,\n            beneficiary,\n            block.timestamp\n        );\n\n        amountOut = outputAmounts[1];\n    }\n\n    /**\n     * @notice\n     */\n    function tradedAveragePrice() internal view returns (FixedPoint.uq112x112 memory) {\n        uint64 blockTimestamp = currentBlockTimestamp();\n        uint256 price0Cumulative = IUniswapV2Pair(uniswapV2Pair).price0CumulativeLast();\n        uint64 timeElapsed = blockTimestamp - pairObservation.timestampLast;\n        uint64 windowSize = ((blockTimestamp - startupTimestamp) * averagePriceWindow) / FRACTION;\n\n        if (timeElapsed > windowSize && timeElapsed > 0 && price0Cumulative > pairObservation.price0CumulativeLast) {\n            // console.log(\"timeElapsed > windowSize && timeElapsed>0\");\n            // console.log(\"price0Cumulative                       =\", price0Cumulative);\n            // console.log(\"pairObservation.price0CumulativeLast   =\", pairObservation.price0CumulativeLast);\n            // console.log(\"timeElapsed                            =\", timeElapsed);\n            return\n                FixedPoint.uq112x112(\n                    uint224(price0Cumulative - pairObservation.price0CumulativeLast) / uint224(timeElapsed)\n                );\n        } else {\n            //use stored\n            return pairObservation.price0Average;\n        }\n    }\n\n    function update() internal {\n        uint64 blockTimestamp = currentBlockTimestamp();\n        uint64 timeElapsed = blockTimestamp - pairObservation.timestampLast;\n\n        uint64 windowSize = ((blockTimestamp - startupTimestamp) * averagePriceWindow) / FRACTION;\n\n        if (timeElapsed > windowSize && timeElapsed > 0) {\n            uint256 price0Cumulative = IUniswapV2Pair(uniswapV2Pair).price0CumulativeLast();\n\n            pairObservation.price0Average = FixedPoint\n                .uq112x112(uint224(price0Cumulative - pairObservation.price0CumulativeLast))\n                .divuq(FixedPoint.encode(timeElapsed));\n            pairObservation.price0CumulativeLast = price0Cumulative;\n\n            pairObservation.timestampLast = blockTimestamp;\n        }\n    }\n\n    function _calculateSellTradedAndLiquidity(uint256 incomingTradedToken)\n        internal\n        view\n        returns (\n            uint256 rTraded,\n            uint256 rReserved,\n            uint256 traded2Swap,\n            uint256 traded2Liq,\n            uint256 reserved2Liq\n        )\n    {\n        (\n            rTraded,\n            rReserved, /*uint256 priceTraded*/\n\n        ) = _uniswapReserves();\n\n        traded2Swap = sqrt((rTraded + incomingTradedToken) * (rTraded)) - rTraded; //\n        require(traded2Swap > 0 && incomingTradedToken > traded2Swap, \"BAD_AMOUNT\");\n\n        reserved2Liq = IUniswapV2Router02(uniswapRouter).getAmountOut(traded2Swap, rTraded, rReserved);\n        traded2Liq = incomingTradedToken - traded2Swap;\n    }\n\n    function _doSellTradedAndLiquidity(uint256 traded2Swap, uint256 traded2Liq) internal {\n        // claim to address(this) necessary amount to swap from traded to reserved tokens\n        _mint(address(this), traded2Swap, \"\", \"\");\n        doSwapOnUniswap(tradedToken, reserveToken, traded2Swap, address(internalLiquidity));\n\n        // mint that left to  internalLiquidity contract\n        _mint(address(internalLiquidity), traded2Liq, \"\", \"\");\n\n        // add to liquidity from there\n        internalLiquidity.addLiquidity();\n    }\n\n    function _maxAddLiquidity()\n        internal\n        view\n        returns (\n            //      traded1 -> traded2->priceAverageData\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // tradedNew = Math.sqrt(@tokenPair.r0 * @tokenPair.r1 / (average_price*(1-@price_drop)))\n\n        uint112 reserve0;\n        uint112 reserve1;\n        uint32 blockTimestampLast;\n\n        (reserve0, reserve1, blockTimestampLast) = _uniswapReserves();\n\n        FixedPoint.uq112x112 memory priceAverageData = tradedAveragePrice();\n\n        FixedPoint.uq112x112 memory q1 = FixedPoint.encode(uint112(sqrt(reserve0)));\n        FixedPoint.uq112x112 memory q2 = FixedPoint.encode(uint112(sqrt(reserve1)));\n        FixedPoint.uq112x112 memory q3 = (\n            priceAverageData.muluq(FixedPoint.encode(uint112(uint256(FRACTION) - priceDrop))).muluq(\n                FixedPoint.fraction(1, FRACTION)\n            )\n        ).sqrt();\n        //FixedPoint.uq112x112 memory q4 = FixedPoint.encode(uint112(1)).divuq(q3);\n\n        //traded1*reserve1/(priceaverage*pricedrop)\n\n        //traded1 * reserve1*(1/(priceaverage*pricedrop))\n\n        uint256 reserve0New = (\n            q1.muluq(q2).muluq(FixedPoint.encode(uint112(sqrt(FRACTION)))).muluq(\n                FixedPoint.encode(uint112(1)).divuq(q3)\n            )\n        ).decode();\n\n        return (reserve0, reserve0New, priceAverageData._x);\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n        // Calculate the square root of the perfect square of a\n        // power of two that is the closest to x.\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n        // The operations can never overflow because the result is\n        // max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/ERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/IERC1820Registry.sol\";\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using Address for address;\n\n    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    mapping(address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // ERC20-allowances\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address[] memory defaultOperators_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n\n        _defaultOperatorsArray = defaultOperators_;\n        for (uint256 i = 0; i < defaultOperators_.length; i++) {\n            _defaultOperators[defaultOperators_[i]] = true;\n        }\n\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view virtual override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n        address from = _msgSender();\n\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n        _move(from, from, recipient, amount, \"\", \"\");\n\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes memory data) public virtual override {\n        _burn(_msgSender(), amount, data, \"\");\n    }\n\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {\n        return\n            operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) public virtual override {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) public virtual override {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view virtual override returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {IERC20-Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {IERC20-Transfer} events.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender) public view virtual override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators cannot\n     * call `transferFrom` (unless they have allowance), and accounts with\n     * allowance cannot call `operatorSend` (unless they are operators).\n     *\n     * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\n\n        address spender = _msgSender();\n\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\n        _move(spender, holder, recipient, amount, \"\", \"\");\n\n        uint256 currentAllowance = _allowances[holder][spender];\n        require(currentAllowance >= amount, \"ERC777: transfer amount exceeds allowance\");\n        _approve(holder, spender, currentAllowance - amount);\n\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) internal virtual {\n        _mint(account, amount, userData, operatorData, true);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If `requireReceptionAck` is set to true, and if a send hook is\n     * registered for `account`, the corresponding function will be called with\n     * `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(account != address(0), \"ERC777: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, amount);\n\n        // Update state variables\n        _totalSupply += amount;\n        _balances[account] += amount;\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, requireReceptionAck);\n\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Send tokens\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(from != address(0), \"ERC777: send from the zero address\");\n        require(to != address(0), \"ERC777: send to the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) internal virtual {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        _beforeTokenTransfer(operator, from, address(0), amount);\n\n        // Update state variables\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: burn amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        _beforeTokenTransfer(operator, from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @dev See {ERC20-_approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 value\n    ) internal {\n        require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n * their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(\n        address account,\n        bytes32 _interfaceHash,\n        address implementer\n    ) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/libs/SwapSettingsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nlibrary SwapSettingsLib {\n    function netWorkSettings(\n    )\n        internal\n        view\n        returns(address, address)\n    {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        if ((chainId == 0x1) || (chainId == 0x3) || (chainId == 0x4) || (chainId == 0x539) || (chainId == 0x7a69)) {  //+ localganache chainId, used for fork \n            // Ethereum-Uniswap\n            return( \n                0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, //uniswapRouter\n                0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f  //uniswapRouterFactory\n            );\n        } else if(chainId == 0x89) {\n            // Matic-QuickSwap\n            return( \n                0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff, //uniswapRouter\n                0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32  //uniswapRouterFactory\n            );\n        } else if(chainId == 0x38) {\n            // Binance-PancakeSwap\n            return( \n                0x10ED43C718714eb63d5aA57B78B54704E256024E, //uniswapRouter\n                0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73  //uniswapRouterFactory\n            );\n        } else {\n            revert(\"unsupported chain\");\n        }\n    }\n\n}"
    },
    "contracts/libs/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport './FullMath.sol';\nimport './Babylonian.sol';\nimport './BitMath.sol';\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 public constant RESOLUTION = 112;\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\n        return uq144x112(z);\n    }\n\n    // multiply a UQ112x112 by an int and decode, returning an int\n    // reverts on overflow\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n        require(z < 2**255, 'FixedPoint::muli: overflow');\n        return y < 0 ? -int256(z) : int256(z);\n    }\n\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n    // lossy\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        if (self._x == 0 || other._x == 0) {\n            return uq112x112(0);\n        }\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n\n        // partial products\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n        // so the bit shift does not overflow\n        require(upper <= type(uint112).max, 'FixedPoint::muluq: upper overflow');\n\n        // this cannot exceed 256 bits, all values are 224 bits\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n\n        // so the cast does not overflow\n        require(sum <= type(uint224).max, 'FixedPoint::muluq: sum overflow');\n\n        return uq112x112(uint224(sum));\n    }\n\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        require(other._x > 0, 'FixedPoint::divuq: division by zero');\n        if (self._x == other._x) {\n            return uq112x112(uint224(Q112));\n        }\n        if (self._x <= type(uint144).max) {\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n            require(value <= type(uint224).max, 'FixedPoint::divuq: overflow');\n            return uq112x112(uint224(value));\n        }\n\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n        require(result <= type(uint224).max, 'FixedPoint::divuq: overflow');\n        return uq112x112(uint224(result));\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // can be lossy\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= type(uint144).max) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <=type(uint224).max, 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= type(uint224).max, 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        }\n    }\n\n    // take the reciprocal of a UQ112x112\n    // reverts on overflow\n    // lossy\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\n        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        if (self._x <= type(uint144).max) {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n    }\n}\n"
    },
    "contracts/minimums/libs/MinimumsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nlibrary MinimumsLib {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    //address internal constant ZERO_ADDRESS = address(0);\n\n    struct Minimum {\n     //   uint256 timestampStart; //ts start no need \n        //uint256 timestampEnd;   //ts end\n        uint256 speedGradualUnlock;    \n        uint256 amountGradualWithdrawn;\n        //uint256 amountGradual;\n        uint256 amountNoneGradual;\n        //bool gradual;\n    }\n\n    struct Lockup {\n        uint64 duration;\n        //bool gradual; // does not used \n        bool exists;\n    }\n\n    struct UserStruct {\n        EnumerableSetUpgradeable.UintSet minimumsIndexes;\n        mapping(uint256 => Minimum) minimums;\n        //mapping(uint256 => uint256) dailyAmounts;\n        Lockup lockup;\n    }\n\n\n      /**\n    * @dev adding minimum holding at sender during period from now to timestamp.\n    *\n    * @param amount amount.\n    * @param intervalCount duration in count of intervals defined before\n    * @param gradual true if the limitation can gradually decrease\n    */\n    function _minimumsAdd(\n        UserStruct storage _userStruct,\n        uint256 amount, \n        uint256 intervalCount,\n        uint64 interval,\n        bool gradual\n    ) \n        // public \n        // onlyOwner()\n        internal\n        returns (bool)\n    {\n        uint256 timestampStart = getIndexInterval(block.timestamp, interval);\n        uint256 timestampEnd = timestampStart + (intervalCount * interval);\n        require(timestampEnd > timestampStart, \"TIMESTAMP_INVALID\");\n        \n        _minimumsClear(_userStruct, interval, false);\n        \n        _minimumsAddLow(_userStruct, timestampStart, timestampEnd, amount, gradual);\n    \n        return true;\n        \n    }\n    \n    /**\n     * @dev removes all minimums from this address\n     * so all tokens are unlocked to send\n     *  UserStruct which should be clear restrict\n     */\n    function _minimumsClear(\n        UserStruct storage _userStruct,\n        uint64 interval\n    )\n        internal\n        returns (bool)\n    {\n        return _minimumsClear(_userStruct, interval, true);\n    }\n    \n    /**\n     * from will add automatic lockup for destination address sent address from\n     * @param duration duration in count of intervals defined before\n     */\n    function _automaticLockupAdd(\n        UserStruct storage _userStruct,\n        uint64 duration,\n        uint64 interval\n    )\n        internal\n    {\n        _userStruct.lockup.duration = duration * interval;\n        _userStruct.lockup.exists = true;\n    }\n    \n    /**\n     * remove automaticLockup from UserStruct\n     */\n    function _automaticLockupRemove(\n        UserStruct storage _userStruct\n    )\n        internal\n    {\n        _userStruct.lockup.exists = false;\n    }\n    \n    /**\n    * @dev get sum minimum and sum gradual minimums from address for period from now to timestamp.\n    *\n    */\n    function _getMinimum(\n        UserStruct storage _userStruct\n    ) \n        internal \n        view\n        returns (uint256 amountLocked) \n    {\n        \n        uint256 mapIndex;\n        uint256 tmp;\n        for (uint256 i=0; i<_userStruct.minimumsIndexes.length(); i++) {\n            mapIndex = _userStruct.minimumsIndexes.at(i);\n            \n            if (block.timestamp <= mapIndex) { // block.timestamp<timestampEnd\n                tmp = _userStruct.minimums[mapIndex].speedGradualUnlock * (mapIndex - block.timestamp);\n                \n                amountLocked = amountLocked +\n                                    (\n                                        tmp < _userStruct.minimums[mapIndex].amountGradualWithdrawn \n                                        ? \n                                        0 \n                                        : \n                                        tmp - (_userStruct.minimums[mapIndex].amountGradualWithdrawn)\n                                    ) +\n                                    (_userStruct.minimums[mapIndex].amountNoneGradual);\n            }\n        }\n    }\n\n    function _getMinimumList(\n        UserStruct storage _userStruct\n    ) \n        internal \n        view\n        returns (uint256[][] memory ) \n    {\n        \n        uint256 mapIndex;\n        uint256 tmp;\n        uint256 len = _userStruct.minimumsIndexes.length();\n\n        uint256[][] memory ret = new uint256[][](len);\n\n\n        for (uint256 i=0; i<len; i++) {\n            mapIndex = _userStruct.minimumsIndexes.at(i);\n            \n            if (block.timestamp <= mapIndex) { // block.timestamp<timestampEnd\n                tmp = _userStruct.minimums[mapIndex].speedGradualUnlock * (mapIndex - block.timestamp);\n                ret[i] = new uint256[](2);\n                ret[i][1] = mapIndex;\n                ret[i][0] = (\n                                tmp < _userStruct.minimums[mapIndex].amountGradualWithdrawn \n                                ? \n                                0 \n                                : \n                                tmp - _userStruct.minimums[mapIndex].amountGradualWithdrawn\n                            ) +\n                            _userStruct.minimums[mapIndex].amountNoneGradual;\n            }\n        }\n\n        return ret;\n    }\n    \n    /**\n    * @dev clear expired items from mapping. used while addingMinimum\n    *\n    * @param deleteAnyway if true when delete items regardless expired or not\n    */\n    function _minimumsClear(\n        UserStruct storage _userStruct,\n        uint64 interval,\n        bool deleteAnyway\n    ) \n        internal \n        returns (bool) \n    {\n        uint256 mapIndex = 0;\n        uint256 len = _userStruct.minimumsIndexes.length();\n        if (len > 0) {\n            for (uint256 i=len; i>0; i--) {\n                mapIndex = _userStruct.minimumsIndexes.at(i-1);\n                if (\n                    (deleteAnyway == true) ||\n                    (getIndexInterval(block.timestamp, interval) > mapIndex)\n                ) {\n                    delete _userStruct.minimums[mapIndex];\n                    _userStruct.minimumsIndexes.remove(mapIndex);\n                }\n                \n            }\n        }\n        return true;\n    }\n\n\n        \n    /**\n     * added minimum if not exist by timestamp else append it\n     * @param _userStruct destination user\n     * @param timestampStart if empty get current interval or currente time. Using only for calculate gradual\n     * @param timestampEnd \"until time\"\n     * @param amount amount\n     * @param gradual if true then lockup are gradually\n     */\n    //function _appendMinimum(\n    function _minimumsAddLow(\n        UserStruct storage _userStruct,\n        uint256 timestampStart, \n        uint256 timestampEnd, \n        uint256 amount, \n        bool gradual\n    )\n        private\n    {\n        _userStruct.minimumsIndexes.add(timestampEnd);\n        if (gradual == true) {\n            // gradual\n            _userStruct.minimums[timestampEnd].speedGradualUnlock = _userStruct.minimums[timestampEnd].speedGradualUnlock + \n                (\n                amount / (timestampEnd - timestampStart)\n                );\n            //_userStruct.minimums[timestamp].amountGradual = _userStruct.minimums[timestamp].amountGradual.add(amount);\n        } else {\n            // none-gradual\n            _userStruct.minimums[timestampEnd].amountNoneGradual = _userStruct.minimums[timestampEnd].amountNoneGradual + amount;\n        }\n    }\n    \n    /**\n     * @dev reduce minimum by value  otherwise remove it \n     * @param _userStruct destination user struct\n     * @param timestampEnd \"until time\"\n     * @param value amount\n     */\n    function _reduceMinimum(\n        UserStruct storage _userStruct,\n        uint256 timestampEnd, \n        uint256 value,\n        bool gradual\n    )\n        internal\n    {\n        \n        if (_userStruct.minimumsIndexes.contains(timestampEnd) == true) {\n            \n            if (gradual == true) {\n                \n                _userStruct.minimums[timestampEnd].amountGradualWithdrawn = _userStruct.minimums[timestampEnd].amountGradualWithdrawn + value;\n                \n                uint256 left = (_userStruct.minimums[timestampEnd].speedGradualUnlock) * (timestampEnd - block.timestamp);\n                if (left <= _userStruct.minimums[timestampEnd].amountGradualWithdrawn) {\n                    _userStruct.minimums[timestampEnd].speedGradualUnlock = 0;\n                    // delete _userStruct.minimums[timestampEnd];\n                    // _userStruct.minimumsIndexes.remove(timestampEnd);\n                }\n            } else {\n                if (_userStruct.minimums[timestampEnd].amountNoneGradual > value) {\n                    _userStruct.minimums[timestampEnd].amountNoneGradual = _userStruct.minimums[timestampEnd].amountNoneGradual - value;\n                } else {\n                    _userStruct.minimums[timestampEnd].amountNoneGradual = 0;\n                    // delete _userStruct.minimums[timestampEnd];\n                    // _userStruct.minimumsIndexes.remove(timestampEnd);\n                }\n                    \n            }\n            \n            if (\n                _userStruct.minimums[timestampEnd].speedGradualUnlock == 0 &&\n                _userStruct.minimums[timestampEnd].amountNoneGradual == 0\n            ) {\n                delete _userStruct.minimums[timestampEnd];\n                _userStruct.minimumsIndexes.remove(timestampEnd);\n            }\n                \n                \n            \n        }\n    }\n    \n    /**\n     * \n     \n     * @param value amount\n     */\n    function minimumsTransfer(\n        UserStruct storage _userStructFrom, \n        UserStruct storage _userStructTo, \n        bool isTransferToZeroAddress,\n        //address to,\n        uint256 value\n    )\n        internal\n    {\n        \n\n        uint256 len = _userStructFrom.minimumsIndexes.length();\n        uint256[] memory _dataList;\n        //uint256 recieverTimeLeft;\n    \n        if (len > 0) {\n            _dataList = new uint256[](len);\n            for (uint256 i=0; i<len; i++) {\n                _dataList[i] = _userStructFrom.minimumsIndexes.at(i);\n            }\n            _dataList = sortAsc(_dataList);\n            \n            uint256 iValue;\n            uint256 tmpValue;\n        \n            for (uint256 i=0; i<len; i++) {\n                \n                if (block.timestamp <= _dataList[i]) {\n                    \n                    // try move none-gradual\n                    if (value >= _userStructFrom.minimums[_dataList[i]].amountNoneGradual) {\n                        iValue = _userStructFrom.minimums[_dataList[i]].amountNoneGradual;\n                        value = value - iValue;\n                    } else {\n                        iValue = value;\n                        value = 0;\n                    }\n                    \n                    // remove from sender\n                    _reduceMinimum(\n                        _userStructFrom,\n                        _dataList[i],//timestampEnd,\n                        iValue,\n                        false\n                    );\n\n                    // shouldn't add miniums for zero account.\n                    // that feature using to drop minimums from sender\n                    //if (to != ZERO_ADDRESS) {\n                    if (!isTransferToZeroAddress) {\n                        _minimumsAddLow(_userStructTo, block.timestamp, _dataList[i], iValue, false);\n                    }\n                    \n                    if (value == 0) {\n                        break;\n                    }\n                    \n                    \n                    // try move gradual\n                    \n                    // amount left in current minimums\n                    tmpValue = _userStructFrom.minimums[_dataList[i]].speedGradualUnlock * (_dataList[i] - block.timestamp);\n                        \n                        \n                    if (value >= tmpValue) {\n                        iValue = tmpValue;\n                        value = value - tmpValue;\n\n                    } else {\n                        iValue = value;\n                        value = 0;\n                    }\n                    // remove from sender\n                    _reduceMinimum(\n                        _userStructFrom,\n                        _dataList[i],//timestampEnd,\n                        iValue,\n                        true\n                    );\n                    // uint256 speed = iValue.div(\n                        //     users[from].minimums[_dataList[i]].timestampEnd.sub(block.timestamp);\n                        // );\n\n                    // shouldn't add miniums for zero account.\n                    // that feature using to drop minimums from sender\n                    //if (to != ZERO_ADDRESS) {\n                    if (!isTransferToZeroAddress) {\n                        _minimumsAddLow(_userStructTo, block.timestamp, _dataList[i], iValue, true);\n                    }\n                    if (value == 0) {\n                        break;\n                    }\n                    \n\n\n                } // if (block.timestamp <= users[from].minimums[_dataList[i]].timestampEnd) {\n            } // end for\n            \n   \n        }\n        \n        // if (value != 0) {\n            // todo 0: what this?\n            // _appendMinimum(\n            //     to,\n            //     block.timestamp,//block.timestamp.add(minTimeDiff),\n            //     value,\n            //     false\n            // );\n        // }\n     \n        \n    }\n\n    /**\n    * @dev gives index interval. here we deliberately making a loss precision(div before mul) to get the same index during interval.\n    * @param ts unixtimestamp\n    */\n    function getIndexInterval(uint256 ts, uint64 interval) internal pure returns(uint256) {\n        return ts / interval * interval;\n    }\n    \n    // useful method to sort native memory array \n    function sortAsc(uint256[] memory data) private returns(uint[] memory) {\n       quickSortAsc(data, int(0), int(data.length - 1));\n       return data;\n    }\n    \n    function quickSortAsc(uint[] memory arr, int left, int right) private {\n        int i = left;\n        int j = right;\n        if(i==j) return;\n        uint pivot = arr[uint(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint(i)] < pivot) i++;\n            while (pivot < arr[uint(j)]) j--;\n            if (i <= j) {\n                (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\n                i++;\n                j--;\n            }\n        }\n        if (left < j)\n            quickSortAsc(arr, left, j);\n        if (i < right)\n            quickSortAsc(arr, i, right);\n    }\n\n \n\n\n}"
    },
    "contracts/ExecuteManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ExecuteManager {\n    uint8 private runOnlyOnceFlag;\n\n    modifier runOnlyOnce() {\n        require(runOnlyOnceFlag < 1, \"already called\");\n        runOnlyOnceFlag = 1;\n        _;\n    }\n}\n"
    },
    "contracts/Liquidity.sol": {
      "content": "// SPDX-License-Identifier: AGPL\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\n//import \"hardhat/console.sol\";\n\ncontract Liquidity is IERC777Recipient {\n    address internal immutable token0;\n    address internal immutable token1;\n    address internal immutable uniswapRouter;\n    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n    constructor(\n        address token0_,\n        address token1_,\n        address uniswapRouter_\n    ) {\n        token0 = token0_;\n        token1 = token1_;\n        uniswapRouter = uniswapRouter_;\n\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n    }\n\n    /**\n     * adding liquidity for all available balance\n     */\n    function addLiquidity() external {\n        uint256 token0Amount = IERC20(token0).balanceOf(address(this));\n        uint256 token1Amount = IERC20(token1).balanceOf(address(this));\n\n        _addLiquidity(token0Amount, token1Amount);\n    }\n\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external {}\n\n    /**\n     * approve tokens to uniswap router obtain LP tokens and move to zero address\n     */\n    function _addLiquidity(uint256 token0Amount, uint256 token1Amount) internal {\n        IERC20(token0).approve(address(uniswapRouter), token0Amount);\n        IERC20(token1).approve(address(uniswapRouter), token1Amount);\n\n        //(/* uint256 A*/, /*uint256 B*/, /*uint256 lpTokens*/) =\n        IUniswapV2Router02(uniswapRouter).addLiquidity(\n            token0,\n            token1,\n            token0Amount,\n            token1Amount,\n            0, // there may be some slippage\n            0, // there may be some slippage\n            address(0),\n            block.timestamp\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/libs/FullMath.sol": {
      "content": "// SPDX-License-Identifier: CC-BY-4.0\npragma solidity >=0.8.0;\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, type(uint256).max);\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        //uint256 pow2 = d & -d;\n        uint256 pow2 = d & (~d + 1);\n\n        d /= pow2;\n        l /= pow2;\n        //l += h * ((-pow2) / pow2 + 1);\n        l += h * ((~pow2+1) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n\n        if (h == 0) return l / d;\n\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\n        return fullDiv(l, h, d);\n    }\n}\n"
    },
    "contracts/libs/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "contracts/libs/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nlibrary BitMath {\n    // returns the 0 indexed position of the most significant bit of the input x\n    // s.t. x >= 2**msb and x < 2**(msb+1)\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    // returns the 0 indexed position of the least significant bit of the input x\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::leastSignificantBit: zero');\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint8).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}