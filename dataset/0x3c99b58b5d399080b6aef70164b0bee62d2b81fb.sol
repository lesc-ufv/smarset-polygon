{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/univ2/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IUniswapV2Factory {\n    function getPair(address token0, address token1) external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/univ2/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IUniswapV2Pair {\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/oracles/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOracle {\n    /// @notice Oracle price for tokens.\n    /// @dev The price is token1 / token0 i.e. how many weis of token1 required for 1 wei of token0.\n    /// The safety indexes are:\n    ///\n    /// 1 - unsafe, this is typically a spot price that can be easily manipulated,\n    ///\n    /// 2 - 4 - more or less safe, this is typically a uniV3 oracle, where the safety is defined by the timespan of the average price\n    ///\n    /// 5 - safe - this is typically a chailink oracle\n    /// @param token0 Reference to token0\n    /// @param token1 Reference to token1\n    /// @param safetyIndicesSet Bitmask of safety indices that are allowed for the return prices\n    /// @return pricesX96 Prices that satisfy safetyIndex and tokens\n    /// @return safetyIndices Safety indices for those prices\n    function price(\n        address token0,\n        address token1,\n        uint256 safetyIndicesSet\n    ) external view returns (uint256[] memory pricesX96, uint256[] memory safetyIndices);\n}\n"
    },
    "contracts/interfaces/oracles/IUniV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: BSL-1.1\npragma solidity 0.8.9;\n\nimport \"../external/univ2/IUniswapV2Factory.sol\";\nimport \"./IOracle.sol\";\n\ninterface IUniV2Oracle is IOracle {\n    /// @notice Reference to UniV2 factory\n    function factory() external returns (IUniswapV2Factory);\n\n    /// @notice Index of safety bit\n    function safetyIndex() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/utils/IContractMeta.sol": {
      "content": "// SPDX-License-Identifier: BSL-1.1\npragma solidity 0.8.9;\n\ninterface IContractMeta {\n    function contractName() external view returns (string memory);\n    function contractNameBytes() external view returns (bytes32);\n\n    function contractVersion() external view returns (string memory);\n    function contractVersionBytes() external view returns (bytes32);\n}\n"
    },
    "contracts/libraries/CommonLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./external/FullMath.sol\";\nimport \"./ExceptionsLibrary.sol\";\n\n/// @notice CommonLibrary shared utilities\nlibrary CommonLibrary {\n    uint256 constant DENOMINATOR = 10**9;\n    uint256 constant D18 = 10**18;\n    uint256 constant YEAR = 365 * 24 * 3600;\n    uint256 constant Q128 = 2**128;\n    uint256 constant Q96 = 2**96;\n    uint256 constant Q48 = 2**48;\n    uint256 constant Q160 = 2**160;\n    uint256 constant UNI_FEE_DENOMINATOR = 10**6;\n\n    /// @notice Sort uint256 using bubble sort. The sorting is done in-place.\n    /// @param arr Array of uint256\n    function sortUint(uint256[] memory arr) internal pure {\n        uint256 l = arr.length;\n        for (uint256 i = 0; i < l; ++i) {\n            for (uint256 j = i + 1; j < l; ++j) {\n                if (arr[i] > arr[j]) {\n                    uint256 temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n    }\n\n    /// @notice Checks if array of addresses is sorted and all adresses are unique\n    /// @param tokens A set of addresses to check\n    /// @return `true` if all addresses are sorted and unique, `false` otherwise\n    function isSortedAndUnique(address[] memory tokens) internal pure returns (bool) {\n        if (tokens.length < 2) {\n            return true;\n        }\n        for (uint256 i = 0; i < tokens.length - 1; ++i) {\n            if (tokens[i] >= tokens[i + 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Projects tokenAmounts onto subset or superset of tokens\n    /// @dev\n    /// Requires both sets of tokens to be sorted. When tokens are not sorted, it's undefined behavior.\n    /// If there is a token in tokensToProject that is not part of tokens and corresponding tokenAmountsToProject > 0, reverts.\n    /// Zero token amount is eqiuvalent to missing token\n    function projectTokenAmounts(\n        address[] memory tokens,\n        address[] memory tokensToProject,\n        uint256[] memory tokenAmountsToProject\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory res = new uint256[](tokens.length);\n        uint256 t = 0;\n        uint256 tp = 0;\n        while ((t < tokens.length) && (tp < tokensToProject.length)) {\n            if (tokens[t] < tokensToProject[tp]) {\n                res[t] = 0;\n                t++;\n            } else if (tokens[t] > tokensToProject[tp]) {\n                if (tokenAmountsToProject[tp] == 0) {\n                    tp++;\n                } else {\n                    revert(\"TPS\");\n                }\n            } else {\n                res[t] = tokenAmountsToProject[tp];\n                t++;\n                tp++;\n            }\n        }\n        while (t < tokens.length) {\n            res[t] = 0;\n            t++;\n        }\n        return res;\n    }\n\n    /// @notice Calculated sqrt of uint in X96 format\n    /// @param xX96 input number in X96 format\n    /// @return sqrt of xX96 in X96 format\n    function sqrtX96(uint256 xX96) internal pure returns (uint256) {\n        uint256 sqX96 = sqrt(xX96);\n        return sqX96 << 48;\n    }\n\n    /// @notice Calculated sqrt of uint\n    /// @param x input number\n    /// @return sqrt of x\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n\n    /// @notice Recovers signer address from signed message hash\n    /// @param _ethSignedMessageHash signed message\n    /// @param _signature contatenated ECDSA r, s, v (65 bytes)\n    /// @return Recovered address if the signature is valid, address(0) otherwise\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    /// @notice Get ECDSA r, s, v from signature\n    /// @param sig signature (65 bytes)\n    /// @return r ECDSA r\n    /// @return s ECDSA s\n    /// @return v ECDSA v\n    function splitSignature(bytes memory sig)\n        internal\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        require(sig.length == 65, ExceptionsLibrary.INVALID_LENGTH);\n\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n    }\n}\n"
    },
    "contracts/libraries/ExceptionsLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\n/// @notice Exceptions stores project`s smart-contracts exceptions\nlibrary ExceptionsLibrary {\n    string constant ADDRESS_ZERO = \"AZ\";\n    string constant VALUE_ZERO = \"VZ\";\n    string constant EMPTY_LIST = \"EMPL\";\n    string constant NOT_FOUND = \"NF\";\n    string constant INIT = \"INIT\";\n    string constant DUPLICATE = \"DUP\";\n    string constant NULL = \"NULL\";\n    string constant TIMESTAMP = \"TS\";\n    string constant FORBIDDEN = \"FRB\";\n    string constant ALLOWLIST = \"ALL\";\n    string constant LIMIT_OVERFLOW = \"LIMO\";\n    string constant LIMIT_UNDERFLOW = \"LIMU\";\n    string constant INVALID_VALUE = \"INV\";\n    string constant INVARIANT = \"INVA\";\n    string constant INVALID_TARGET = \"INVTR\";\n    string constant INVALID_TOKEN = \"INVTO\";\n    string constant INVALID_INTERFACE = \"INVI\";\n    string constant INVALID_SELECTOR = \"INVS\";\n    string constant INVALID_STATE = \"INVST\";\n    string constant INVALID_LENGTH = \"INVL\";\n    string constant LOCK = \"LCKD\";\n    string constant DISABLED = \"DIS\";\n}\n"
    },
    "contracts/libraries/external/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.9;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // diff: original lib works under 0.7.6 with overflows enabled\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            // diff: original uint256 twos = -denominator & denominator;\n            uint256 twos = uint256(-int256(denominator)) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // diff: original lib works under 0.7.6 with overflows enabled\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n"
    },
    "contracts/oracles/UniV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: BSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../interfaces/external/univ2/IUniswapV2Pair.sol\";\nimport \"../interfaces/external/univ2/IUniswapV2Factory.sol\";\nimport \"../interfaces/oracles/IUniV2Oracle.sol\";\nimport \"../libraries/CommonLibrary.sol\";\nimport \"../utils/ContractMeta.sol\";\n\ncontract UniV2Oracle is ContractMeta, IUniV2Oracle, ERC165 {\n    /// @inheritdoc IUniV2Oracle\n    IUniswapV2Factory public immutable factory;\n    /// @inheritdoc IUniV2Oracle\n    uint8 public constant safetyIndex = 1;\n\n    constructor(IUniswapV2Factory factory_) {\n        factory = factory_;\n    }\n\n    // -------------------------  EXTERNAL, VIEW  ------------------------------\n\n    /// @inheritdoc IOracle\n    function price(\n        address token0,\n        address token1,\n        uint256 safetyIndicesSet\n    ) external view returns (uint256[] memory pricesX96, uint256[] memory safetyIndices) {\n        bool isSwapped = false;\n        if (token0 > token1) {\n            (token0, token1) = (token1, token0);\n            isSwapped = true;\n        }\n        if (((safetyIndicesSet >> safetyIndex) & 1) != 1) {\n            return (pricesX96, safetyIndices);\n        }\n        IUniswapV2Pair pool = IUniswapV2Pair(factory.getPair(token0, token1));\n        if (address(pool) == address(0)) {\n            return (pricesX96, safetyIndices);\n        }\n        (uint112 reserve0, uint112 reserve1, ) = pool.getReserves();\n        pricesX96 = new uint256[](1);\n        safetyIndices = new uint256[](1);\n        if (isSwapped) {\n            pricesX96[0] = FullMath.mulDiv(reserve0, CommonLibrary.Q96, reserve1);\n        } else {\n            pricesX96[0] = FullMath.mulDiv(reserve1, CommonLibrary.Q96, reserve0);\n        }\n        safetyIndices[0] = safetyIndex;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return super.supportsInterface(interfaceId) || type(IUniV2Oracle).interfaceId == interfaceId;\n    }\n\n    // -------------------  INTERNAL, VIEW  -------------------\n\n    function _contractName() internal pure override returns (bytes32) {\n        return bytes32(\"UniV2Oracle\");\n    }\n\n    function _contractVersion() internal pure override returns (bytes32) {\n        return bytes32(\"1.0.0\");\n    }\n}\n"
    },
    "contracts/utils/ContractMeta.sol": {
      "content": "// SPDX-License-Identifier: BSL-1.1\npragma solidity 0.8.9;\n\nimport \"../interfaces/utils/IContractMeta.sol\";\n\nabstract contract ContractMeta is IContractMeta {\n    // -------------------  EXTERNAL, VIEW  -------------------\n\n    function contractName() external pure returns (string memory) {\n        return _bytes32ToString(_contractName());\n    }\n\n    function contractNameBytes() external pure returns (bytes32) {\n        return _contractName();\n    }\n\n    function contractVersion() external pure returns (string memory) {\n        return _bytes32ToString(_contractVersion());\n    }\n\n    function contractVersionBytes() external pure returns (bytes32) {\n        return _contractVersion();\n    }\n\n    // -------------------  INTERNAL, VIEW  -------------------\n\n    function _contractName() internal pure virtual returns (bytes32);\n\n    function _contractVersion() internal pure virtual returns (bytes32);\n\n    function _bytes32ToString(bytes32 b) internal pure returns (string memory s) {\n        s = new string(32);\n        uint256 len = 32;\n        for (uint256 i = 0; i < 32; ++i) {\n            if (uint8(b[i]) == 0) {\n                len = i;\n                break;\n            }\n        }\n        assembly {\n            mstore(s, len)\n            mstore(add(s, 0x20), b)\n        }\n    }\n}\n"
    }
  }
}}